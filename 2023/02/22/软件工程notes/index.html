
<!DOCTYPE html>
<html lang="zh" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>软工笔记 - SZH&#39;s blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="shanzhihan&#39;s blog,"> 
    <meta name="description" content="一生所求是做个温柔又强大的人,开个坑，期末复习用。参考 这位 和 这位 的笔记，并做了补充。
第一章 软件工程概述
软件的定义软件的发展和软件危机软件工程的概念

程序的定义：程序&amp;#x3D;算法+数据结构。
软件的定义： &amp;#,"> 
    <meta name="author" content="szh"> 
    <link rel="alternative" href="atom.xml" title="SZH&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/icoon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="软工笔记 - SZH&#39;s blog"/>
    <meta name="twitter:description" content="一生所求是做个温柔又强大的人,开个坑，期末复习用。参考 这位 和 这位 的笔记，并做了补充。
第一章 软件工程概述
软件的定义软件的发展和软件危机软件工程的概念

程序的定义：程序&amp;#x3D;算法+数据结构。
软件的定义： &amp;#,"/>
    
    
    
    
    <meta property="og:site_name" content="SZH&#39;s blog"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="软工笔记 - SZH&#39;s blog"/>
    <meta property="og:description" content="一生所求是做个温柔又强大的人,开个坑，期末复习用。参考 这位 和 这位 的笔记，并做了补充。
第一章 软件工程概述
软件的定义软件的发展和软件危机软件工程的概念

程序的定义：程序&amp;#x3D;算法+数据结构。
软件的定义： &amp;#,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 6.0.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">SZH&#39;s blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://blog.szhhh.top"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">软工笔记</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <!--
 * @Date: 2023-03-05 08:54:47
 * @LastEditors: ShanZhihan
 * @LastEditTime: 2023-03-18 16:23:49
 * @FilePath: \diaspora\layout\_partial\post\article.ejs
-->
<div class="article">
    <div class='main'>
        <h1 class="title">软工笔记</h1>
        <div class="stuff">
            <span>二月 22, 2023</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/course/" rel="tag">course</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" rel="tag">软件工程</a></li></ul>


        </div>
        
        <div class="content markdown">
            <p>开个坑，期末复习用。<br>参考 <a target="_blank" rel="noopener" href="https://blog.xqmmcqs.com/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">这位</a> 和 <a target="_blank" rel="noopener" href="https://bakanetwork.github.io/ComputerArchitecture/#/%E6%9E%81%E9%99%90%E5%A4%8D%E4%B9%A0eXtremeReviewing.md">这位</a> 的笔记，并做了补充。</p>
<h2 id="第一章-软件工程概述"><a href="#第一章-软件工程概述" class="headerlink" title="第一章 软件工程概述"></a>第一章 软件工程概述</h2><blockquote>
<p>软件的定义<br>软件的发展和软件危机<br>软件工程的概念</p>
</blockquote>
<p>程序的定义：程序&#x3D;算法+数据结构。</p>
<p>软件的定义： &#x3D;&#x3D;软件是包括程序、数据及其相关文档的完整集合。&#x3D;&#x3D; 程序和数据是构造软件的基础，文档是软件质量的保证，也是保证软件更新及生命周期长短的必需品。</p>
<p><strong>软件危机</strong>：计算机软件在开发和维护过程中遇到一系列严重问题，导致软件行业的信任危机。具体表现在：</p>
<ol>
<li>软件的开发成本难以估算，无法制定合理的开发计划。</li>
<li>用户的需求无法确切表达。</li>
<li>软件质量存在问题。</li>
<li>软件的可维护性差。</li>
<li>缺乏文档资料。</li>
</ol>
<p>产生软件危机的原因：</p>
<ul>
<li>软件系统本身的复杂性。</li>
<li>软件开发的方法和技术不合理不成熟。</li>
</ul>
<p>软件工程定义：运用工程化原则和方法，组织软件开发解决软件危机。</p>
<p>软件工程的<strong>三要素</strong>：&#x3D;&#x3D;方法、工具、过程&#x3D;&#x3D;。方法提供了“如何做”的技术、工具提供了自动或半自动的软件支撑环境、过程将方法和工具综合起来以达到合理及时地进行计算机软件开发的目的。</p>
<p>软件工程的<strong>目标</strong>：在<strong>给定成本和时间</strong>的前提下，开发出满足用户需求且具有&#x3D;&#x3D;正确性、可用性&#x3D;&#x3D;等因素的软件产品。</p>
<p>软件工程<strong>项目三个基本目标</strong>：合理的进度、有限的经费、一定的质量。（和上条类似）</p>
<p>软件工程的终极目标：摆脱手工生产软件的状况，逐步实现软件研制和维护的自动化。</p>
<p>软件工程知识体系指南<br>SWEBOK（Guide to SoftWare Engineering Body of Knowledge）</p>
<p><img src="https://api2.mubu.com/v3/document_image/338ef7d0-4ea9-4fac-b164-5481d7ad0c84-16175743.jpg" alt="1"></p>
<h2 id="第二章-生命周期模型"><a href="#第二章-生命周期模型" class="headerlink" title="第二章 生命周期模型"></a>第二章 生命周期模型</h2><p>points:</p>
<blockquote>
<p>软件生命周期概念<br>传统软件生命周期模型<br>新型软件生命周期模型</p>
</blockquote>
<p>软件工程项目三个基本目标：合理的进度、有限的经费、一定的质量。</p>
<p>戴明环：<strong>PDCA——Plan，Do，Check，Action</strong>。(美国质量管理专家戴明博士针对工程项目的指令目标提出的)</p>
<p><strong>软件工程过程</strong>是为了获得软件产品，在软件工具的支持下由软件工程师完成的一系列软件工程活动。主要活动有：</p>
<ul>
<li>软件规格说明：规定软件功能及其使用限制。</li>
<li>软件开发：产生满足规格说明的软件。</li>
<li>软件确认：通过有效性验证以保证软件能够满足客户要求。</li>
<li>软件演进：为了满足客户变更要求，软件在使用过程中不断地改进。</li>
</ul>
<h3 id="软件生命周期概念"><a href="#软件生命周期概念" class="headerlink" title="软件生命周期概念"></a>软件生命周期概念</h3><p>软件产品从考虑其概念开始，到该产品不再使用为止的整个时期。包括<strong>概念阶段、分析与设计阶段、构造阶段、移交和运行阶段</strong>等不同时期。</p>
<p>软件生命周期六个基本步骤：PDDDCA<br>(相当于戴明环PDCA的细分)</p>
<ul>
<li><strong>制定计划 P</strong><br><font size =2>确定总目标，给出各方面的要求，可行性研究，预估可用资源，提交审查</font></li>
<li><strong>需求分析 D</strong><br><font size =2>详细进行需求分析，初步编写说明书和用户手册</font></li>
<li><strong>设计 D</strong><br><font size =2>概要设计、详细设计</font></li>
<li><strong>程序编码 D</strong><br><font size =2>就是写代码给过程</font></li>
<li><strong>软件测试 C</strong><br><font size =2>单元测试、组装测试</font></li>
<li><strong>运行维护 A</strong><br><font size =2>改正性维护，适应性维护，完善性维护。<br>软件维护是更加复杂的软件开发活动。</font></li>
</ul>
<p>软件过程模型：从一个特定角度提出的对软件过程的概括描述，是对软件开发过程的抽象，包括构成软件过程的各种<strong>活动(Activity)<strong>、</strong>软件工件(Artifacts)<strong>、</strong>参与角色(Actors&#x2F;Roles)</strong> 等。</p>
<p>软件生命周期模型：一个框架，描述软件需求定义直至软件经过使用后废弃为止，跨越整个生命期的软件开发、运行、维护所实施的全部<strong>过程、活动、任务</strong>。同时描述生命周期不同阶段产生的<strong>软件工件，明确活动的执行角色</strong>等。</p>
<h3 id="传统软件生命周期模型"><a href="#传统软件生命周期模型" class="headerlink" title="传统软件生命周期模型"></a>传统软件生命周期模型</h3><p>传统模型种类：瀑布模型、演化模型、增量模型、喷泉模型、V&amp;W 模型、螺旋模型、构件组装模型、快速应用开发模型、原型方法。</p>
<h4 id="瀑布模型-Water-Fall-Model"><a href="#瀑布模型-Water-Fall-Model" class="headerlink" title="瀑布模型 Water Fall Model"></a>瀑布模型 Water Fall Model</h4><p><strong>是所有其他软件生命周期模型的基础，最经典。</strong><br>1970年提出的，属于是软件危机的关键时期。<br><img src="https://api2.mubu.com/v3/document_image/2eec8cce-b4f6-4bc3-8d69-a2986079fc79-16175743.jpg" alt="waterfall"></p>
<p><img src="https://api2.mubu.com/v3/document_image/7c061528-7e92-42d8-aab8-24ab33ba4df6-16175743.jpg" alt="backroll"></p>
<ul>
<li>特征<ul>
<li>文档驱动，本阶段的工作对象来自于上一阶段活动的输出文档。</li>
<li>每个阶段要产生本阶段的输出——软件文件</li>
<li>每个阶段结束都有评审，方便出现问题立即解决。</li>
</ul>
</li>
<li>优点<ul>
<li>降低开发复杂度、提高透明性可管理性。</li>
<li>&#x3D;&#x3D;推迟了软件实现，强调必须先分析和设计。&#x3D;&#x3D;</li>
<li>对本阶段活动执行情况进行评审，以文档评审等手段指导整个开发过程，保证了错误不会留到下一个周期。</li>
</ul>
</li>
<li>缺点<ul>
<li>缺乏灵活性，无法解决需求不明或不准确的问题。</li>
<li>风险控制能力较弱。</li>
<li>文档过多时，增加工作量。且文档的完成情况并不能完全反映实际项目情况，导致错误结论。</li>
</ul>
</li>
</ul>
<h4 id="演化模型-Evolutional-Model"><a href="#演化模型-Evolutional-Model" class="headerlink" title="演化模型 Evolutional Model"></a>演化模型 Evolutional Model</h4><p><img src="https://api2.mubu.com/v3/document_image/a4e081e5-94ec-4d25-9f46-a7781364fd41-16175743.jpg" alt="yanhua"></p>
<ul>
<li>提倡两次开发（Do Twice）：第一次得到试验性的原型产品，探索可行性，明确需求。第二次在此基础上开发成品。</li>
</ul>
<blockquote>
<p>相对于瀑布模型而言,演化模型的一个明显优点就是可以处理需求不明确的软件项目，对于探索式的演化模型,能够在开发过程中间逐步向用户展示软件半成品,降低系统的开发风险。<br>另外,演化模型将用户的参与始终贯穿在开发过程中,使最终的软件系统能够真实地实现用户需求,又保障系统质量。</p>
</blockquote>
<ul>
<li><p>(1)<strong>探索式</strong>演化模型：其目标是与用户一起工作,共同探索系统需求,直到最后交付系统。</p>
</li>
<li><p>(2)<strong>抛弃式</strong>演化模型：通过实现一个或多个系统原型理解和明确用户需求,然后给出系统一个较好的需求定义。</p>
</li>
<li><p>优点：<br>明确用户需求、提高系统质量、降低开发风险。</p>
</li>
<li><p>缺点：</p>
<ul>
<li>难于管理、结构较差、技术不成熟。</li>
<li>可能会抛弃瀑布模型的文档控制优点。</li>
<li>缺乏设计，可能导致软件系统结构较差。</li>
</ul>
</li>
<li><p>适用范围：需求不清楚、中小型系统、开发周期短。</p>
</li>
</ul>
<h4 id="增量模型-Incremental-Model"><a href="#增量模型-Incremental-Model" class="headerlink" title="增量模型 Incremental Model"></a>增量模型 Incremental Model</h4><ul>
<li>首先对系统最核心或最清晰的需求进行分析、设计、实现、测试。再按优先级逐步对后续的需求进行上述开发工作。<strong>结合了演化和瀑布模型的优点。</strong><br><img src="https://api2.mubu.com/v3/document_image/2d117c6c-eef1-4e14-9f71-01b34cbc348f-16175743.jpg" alt="incremental"></li>
</ul>
<blockquote>
<p>在增量模型中,客户大概或模糊地提出系统须提供的服务或功能,即给出系统的需求框架,以及这些服务或功能的重要作用,从而可以确定系统需求实现的优先级。<br>为了避免多个增量集成时导致不一致的系统体系结构,增量模型在获取系统框架需求后,针对核心需求及系统的性能要求确定系统的体系结构,并以此体系结构指导增量的集成,保证在整个开发过程中体系结构稳定。</p>
</blockquote>
<ul>
<li>优点：<ul>
<li>第一次增量实现系统核心功能，增强客户使用系统的信心。</li>
<li><u>项目总体失败风险较低,因为先开发核心功能</u>，即使某一次增量失败，核心功能还是能用。</li>
<li>最高优先级的功能先开发，得到最多测试，<u>保障可靠性</u>。</li>
<li>增量在同一体系指导下进行集成，提高稳定性和可维护性。</li>
</ul>
</li>
<li>缺点：<ul>
<li>难以选择增量粒度。</li>
<li>难以确定所有需求。</li>
</ul>
</li>
</ul>
<h4 id="喷泉模型（迭代模型）Fountain-Model"><a href="#喷泉模型（迭代模型）Fountain-Model" class="headerlink" title="喷泉模型（迭代模型）Fountain Model"></a>喷泉模型（迭代模型）Fountain Model</h4><p>高情商：各个开发阶段没有特定次序要求，可以并行进行，可以随时补充遗漏的需求（低情商：想到什么做什么，瞎 JB 写）。(比较灵活，用的不多)<br>优点：提高开发效率、缩短开发周期。<br>缺点：难于管理。<br>适用于：需求不明晰。</p>
<h4 id="V-amp-W模型"><a href="#V-amp-W模型" class="headerlink" title="V&amp;W模型"></a>V&amp;W模型</h4><p>V模型在瀑布模型基础上改进，把测试活动提前，使得模型能够驾驭风险。后来Evolutif公司在V模型的基础上提出了W模型。</p>
<p><img src="https://api2.mubu.com/v3/document_image/8e964947-070a-4187-812b-4855c4c8635d-16175743.jpg" alt="v&amp;w"></p>
<p>V模型的左半部分就是在测试阶段之前的瀑布模型，即V模型的开发阶段，右半部分是测试阶段。V模型明确地划分测试的级别,并将其与开发阶段的活动对应。</p>
<p><img src="https://api2.mubu.com/v3/document_image/4b3c2f3d-2380-4a6a-b5f8-e86aeb86556f-16175743.jpg" alt="WW"></p>
<p>W模型强调：测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求和设计同样需要测试，即测试与开发是同步进行的。（相当于测试的时间提前了，并且贯穿整个软件的生命周期）<br>由于W模型扩展测试的内容：增加确认和验证活动，所以它有利于尽早地全面发现问题。</p>
<h4 id="螺旋模型-Spiral-Model"><a href="#螺旋模型-Spiral-Model" class="headerlink" title="螺旋模型 Spiral Model"></a>螺旋模型 Spiral Model</h4><p><img src="https://api2.mubu.com/v3/document_image/dfb95e35-8a21-448c-bf25-e5a778cbf75d-16175743.jpg" alt="luoxuan"></p>
<ul>
<li>针对大型软件开发项目的特点而提出来的。</li>
<li>分为<strong>四个象限</strong>螺旋上升：风险分析、制定计划、实施工程、客户评价——进入下一回路。</li>
<li>适用于：开发周期长、风险高的大型软件。</li>
</ul>
<p>构件组装模型：</p>
<ul>
<li><p>模块化思想，使用复用构件库的组件搭建系统。</p>
</li>
<li><p>优点：</p>
<ul>
<li>软件复用、提高效率。</li>
<li>允许多项目同时开发，降低费用、提高可维护性。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>缺乏通用构建组装标准风险较大。</li>
<li>构建可重用性与系统高效性不易协调。</li>
<li>过分依赖构件，构件质量影响产品质量。</li>
</ul>
</li>
</ul>
<h4 id="构件组装模型"><a href="#构件组装模型" class="headerlink" title="构件组装模型"></a>构件组装模型</h4><p><img src="https://api2.mubu.com/v3/document_image/a1f1766a-7dc6-4553-8e93-702aa973b0d1-16175743.jpg" alt="goujian"></p>
<ul>
<li><p>模块化思想，使用复用构件库的组件搭建系统。</p>
</li>
<li><p>优点：</p>
<ul>
<li>软件复用、提高效率。</li>
<li>允许多项目同时开发，降低费用、提高可维护性。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>缺乏通用构建组装标准，风险较大。</li>
<li>构建可重用性与系统高效性不易协调。</li>
<li>过分依赖构件，构件质量影响最终产品质量。</li>
</ul>
</li>
</ul>
<h4 id="快速应用开发模型（RAD）"><a href="#快速应用开发模型（RAD）" class="headerlink" title="快速应用开发模型（RAD）"></a>快速应用开发模型（RAD）</h4><p>英文是 Rapid Application Development</p>
<p><img src="https://api2.mubu.com/v3/document_image/a3bd5c9f-cc02-4282-b5ba-cb3cd2a64345-16175743.jpg" alt="RAD"></p>
<ul>
<li>开发周期 60-90 天(很短)，分小组同步进行软件各部分开发。</li>
<li>缺点：时间短，需要强沟通配合。不适合所有应用。</li>
<li>适用于：信息管理系统的开发，对于其他系统不太适合。</li>
</ul>
<h4 id="原型方法-Prototyping-Method"><a href="#原型方法-Prototyping-Method" class="headerlink" title="原型方法 Prototyping Method"></a>原型方法 Prototyping Method</h4><p>原型指的是 模拟某种最终产品的原始模型。<br>用户通过使用原型系统提出修改意见。<br>和增量好像也没什么区别<br><strong>主要用于明确需求</strong>，<u>也可以用于软件开发的其他阶段</u>。（划线部分也是它与增量模型和演化模型的区别）</p>
<p>由于运用原型的目的和方式不同,在使用原型时可采取以下两种不同的策略。</p>
<ol>
<li><strong>废弃策略</strong>:先构造一个功能简单而且性能要求不高的原型系统,针对用户使用这个原型系统后的评价和反馈,反复进行分析和改进,形成比较好的设计思想,据此设计出较完整,准确、一致、可靠的最终系统。系统构造完成后,原来的原型系统废弃不用。探索型和实验型原型属于这种策略。</li>
<li><strong>追加策略</strong>:先构造一个功能简单而且性能要求不高的原型系统,作为最终系统的核心,然后通过不断地扩充修改,逐步追加新要求,最后发展成为最终系统。它对应进化型原型。</li>
</ol>
<!-- ![2](https://api2.mubu.com/v3/document_image/16775692935997df0.jpg) -->
<p>原型方法的优点</p>
<ul>
<li><p>原型提供了用户与开发人员良好的沟通手段，易于被人们接受：</p>
<ul>
<li>原型方法有助于快速理解用户对于需求的真实想法 ；</li>
<li>可以容易地确定系统的性能，确认各项主要系统服务的可应用性，确认系统设计的可行性，确认系统作为产品的结果 ；</li>
<li>软件原型的最终版本，有的可以原封不动地成为产品，有的略加修改就可以成为最终系统的一个组成部分，这样有利于建成最终系统。</li>
</ul>
</li>
<li><p>原型法的适用范围和局限性：</p>
<ul>
<li>大型系统如不经过系统分析得到系统的整体划分，而直接用原型来模拟是很困难的。</li>
<li>对于大量运算的、逻辑性较强的程序模块，原型方法很难构造出该模块的原型来供人评价。</li>
<li>对于原有应用的业务流程、信息流程混乱的情况，原型构造与使用有一定的困难。</li>
</ul>
</li>
<li><p>原型方法存在的问题：</p>
<ul>
<li>文档容易被忽略。</li>
<li>建立原型的许多工作会被浪费掉 。</li>
<li>项目难以规划和管理。</li>
</ul>
</li>
</ul>
<h3 id="新型软件生命周期模型"><a href="#新型软件生命周期模型" class="headerlink" title="新型软件生命周期模型"></a>新型软件生命周期模型</h3><p>RUP（Rational Unified Process）</p>
<ul>
<li>软件生命周期分解为 4 各阶段：初始阶段（Inception）、细化阶段（Elaboration）、构造阶段（Construction）和交付阶段（Transition）。每个阶段结束于一个<strong>重要的里程碑</strong>。在阶段结尾评估是否满足阶段目标，评估通过允许项目进入下一阶段。<ul>
<li>初始阶段：软件目标里程碑。</li>
<li>细化阶段：体系结构里程碑。</li>
<li>构造阶段：运行能力里程碑。</li>
<li>移交阶段：产品发布里程碑。</li>
</ul>
</li>
<li>特点<ul>
<li>用例驱动</li>
<li>软件体系结构为核心</li>
<li>应用迭代及增量的新型软件生命周期模型。</li>
</ul>
</li>
</ul>
<p>适应性开发：<br>小步骤，快速反馈和调整</p>
<blockquote>
<p>RUP既是一种软件生命周期模型，又是一种支持面向对象软件开发的工具，它将软件开发过程要素和软件工件要素整合在统一的框架中 。</p>
</blockquote>
<p>敏捷及极限编程</p>
<blockquote>
<p>敏捷建模（Agile Modeling，AM）是由Scott W. Ambler从许多的软件开发过程实践中归纳总结出来的一些敏捷建模价值观、原则和实践等组成的，它是快速软件开发的一种<strong>思想代表</strong>，具体的应用有极限编程、SCRUM、水晶、净室开发等。<br><img src="https://api2.mubu.com/v3/document_image/c0000416-1155-417d-97bf-13f610dc1132-16175743.jpg" alt="AM"></p>
</blockquote>
<ul>
<li>XP 极限编程(eXtreme Programming)：基于敏捷建模思想，也是瀑布模型演化而来。</li>
<li>XP 强调用户满意，开发人员可以对需求的变化作出快速的反应。</li>
</ul>
<h2 id="第三章-软件需求分析"><a href="#第三章-软件需求分析" class="headerlink" title="第三章 软件需求分析"></a>第三章 软件需求分析</h2><blockquote>
<p>需求分析的对象、任务、目标<br>数据、功能、行为建模<br>需求类别</p>
</blockquote>
<h3 id="需求分析的对象、任务、目标"><a href="#需求分析的对象、任务、目标" class="headerlink" title="需求分析的对象、任务、目标"></a>需求分析的对象、任务、目标</h3><p>需求分析的<strong>必要性</strong></p>
<ul>
<li>需求分析是一项必须的软件工程活动。它在系统需求分析和软件设计之间起到<strong>桥梁</strong>的作用：<ul>
<li>它使得软件开发人员在系统分析的基础上深入描述软件的功能和性能、指明软件和其他系统元素的接口，建立软件必须满足的约束条件。</li>
<li>它允许软件开发人员对<strong>关键问题</strong>进行<strong>细化</strong>，并<strong>构建</strong>相应的<strong>分析模型</strong>：数据、功能和行为模型。</li>
<li>分析模型成为设计模型的基础，需求规格说明书也为软件测试人员和用户提供了软件质量评估的依据。</li>
<li>它能准确表达用户对系统的各项要求。</li>
</ul>
</li>
</ul>
<p>分析模型</p>
<ul>
<li>数据模型</li>
<li>功能模型</li>
<li>行为模型</li>
</ul>
<p>需求分析的对象：用户要求。</p>
<p>需求分析的<strong>任务</strong>：准确地定义新系统的目标，回答系统“做什么”的问题，<strong>编写需求规格说明书</strong>（结果）</p>
<p>需求分析的<strong>目标</strong>：借助于当前（业务）系统的逻辑模型导出目标系统的逻辑模型，解决目标系统的“做什么”的问题。</p>
<p>需求分析的操作性原则：</p>
<ul>
<li>表示和理解问题的信息域（数据）。</li>
<li>定义软件功能。</li>
<li>表示软件行为。</li>
</ul>
<p>用户需求说明书与软件需求规格说明书的区别：前者主要采用自然语言来表达用户需求，后者采用规范的建模语言表示。<strong>后者是前者的细化，更多地采用计算机语言和图形符号来刻画需求。软件需求规格说明书是软件系统设计的直接依据。</strong></p>
<p>需求规格说明书的内容：需求分析模型。（描述系统需要做什么，而非如何做系统）</p>
<ul>
<li>给出当前系统及目标系统的逻辑视图，以及当前系统的物理视图。</li>
<li>逻辑模型给出软件要达到的功能和处理数据之间的关系，而非实现细节。</li>
<li>物理模型给出业务环境中的业务实体和业务处理流程，是抽象出当前系统逻辑模型的基础。</li>
</ul>
<p>常用的建模分析方法有：SA（面向数据流的结构化分析方法）、JSD（面向数据结构的 Jackson 方法）、OOA（面向对象的分析方法）等。</p>
<h3 id="数据、功能、行为建模"><a href="#数据、功能、行为建模" class="headerlink" title="数据、功能、行为建模"></a>数据、功能、行为建模</h3><p>数据模型：信息和内容关系、信息流、信息结构。</p>
<p>功能模型：对进入软件的信息和数据进行变换的模块，必须至少完成“输入、处理、输出”三个功能。</p>
<p>行为模型：大多数软件对来自外界的事件做出反应。行为模型创建了软件状态的表示，以及导致软件状态变化的事件的表示（状态机）。</p>
<h3 id="需求类别"><a href="#需求类别" class="headerlink" title="需求类别"></a>需求类别</h3><p><strong>功能需求</strong>：列举出所开发软甲你在功能上应做什么（最主要需求）。</p>
<p><strong>性能需求</strong>：给出所开发软件的技术性能指标。系统的实时性和其他时间要求（响应时间、处理时间、消息传送时间等）、资源配置要求、精确度、数据处理量等其他要求。</p>
<p><strong>环境需求</strong>：软件系统运行时所处环境的要求。① 硬件方面，采用什么机型、有什么外部设备、数据通信接口等。② 软件方面，采用什么支操作系统、数据库管理系统等。③ 使用方面，需要使用部门在制度上、人员技术水平上具备什么样的条件等。</p>
<p>其他需求类别：</p>
<ul>
<li>可靠性需求：软件的有效性和数据完整性。</li>
<li>安全保密需求。</li>
<li>用户界面需求。</li>
<li>资源使用需求：指所开发软件运行时所需的数据、软件、内存空间等各项资源。以及软件开发时的人力物力需求。</li>
<li>软件成本消耗与开发进度需求：软件项目立项之后，根据合同规定，对软件开发的进度和步骤费用提出要求，作为开发管理依据。</li>
<li>预估将来系统可能达到的目标：在开发过程中对系统将来可能的扩充与修改做准备。</li>
</ul>
<h2 id="第四章-面向对象分析"><a href="#第四章-面向对象分析" class="headerlink" title="第四章 面向对象分析"></a>第四章 面向对象分析</h2><blockquote>
<p>UML<br>面向对象分析模型<br>    1. 领域建模<br>    2. 用例建模</p>
</blockquote>
<h3 id="UML概念及画法"><a href="#UML概念及画法" class="headerlink" title="UML概念及画法"></a>UML概念及画法</h3><p>UML（Unified Modeling Language）：面向对象的统一建模语言。是一种建模语言规格说明，是一种表示的标准。不是过程也不是方法，但允许任何一种过程和方法使用它。</p>
<p>4+1 视图：从不同视角为系统架构建模，形成系统的不同视图。分别为：</p>
<ul>
<li>用例视图Use Case View（用户模型视图、场景视图）：强调从用户角度看到的或需要的系统功能。</li>
<li>逻辑视图Logical view（结构模型视图、静态视图）：展现系统的静态或结构组成及特征。</li>
<li>进程视图Process View（行为模型视图、过程视图、协作视图、动态视图）：描述设计的并发和同步等特性，关注系统非功能性需求。</li>
<li>构件视图Component View（实现模型视图、开发视图）：关注代码的静态组织与管理。</li>
<li>部署视图Deployment View（环境模型视图、物理视图）：描述硬件的拓扑结构以及软件和硬件的映射问题，关注系统非功能性需求（性能、可靠性等）。<br><img src="https://api2.mubu.com/v3/document_image/1b6cde9d-8b76-4f23-b95c-739c2cd5da71-16175743.jpg" alt="2"></li>
</ul>
<p>每一种 UML的视图都是由一个或多个图(Diagram)组成的,一个图就是系统架构在某个侧面的表示,所有的图组成系统的完整视图。UML 规范提供下述9种基本的图形元素：</p>
<ul>
<li><strong>用例图 Use Case Diagram：从用户的角度描述系统的功能</strong>。</li>
<li><strong>类图 Class Diagram：描述系统的静态结构（类及其相互关系）</strong>。</li>
<li>对象图：描述系统在某个时刻的静态结构（对象及其相互关系）。</li>
<li><strong>顺序图 Sequence Diagram：按时间顺序描述系统元素间的交互</strong>。</li>
<li><strong>协作图 Collaboration Diagram：按照时间空间的顺序描述系统元素间的交互和他们之间的关系</strong>。</li>
<li>状态图 State Diagram：描述系统元素（对象）的状态条件和响应。</li>
<li>活动图 Activity Diagram：描述了系统元素之间的活动。</li>
<li>构件图 Componet Diagram：描述了实现系统的元素（类或包）组织。</li>
<li>部署图 Deployment Diagram：描述了环境元素的配置并把实现系统的元素映射到配置上。</li>
</ul>
<p>UML 视图与图的关系：</p>
<ul>
<li><mark>用例视图——用例图和活动图。</mark></li>
<li><mark>逻辑视图——类图、对象图、顺序图&#x2F;协作图。</mark></li>
<li>进程试图——状态图、活动图。</li>
<li>构件视图——构件图。</li>
<li>部署视图——部署图。</li>
</ul>
<h4 id="UML类图的画法"><a href="#UML类图的画法" class="headerlink" title="UML类图的画法"></a>UML类图的画法</h4><h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><h5 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h5><p><img src="https://api2.mubu.com/v3/document_image/a4f9f78c-bcd3-4142-b74a-d76f0187fb97-16175743.jpg" alt="2"></p>
<h6 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h6><p>当发现一个类“须知道”另一个类并使用它的对象时,这两个对象之间存在依赖关系。</p>
<blockquote>
<p>注意:此时声明两个类之间存在依赖关系时,仅仅说明它们在对象的级别上存在关系,而非对象的内部属性和操作,因此依赖关系是类之间关系最薄弱的环节。UML规范中用带有箭头的虚线表示依赖关系,并且特别注意两个概念类之间谁依赖谁。</p>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/74763d62-6fb8-43ae-8c06-47a005ed46bb-16175743.jpg" alt="2"></p>
<h6 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h6><p>当一个类的属性声明另一个类的对象或者定义另一个类的对象引用时﹐说明这两个类之间存在关联关系。</p>
<p><img src="https://api2.mubu.com/v3/document_image/babe96c8-3538-4477-a518-e328a8cca58c-16175743.jpg" alt="2"></p>
<h6 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h6><p>当一个类A(整体类)拥有另一个类B(部分类),<strong>同时其他的类C也可分享类B</strong>,即类B不完全被类A所拥有时,它们之间存在聚合关系。</p>
<p><img src="https://api2.mubu.com/v3/document_image/4d1ccd95-23c8-48cd-bd6f-0c88811d52d7-16175743.jpg" alt="2"><br><img src="https://api2.mubu.com/v3/document_image/193b9306-ea6f-4201-981c-370fbfae2677-16175743.jpg" alt="2"></p>
<h6 id="类的组合关系"><a href="#类的组合关系" class="headerlink" title="类的组合关系"></a>类的组合关系</h6><p>当一个类A(整体类)完全拥有另一个类B(部分类),<strong>且其他任何类都不能分享类B时</strong>，它们之间存在组合关系。当整体类消失时,部分类也不会存在。</p>
<h6 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h6><p>当一个类(父类)是另外一个类或一些类(子类)的类型时,它们之间存在继承或者泛化关系。</p>
<p><img src="https://api2.mubu.com/v3/document_image/e3a010cc-3a53-485e-b456-0e38ebaa7cbb-16175743.jpg" alt="2"></p>
<h6 id="关联类"><a href="#关联类" class="headerlink" title="关联类"></a>关联类</h6><p>在关联建模中,存在一些情况下,需要其他类,因为它包含关于关联有价值的信息。对于这种情况,使用关联类来绑定这些基本关联。关联类和一般类一样表示。不同的是,主类和关联类之间用一条相交的点线连接。</p>
<p><img src="https://api2.mubu.com/v3/document_image/db09d3cc-7b60-4dde-9be6-590703d246ff-16175743.jpg" alt="2"></p>
<h3 id="面向对象的需求分析建模"><a href="#面向对象的需求分析建模" class="headerlink" title="面向对象的需求分析建模"></a>面向对象的需求分析建模</h3><p><img src="https://api2.mubu.com/v3/document_image/f2be816c-c1f8-452e-8691-1dd10c09dd7a-16175743.jpg" alt="2"></p>
<h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><p>领域模型：领域内概念类或对象的抽象可视化表示（将客观世界中的事物可视化抽象化）。主要用于概括地描述业务背景和重要的业务流程，通过类图和活动图展示。</p>
<ul>
<li>业务背景：描述概念类之间的关系，表示成能够代表业务知识结构的类图。</li>
<li>业务流程：由角色及其执行的活动构成。由活动图描述。</li>
</ul>
<p>创建领域模型的步骤：</p>
<ol>
<li>找出当前需求中的候选概念类。</li>
<li>在领域模型中描述这些概念类。用问题域中的词汇对概念类命名，将与当前需求无关的概念类排除。</li>
<li>在概念类之间添加必要的关联来记录关系。用关联、继承、组合&#x2F;聚合表示。</li>
<li>在概念类中添加用来实现需求必要的属性。</li>
</ol>
<p>识别概念类或属性：</p>
<ul>
<li>属性一般是可以赋值的（如数字、文本），而概念类不可以。</li>
<li>如果对一个名词是概念类还是属性不确定，将其作为概念类处理。</li>
<li>不存在名词到类的映射机制，因为自然语言具有二义性。</li>
</ul>
<p>领域模型中的关联可分为两种：“需要知道”型和“只需理解”型关联，着重考虑前者。</p>
<ul>
<li>“<mark>须</mark>要知道”型关联：需要将概念之间的关系信息保持一段时间的关联。领域模型中需要着重考虑。</li>
<li>“只需理解”型关联：有助于增强对领域中关键概念的理解的关联.</li>
</ul>
<p>寻找关联时要遵循下述指导原则：</p>
<ul>
<li>将注意力集中在须要知道型关联。</li>
<li>识别概念类比识别关联更重要，因此领域模型创建过程中应该更加注重概念类的识别。</li>
<li>太多的关联不仅不能有效地表示领域模型，反而容易使领域模型变得混乱。<br>避免显示冗余或导出关联。</li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="/music/溯.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="/music/mine.mp3"></li>
                        
                    
                        
                            <li title="2" data-url="/music/诀别书.mp3"></li>
                        
                    
                        
                            <li title="3" data-url="/music/七年了，他还是走不出来.mp3"></li>
                        
                    
                        
                            <li title="4" data-url="/music/《溯 Reverse》.mp3"></li>
                        
                    
                        
                            <li title="5" data-url="/music/《託された想い (被寄托的思念)—増田俊郎》.mp3"></li>
                        
                    
                        
                            <li title="6" data-url="/music/【钢琴】《所念皆星河 》.mp3"></li>
                        
                    
                        
                            <li title="7" data-url="/music/【钢琴】陈奕迅《富士山下》.mp3"></li>
                        
                    
                        
                            <li title="8" data-url="/music/【钢琴】花之舞 《Flower Dance》.mp3"></li>
                        
                    
                        
                            <li title="9" data-url="/music/【钢琴】周杰伦《反方向的钟》.mp3"></li>
                        
                    
                        
                            <li title="10" data-url="/music/【钢琴】周杰伦《青花瓷》.mp3"></li>
                        
                    
                        
                            <li title="11" data-url="/music/I Really Like You.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link"
		data-enable="true"
        data-ae="true"
        data-ci="86a92b9df49e55c6beaf"
        data-cs="b740ee88f80bbd33b4109f0c18a4f049a00a6439"
        data-r="CommentRepo"
        data-o="0bluewhale0"
        data-a="0bluewhale0"
        data-d="true"
    >查看评论</div>


    </div>
    
        <div class="side">
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">第一章 软件工程概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B"><span class="toc-text">第二章 生命周期模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A6%82%E5%BF%B5"><span class="toc-text">软件生命周期概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B"><span class="toc-text">传统软件生命周期模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B-Water-Fall-Model"><span class="toc-text">瀑布模型 Water Fall Model</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E5%8C%96%E6%A8%A1%E5%9E%8B-Evolutional-Model"><span class="toc-text">演化模型 Evolutional Model</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B-Incremental-Model"><span class="toc-text">增量模型 Incremental Model</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B%EF%BC%89Fountain-Model"><span class="toc-text">喷泉模型（迭代模型）Fountain Model</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V-amp-W%E6%A8%A1%E5%9E%8B"><span class="toc-text">V&amp;W模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B-Spiral-Model"><span class="toc-text">螺旋模型 Spiral Model</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E4%BB%B6%E7%BB%84%E8%A3%85%E6%A8%A1%E5%9E%8B"><span class="toc-text">构件组装模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%EF%BC%88RAD%EF%BC%89"><span class="toc-text">快速应用开发模型（RAD）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95-Prototyping-Method"><span class="toc-text">原型方法 Prototyping Method</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%9E%8B%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B"><span class="toc-text">新型软件生命周期模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">第三章 软件需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BB%BB%E5%8A%A1%E3%80%81%E7%9B%AE%E6%A0%87"><span class="toc-text">需求分析的对象、任务、目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E3%80%81%E5%8A%9F%E8%83%BD%E3%80%81%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1"><span class="toc-text">数据、功能、行为建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E7%B1%BB%E5%88%AB"><span class="toc-text">需求类别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90"><span class="toc-text">第四章 面向对象分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%94%BB%E6%B3%95"><span class="toc-text">UML概念及画法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UML%E7%B1%BB%E5%9B%BE%E7%9A%84%E7%94%BB%E6%B3%95"><span class="toc-text">UML类图的画法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">基本结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">类之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-text">依赖关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="toc-text">关联关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-text">聚合关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-text">类的组合关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-text">类的继承关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E7%B1%BB"><span class="toc-text">关联类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%BB%BA%E6%A8%A1"><span class="toc-text">面向对象的需求分析建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B"><span class="toc-text">领域模型</span></a></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
