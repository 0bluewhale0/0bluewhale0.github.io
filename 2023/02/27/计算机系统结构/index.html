
<!DOCTYPE html>
<html lang="zh" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>系统结构笔记一、三章 - SZH&#39;s blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="shanzhihan&#39;s blog,"> 
    <meta name="description" content="一生所求是做个温柔又强大的人,第一章 基础知识1.1基本概念计算机系统的层次结构
计算机系统结构的定义：计算机系统结构(Computer Architecture)的经典定义是1964 年Amdahl在介绍IBM360系统时提出,"> 
    <meta name="author" content="szh"> 
    <link rel="alternative" href="atom.xml" title="SZH&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/icoon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="系统结构笔记一、三章 - SZH&#39;s blog"/>
    <meta name="twitter:description" content="一生所求是做个温柔又强大的人,第一章 基础知识1.1基本概念计算机系统的层次结构
计算机系统结构的定义：计算机系统结构(Computer Architecture)的经典定义是1964 年Amdahl在介绍IBM360系统时提出,"/>
    
    
    
    
    <meta property="og:site_name" content="SZH&#39;s blog"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="系统结构笔记一、三章 - SZH&#39;s blog"/>
    <meta property="og:description" content="一生所求是做个温柔又强大的人,第一章 基础知识1.1基本概念计算机系统的层次结构
计算机系统结构的定义：计算机系统结构(Computer Architecture)的经典定义是1964 年Amdahl在介绍IBM360系统时提出,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 6.0.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">SZH&#39;s blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://blog.szhhh.top"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">系统结构笔记一、三章</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <!--
 * @Date: 2023-03-05 08:54:47
 * @LastEditors: ShanZhihan
 * @LastEditTime: 2023-03-18 16:23:49
 * @FilePath: \diaspora\layout\_partial\post\article.ejs
-->
<div class="article">
    <div class='main'>
        <h1 class="title">系统结构笔记一、三章</h1>
        <div class="stuff">
            <span>二月 27, 2023</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/course/" rel="tag">course</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" rel="tag">计算机系统结构</a></li></ul>


        </div>
        
        <div class="content markdown">
            <h2 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h2><h3 id="1-1基本概念"><a href="#1-1基本概念" class="headerlink" title="1.1基本概念"></a>1.1基本概念</h3><p>计算机系统的<strong>层次结构</strong><br><img src="https://api2.mubu.com/v3/document_image/ecbda4a7-2b0f-472e-b610-4b2f5c30f0d0-16175743.jpg" alt="0"></p>
<p><strong>计算机系统结构</strong>的定义：<strong>计算机系统结构(Computer Architecture)的经典定义是1964 年Amdahl在介绍IBM360系统时提出的:计算机系统结构是指传统机器程序员所看到的计算机属性,即概念性结构与功能特性。</strong></p>
<p><strong>计算机组成</strong>的定义：计算机组成(Computer Organization)指的是计算机系统结构的逻辑实现,包含物理机器级中的<strong>数据流</strong>和<strong>控制流</strong>的组成以及<strong>逻辑设计</strong>等。它着眼于物理机器级内各事件的排序方式与控制方式,各部件的功能以及各部件之间的联系。</p>
<p><strong>计算机实现</strong>的定义：计算机实现(Computer Implementation)指的是计算机组成的物理实现,包括处理机、主存等部件的物理结构,器件的集成度和速度,模块、插件、底板的划分与连接,信号传输﹐电源、冷却及整机装配技术等。它着眼于器件技术和微组装技术,其中器件技术在实现技术中起主导作用。</p>
<p>举例辨析：</p>
<blockquote>
<p>(1)确定指令系统中是否有乘法指令属于计算机系统结构的内容,但乘法指令是用专门的乘法器实现,还是用加法器经多步操作来实现,属于计算机组成。而乘法器、加法器的物理实现﹐如器件的选定及所用的微组装技术等,属于计算机实现。</p>
</blockquote>
<hr>
<blockquote>
<p>(2）主存容量与编址方式(按位、按字节或按字访问等)的确定属于计算机系统结构。为了达到给定的性能价格比,主存速度应多快、逻辑结构是否采用多体交叉等属于计算机组成。而主存系统的物理实现,如器件的选定、逻辑电路的设计,微组装技术的使用等均属于计算机实现。</p>
</blockquote>
<p>计算机系统结构的<strong>分类</strong></p>
<ul>
<li>Flynn分类法：按照指令流和数据流的多倍性进行分类<br><img src="https://api2.mubu.com/v3/document_image/b0833a78-f9b2-495f-9a5f-983e9068cd19-16175743.jpg" alt="2"></li>
<li>冯式分类法：用系统的最大并行度对计算机进行分类<br><img src="https://api2.mubu.com/v3/document_image/476313ef-9aea-4ae2-ba9a-9f3d3631d873-16175743.jpg" alt="2"></li>
<li>Handler分类法：把计算机的硬件结构分成三个层次，并分别考虑它们的可并行-流水处理程度，将计算机用3对整数表示。<br>三个层次：<br><img src="https://api2.mubu.com/v3/document_image/571debbd-8e6a-438e-b164-4a04b9f182a8-16175743.jpg" alt="3"><br><img src="https://api2.mubu.com/v3/document_image/02b74744-0f6b-4233-bc6e-0a944b726fdb-16175743.jpg" alt="4"></li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/6D382E7290C141121677477905.jpg" alt="1"></p>
<p><img src="https://api2.mubu.com/v3/document_image/1677489160735e4b7.jpg" alt="1-2"></p>
<h3 id="1-2-计算机系统的设计"><a href="#1-2-计算机系统的设计" class="headerlink" title="1.2 计算机系统的设计"></a>1.2 计算机系统的设计</h3><h4 id="1-2-1-计算机系统设计的定量原理"><a href="#1-2-1-计算机系统设计的定量原理" class="headerlink" title="1.2.1 计算机系统设计的定量原理"></a>1.2.1 计算机系统设计的定量原理</h4><h5 id="大概率事件优先原理"><a href="#大概率事件优先原理" class="headerlink" title="大概率事件优先原理"></a>大概率事件优先原理</h5><p>（又叫经常性事件原则）: 优先加速使用频率高的部件。</p>
<ul>
<li>为获得明显的系统性能。对大概率 (经常性)事件，<br>赋予优先处理权和资源使用权。</li>
<li>加快处理频繁出现事件对系统的影响远比加速<br>处理很少出现事件的影响。</li>
</ul>
<h5 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h5><p>加快某部件执行速度所获得的系统性能(加速比)，与该部件在系统中总执行时间的比例（重要性）有关。<br><img src="https://api2.mubu.com/v3/document_image/493b86a0-5a70-47a5-af79-948f07288e1d-16175743.jpg" alt="2"><br><img src="https://api2.mubu.com/v3/document_image/c5e48e51-0bd1-4572-818b-d3a120ee87d0-16175743.jpg" alt="2"></p>
<p>加速比公式依赖于两个因素</p>
<ol>
<li>部件加速比 $S_e$</li>
<li>可改进比例 $F_e$</li>
</ol>
<h5 id="程序的局部性原理"><a href="#程序的局部性原理" class="headerlink" title="程序的局部性原理"></a>程序的局部性原理</h5><ul>
<li>程序的时间局部性<ul>
<li>程序即将用到的信息很可能就是目前正在使用的信息。</li>
</ul>
</li>
<li>程序的空间局部<ul>
<li>程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或者临近。</li>
</ul>
</li>
</ul>
<h5 id="CPU性能公式"><a href="#CPU性能公式" class="headerlink" title="CPU性能公式"></a>CPU性能公式</h5><p>$$<br>CPU_{时间} &#x3D; IC \times CPI \times t<br>$$<br>$$<br>&#x3D; \sum (CPI_i \times IC_i)<br>$$</p>
<p>$IC$:执行程序的指令条数<br>$CPI$:指令的平均时钟周期数<br>其中，$t&#x3D;\cfrac{1}{f}$</p>
<h4 id="1-2-2-计算机系统设计的主要内容"><a href="#1-2-2-计算机系统设计的主要内容" class="headerlink" title="1.2.2 计算机系统设计的主要内容"></a>1.2.2 计算机系统设计的主要内容</h4><p>工作方面：</p>
<ol>
<li>需求分析</li>
<li>软硬件功能划分： 经常使用的部分使用硬件加速</li>
<li>前瞻性</li>
</ol>
<h3 id="1-2-3-系统设计的主要方法"><a href="#1-2-3-系统设计的主要方法" class="headerlink" title="1.2.3 系统设计的主要方法"></a>1.2.3 系统设计的主要方法</h3><ol>
<li>top-down 设计</li>
<li>bottom-up 设计</li>
<li>middle-out 设计： 一般认为这个啥best的</li>
</ol>
<h3 id="1-3-计算机系统的性能评测"><a href="#1-3-计算机系统的性能评测" class="headerlink" title="1.3 计算机系统的性能评测"></a>1.3 计算机系统的性能评测</h3><h4 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h4><ol>
<li>执行时间</li>
<li>速度<ul>
<li>MIPS 每秒百万条指令数 million instructions per second</li>
<li>MFLOPS 每秒百万次浮点运算次数 million floating point operations per second</li>
</ul>
</li>
</ol>
<h5 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h5><p>$MIPS &#x3D; I_{N} &#x2F;(T_E \times 10^6)$<br>$&#x3D;I_{N} &#x2F;(I_{N} \times CPI \times t \times 10^6)$<br>$&#x3D;1 &#x2F; (CPI \times 10^6)$</p>
<p>$I_{N}$: 程序中的指令总数<br>$T_E$:执行程序的时间</p>
<p>只适用于评估标量计算机，对于并行计算的机器不能很好的评价。</p>
<h5 id="MFLOPS"><a href="#MFLOPS" class="headerlink" title="MFLOPS"></a>MFLOPS</h5><p>$MFLOPS &#x3D; I_{FN} &#x2F;(T_E \times 10^6)$</p>
<p>$I_{FN}$: 程序中的浮点运算次数<br>$T_E$:执行程序的时间</p>
<p>一般大型机都用MFLOPS来衡量计算机的速度，因为他不依赖于指令系统，与编译系统没有太大关系。</p>
<h4 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h4><ol>
<li>real程序</li>
<li>核心程序</li>
<li>小测试程序</li>
<li>综合测试程序</li>
</ol>
<p>性能比较：</p>
<ul>
<li>平均执行时间</li>
<li>加权平均</li>
<li>调和平均（？ $H_m$ 用于计算速度的<br>$$<br>H_m&#x3D;\cfrac{n}{\sum_{i&#x3D;1}^{n} \cfrac{1}{R_i}}<br>&#x3D; \cfrac{n}{\sum_{i&#x3D;1}^{n} T_i}<br>$$</li>
<li>几何平均（ $G_m$ 这个也是用来算速度的<ul>
<li>普通几何平均<br>$$<br>G_m &#x3D; \sqrt[n]{\prod_{i&#x3D;1}^n R_i}<br>&#x3D; \sqrt[n]{\prod_{i&#x3D;1}^n \cfrac{1}{T_i}}<br>$$</li>
<li>加权几何平均<br>$$<br>G_m &#x3D; \prod_{i&#x3D;1}^n (R_i)^{W_i}<br>$$</li>
</ul>
</li>
</ul>
<h3 id="1-4-计算机系统结构的发展"><a href="#1-4-计算机系统结构的发展" class="headerlink" title="1.4 计算机系统结构的发展"></a>1.4 计算机系统结构的发展</h3><h4 id="1-4-1-冯诺依曼结构"><a href="#1-4-1-冯诺依曼结构" class="headerlink" title="1.4.1 冯诺依曼结构"></a>1.4.1 冯诺依曼结构</h4><ul>
<li>ALU为中心</li>
<li>指令和数据被存储器认为是一样的玩意儿</li>
<li>存储器编码方式是一维的</li>
<li>指令由OP和ADDR组成，而且顺序执行</li>
</ul>
<p>改进：</p>
<ul>
<li>并行处理</li>
<li>指令系统系统的精简：CISC-&gt;RISC的转变，使CPI得到了很大的提高</li>
<li>输入输出方式的改进</li>
</ul>
<h4 id="1-4-2-软件对系统结构的影响"><a href="#1-4-2-软件对系统结构的影响" class="headerlink" title="1.4.2 软件对系统结构的影响"></a>1.4.2 软件对系统结构的影响</h4><p>软件可移植的ways：</p>
<ul>
<li><p>统一的高级语言：理想情况下的最方便的办法</p>
</li>
<li><p>系列机：就一个厂家生产的具有相同的系统结构，但是不同的组成&#x2F;实现的机器，比如intel？？？<br>  系列机又称兼容机，兼容包括：</p>
<ul>
<li>向上兼容：上下是指的机器的档次</li>
<li>向下兼容</li>
<li>向前兼容：前后指的是机器的版次</li>
<li>向后兼容</li>
</ul>
<p>  <strong>向后兼容是系列机的</strong> &#x3D;&#x3D;根本特征&#x3D;&#x3D;<br>  <img src="https://api2.mubu.com/v3/document_image/4612839b-f01f-4194-8db1-f603cf6f3573-16175743.jpg" alt="2"></p>
</li>
<li><p>模拟与仿真</p>
<ul>
<li>模拟：用软件方法中一台现有的机器上实现另一个机器的指令集，就是虚拟机</li>
<li>仿真：用<strong>微程序</strong> 在一台现有机器上实现另一台机器的指令集<ul>
<li>仿真只能在俩结构差别不大的机子之间使用，但是它快一点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-4-3-器件发展对系统结构的影响"><a href="#1-4-3-器件发展对系统结构的影响" class="headerlink" title="1.4.3 器件发展对系统结构的影响"></a>1.4.3 器件发展对系统结构的影响</h4><p>第几代计算机上按照 <strong>器件</strong> 来划分的</p>
<h4 id="1-4-4-应用对系统结构的影响"><a href="#1-4-4-应用对系统结构的影响" class="headerlink" title="1.4.4 应用对系统结构的影响"></a>1.4.4 应用对系统结构的影响</h4><p>应用需求上促使计算机系统结构发展的<strong>最根本的动力</strong><br>（需求带动发展）</p>
<p>专用性 和 通用性</p>
<h3 id="1-5-计算机系统结构中并行性的发展"><a href="#1-5-计算机系统结构中并行性的发展" class="headerlink" title="1.5 计算机系统结构中并行性的发展"></a>1.5 计算机系统结构中并行性的发展</h3><p>并行等级的发展：</p>
<ul>
<li>字串位串</li>
<li>字串位并：同时对一个字的全部位进行操作</li>
<li>字并位串：对许多字的同一位 ，位片</li>
<li>全并行：同时对 许多字的 全部&#x2F;部分位进行处理，是最高一级的并行</li>
</ul>
<h3 id="补充：Words"><a href="#补充：Words" class="headerlink" title="补充：Words"></a>补充：Words</h3><ul>
<li>CPI: clocks per instruction</li>
<li>IC: instruction counts</li>
<li>MIPS million instructions per second</li>
<li>MFLOPS million floating point operations per second</li>
<li>CISC 复杂指令集计算机</li>
<li>RISC 精简指令集计算机</li>
</ul>
<h2 id="第三章-流水线技术"><a href="#第三章-流水线技术" class="headerlink" title="第三章 流水线技术"></a>第三章 流水线技术</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="什么是流水线"><a href="#什么是流水线" class="headerlink" title="什么是流水线"></a>什么是流水线</h4><p>把一个重复的过程<strong>分解为若干个子过程</strong>,每个子过程由<strong>专门的功能部件</strong>来实现。把多个处理过程在<strong>时间上</strong>错开,依次通过各功能段,这样,每个子过程就可以与其他的子过程并行进行。<strong>这就是流水线技术(pipelining)。</strong></p>
<p>流水线中的<strong>每个子过程及其功能部件</strong>称为流水线的<strong>级或段</strong>(stage),段与段相互连接形成流水线。流水线的<strong>段数称为流水线的深度</strong>(Pipeline Depth)。</p>
<p>流水线技术的<strong>核心：部件功能专用化</strong>。</p>
<ol>
<li>一件工作按功能分隔为若干相互联系的部分</li>
<li>每一部分指定给专门部件（段）完成</li>
<li>各部件（段）执行过程时间重叠（时间并行性，并发性）</li>
<li>所有部件依次序分工完成工作。</li>
</ol>
<p>典型的指令流水线：</p>
<ul>
<li>三段：<strong>取指、分析、执行</strong><br>分别用独立的 取指、分析和执行 部件来实现<br>理想中是可以达到三倍</li>
<li>四段：<strong>取指</strong>（<strong>访问主存，取出指令</strong>，并送到<strong>指令寄存器</strong>）、<strong>译码</strong>（指令译码，分析，形成操作数地址并读取操作数）、<strong>执行</strong>（完成指令的功能）、<strong>存结果</strong>（将运算结果写回寄存器或主存）</li>
</ul>
<p>流水线的表示</p>
<ol>
<li>连接图<br><img src="https://api2.mubu.com/v3/document_image/41d793dc-7d91-44f1-a453-48240749298d-16175743.jpg" alt="ljt"></li>
<li>时空图<br><img src="https://api2.mubu.com/v3/document_image/b7ded8fd-6429-4ff4-b42a-38a31d704369-16175743.jpg" alt="skt"><br><img src="https://api2.mubu.com/v3/document_image/4b12b6c2-34bd-49fc-b77e-2cda16fd166e-16175743.jpg" alt="skt2"></li>
</ol>
<p>流水线<strong>通过时间</strong>和<strong>排空时间</strong>：</p>
<ul>
<li>通过时间：第一个任务从进入流水线到流出结果所需的时间，又称装入时间</li>
<li>排空时间：最后一个任务从进入流水线到流出结果所需的时间</li>
</ul>
<p>在装入和排空的过程中，流水线不满载。</p>
<p>各流水段时间尽可能相等，否则引起流水线堵塞、断流。指令通过流水线时间最长的段称为<strong>流水线瓶颈</strong>。</p>
<p>一个处理过程分解为若干个子过程（段），每个子过程以一个专门的功能部件来实现</p>
<p>每段流水线后面有一个缓冲寄存器，称为流水寄存器。有缓冲、隔离、同步作用。</p>
<h4 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h4><ul>
<li>按照流水线等级<ul>
<li>部件级流水线（运算操作流水线）：各类型的运算操作按流水方式进行。</li>
<li>处理机级流水线（指令流水线）：把一条指令的执行过程分段，按流水方式执行。</li>
<li>系统级流水线（宏流水线）：把多台处理机串行连接起来，每个处理机完成整个任务中的一部分。</li>
</ul>
</li>
<li>按照流水线所完成的功能分类<ul>
<li>单功能流水线：只能完成固定功能。</li>
<li>多功能流水线：流水线的各段可以进行不同连接，实现不同功能。</li>
</ul>
</li>
<li>针对多功能流水线做进一步分类<ul>
<li>静态流水线：同一时间内，多功能流水线中的各段只能按同一种功能的连接方式进行工作。</li>
<li>动态流水线：同一时间内，多功能流水线中的各段可以按照不同方式连接，同时执行多种功能。（而不需等到排空之后重新装入）</li>
</ul>
</li>
<li>按照流水线中是否有反馈回路<ul>
<li>线性流水线：流水线各段串行连接，每个段最多流过一次。</li>
<li>非线性流水线：流水线中有反馈回路，每个段可以流过多次。</li>
</ul>
</li>
<li>根据任务流入和流出的顺序是否相同来分类（考虑有多条流水线的机器）<ul>
<li>顺序流水线：流水线输出的任务顺序与输入的任务顺序相同。</li>
<li>乱序流水线：流水线输出的任务顺序与输入的顺序可以不同。（也称无序、错序、异步流水线）</li>
</ul>
</li>
</ul>
<h3 id="流水线性能计算和分析"><a href="#流水线性能计算和分析" class="headerlink" title="流水线性能计算和分析"></a>流水线性能计算和分析</h3><blockquote>
<p>主要的性能指标：<br><strong>吞吐率</strong><br><strong>加速比</strong><br><strong>效率</strong><br>流水线<strong>最佳段数</strong>也是一个重要指标<br>*公式可以不用背，理解概念就行</p>
</blockquote>
<h4 id="吞吐率-TP"><a href="#吞吐率-TP" class="headerlink" title="吞吐率 TP"></a><mark>吞吐率 TP</h4><p>单位时间内流水线<strong>完成的任务数量</strong>或<strong>输出结果的数量</strong>。(有的时候这两个不一定是一致的，这个时候我们倾向于采用输出结果的数量作为吞吐率的计算指标)</p>
<p>$$<br>T_p &#x3D; \cfrac{n}{T_k}<br>$$</p>
<ul>
<li>各段时间相等的流水线<br>理想的 k 段线性流水线完成 n 个连续任务的时间：$T_k &#x3D; (k+n-1) \Delta t$<br>实际吞吐率：$\cfrac{n}{(k+n-1) \Delta t}$<br>最大吞吐率：$TP_{max}&#x3D;\lim\limits_{n \to \infty} \cfrac{n}{(k+n-1) \Delta t} &#x3D; \cfrac{1}{\Delta t}$</li>
<li>各段时间不等的流水线<br>时间最长段称为流水线的瓶颈<br>$T_k &#x3D; \sum\limits_{i&#x3D;1}^k \Delta t_i + (n-1) \max (\Delta t_1,\Delta t_2,···,\Delta t_k)$</li>
</ul>
<p>这里配合ppt17页的图理解更佳<br>如下<br><img src="https://api2.mubu.com/v3/document_image/dfd7b368-77a1-4c9b-8cad-7e090ff6a034-16175743.jpg" alt="17"></p>
<p><strong>解决流水线瓶颈的方法</strong>：</p>
<ol>
<li>重复设置瓶颈段：让多个瓶颈流水段并行工作。<br>  相当于同一个活一个人干得三份时间，于是喊三个人来一起干<br>  <img src="https://api2.mubu.com/v3/document_image/7e23244b-ba2c-4d86-bf8d-5e527c4d7263-16175743.jpg" alt="2"></li>
<li>瓶颈段再细分：细分为多个子流水段（每个子流水段用时和非瓶颈段相同），形成超流水线。<br>  这个是把一个部件的功能再给往细了划分</li>
</ol>
<blockquote>
<p>Attention:<br>重复设置瓶颈段和瓶颈段再细分得到的T、TP和E是一样的。<br>且瓶颈段可能不仅仅只有一段，当有一段50+50+100+200的流水时，100和200都是瓶颈段。</p>
</blockquote>
<h4 id="加速比-S"><a href="#加速比-S" class="headerlink" title="加速比 S"></a><mark>加速比 S</h4><p>完成同样任务，不使用流水线所用时间与使用流水线所用时间之比。<br>$T_s:不使用流水线，T_k:使用流水线$<br>$$<br>S &#x3D; \cfrac{T_s}{T_k}<br>$$</p>
<ul>
<li>各段时间相等的 k 段流水线：<br>$S &#x3D; \cfrac{n \times k \Delta t}{(k+n-1) \Delta t}$<br>最大加速比：k</li>
<li>各段时间不等的流水线：<br>$S &#x3D; \cfrac{n \sum\limits_{i&#x3D;1}^k \Delta t_i}{\sum\limits_{i&#x3D;1}^k \Delta t_i + (n-1) \max (\Delta t_1,\Delta t_2,···,\Delta t_k)}$</li>
</ul>
<h4 id="效率-E"><a href="#效率-E" class="headerlink" title="效率 E"></a><mark>效率 E</h4><p>流水线中的设备实际使用时间与整个运行时间的比值，又称流水线设备利用率。</p>
<p>就是算的 <strong>时空图中有效的面积 &#x2F; 整个面积</strong></p>
<ul>
<li>连续完成 n 个任务，每段的效率计算：每段都执行了 n 个任务，用时$n \Delta t$，效率<br>$e &#x3D; \cfrac{n \Delta t}{(k+n-1) \Delta t}$</li>
<li>整条流水线的效率$E &#x3D; \cfrac{e_1+e_2+…+e_k}{k}&#x3D; \cfrac{n}{k+n-1}$</li>
</ul>
<h4 id="TP、S、E-关系"><a href="#TP、S、E-关系" class="headerlink" title="TP、S、E 关系"></a><mark>TP、S、E 关系</h4><p>$E &#x3D; \cfrac{S}{k}$<br>$E &#x3D; P \times \Delta t$</p>
<h4 id="流水线的最佳段数"><a href="#流水线的最佳段数" class="headerlink" title="流水线的最佳段数"></a>流水线的最佳段数</h4><p>流水线段数增加，吞吐率、加速比和价格均提高。<br>PCR 定义为单位价格的最大吞吐率。<br>$PCR &#x3D; \frac{P_{max}}{C}$，其中$P_{max} &#x3D; \frac{1}{\frac{t}{k}+d}$，$C &#x3D; \frac{1}{a+b \times k}$。t 为非流水机器串行完成一个任务的时间，d 为锁存器延迟，a 为流水段本身价格，b 为锁存器价格。<br>对 k 求导可得 PCR 极大值，以及对应的最佳段数$k_0$。$k_0 &#x3D; \sqrt{\frac{t \times a}{d \times b}}$<br>大于等于 8 段的流水线称为超流水线。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>例2：</p>
<blockquote>
<p>注意，不要把$\Delta t$丢了，吞吐率的结果是带着$\Delta t$的<br>计算设备利用效率的时候，直接算使用的部分，别拿整个的去减。</p>
</blockquote>
<p>例3：</p>
<p>流水线的性能分析举例，课本例题3.1<br><img src="https://static.xqmmcqs.com/2022-06-07-00-07-41-L6JcLw.png" alt="流水线的性能分析举例"></p>
<p>例4：</p>
<p>课本例题3.2<br><img src="https://static.xqmmcqs.com/2022-06-07-00-07-41-L6JcLw.png" alt="课本例题3.2"></p>
<h3 id="流水线相关与冲突（五段流水线）"><a href="#流水线相关与冲突（五段流水线）" class="headerlink" title="流水线相关与冲突（五段流水线）"></a>流水线相关与冲突（五段流水线）</h3><h4 id="经典五段RISC流水线"><a href="#经典五段RISC流水线" class="headerlink" title="经典五段RISC流水线"></a>经典五段RISC流水线</h4><p>经典五段RISC流水线：分为 IF、ID、EX、MEM、WB 五个周期。<br><strong>从第三个周期EX开始，不同类指令在各周期含义不同</strong><br>这里的不同指令，可以大致分为ALU指令，Load&#x2F;store指令&#x2F;Branch指令</p>
<ul>
<li>IF：以程序计数器 PC 中的内容作为地址，从存储器中取出指令并放入指令寄存器 IR。PC 指向顺序的下一条指令。</li>
<li>ID：指令译码，用 IR 中的寄存器地址去访问通用寄存器组，读出所需操作数。</li>
<li>EX：<ul>
<li>ALU 指令：（寄存器——寄存器）ALU 对从通用寄存器组读出的数据进行运算。</li>
<li>load 和 store 指令：ALU 把指定寄存器的内容与偏移量相加，形成访存有效地址。</li>
<li>分支指令：ALU 把偏移量与 PC 值相加，形成转移目标的地址。同时，判断分支是否成功。</li>
</ul>
</li>
<li>MEM：存储器访问&#x2F;分支完成<ul>
<li>load 和 store 指令：根据有效地址从存储器读出相应数据，或把指定数据写入有效地址指向的存储单元。</li>
<li>分支指令：如果分支成功，就把在前一个周期中计算好的转移目标地址送入 PC。分支指令执行完成。否则，不进行任何操作。</li>
<li><strong>ALU 指令此周期不进行操作</strong>。</li>
</ul>
</li>
<li>WB：把结果写入通用寄存器组。<ul>
<li>对于 ALU 指令，结果来自 ALU。</li>
<li>对于 load 指令，结果来自存储器。</li>
<li>对于分支或者store指令，空操作</li>
</ul>
</li>
<li>分支和ALU,store指令需要四个后期，load指令需要5个周期</li>
</ul>
<p>不同类指令中各流水段的具体操作(fromppt)</p>
<p><img src="https://api2.mubu.com/v3/document_image/b01f9717-5f4d-4980-8596-9e800a6b92ec-16175743.jpg" alt="2"></p>
<p>容易发生的冲突：</p>
<ol>
<li>存储器冲突：访存指令在ME段访问主存，其它指令IF段访问主存</li>
<li>寄存器冲突: ID 段读寄存器，ALU指令在WB 段写寄存器。避免同时读写同一寄存器。</li>
</ol>
<p>注意事项：</p>
<ul>
<li>为了避免ID段和WB段都访问同意寄存器时产生冲突，默认写操作在前半拍，读操作在后半拍。</li>
<li>如果是单周期延迟分支，则分支指令在 ID 段完成计算目标地址和判断分支是否成功。</li>
</ul>
<h4 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h4><p>两条指令之间存在某种依赖关系，以至于他们可能无法在流水线中重叠执行，或只能部分重叠。</p>
<p>相关有三种类型：<strong>数据相关（真相关）、名相关、控制相关</strong>。非流水线中，指令顺序执行，不存在相关问题</p>
<ul>
<li><p><mark>数据相关</mark>：下述条件之一成立，则称指令之间数据相关。</p>
<ul>
<li>指令 a 使用指令 b 产生的结果。（后一条指令只用前一条指令的写结果）</li>
<li>指令 a 与指令 b 数据相关，而指令 b 与指令 c 数据相关。第二个条件表明数据相关具有<strong>传递性</strong>。</li>
</ul>
</li>
<li><p><mark>名相关</mark>：名指指令访问的<strong>寄存器</strong>或<strong>存储器单元</strong>的名称。两条指令使用了相同的名，但<strong>并没有数据流动关系</strong>，则称为名相关。名相关分为两种。</p>
<ul>
<li>反相关：<strong>先读后写相关</strong> 指令 b 写的名与指令 a 读的名相同。反相关指令之间的执行顺序必须严格遵守，保证 b 读的值是正确的。</li>
<li>输出相关：<strong>写写相关</strong> 指令 b 与指令 a 写的名相同。输出相关指令的执行顺序也必须严格遵守，保证最后的结果是指令 b 写进去的。</li>
</ul>
<p>名相关的两条指令之间没有数据的传送，只是恰巧用了相同的名。可以通过<strong>换名技术</strong>（改变指令中操作数的名）消除名相关。对于寄存器操作数换名称为<strong>寄存器换名</strong>。寄存器换名既可以通过<strong>编译器</strong>静态实现，也可以<strong>硬件</strong>动态完成。</p>
</li>
<li><p><mark>控制相关</mark>：分支指令和其它会改变 PC 值的指令引起的相关。需要根据分支指令的执行结果来确定后面该执行哪个分支上的指令。<br><img src="https://api2.mubu.com/v3/document_image/d0f6269d-57f8-4655-b834-dc96e55684f4-16175743.jpg" alt="2"></p>
<blockquote>
<p>补充一下，课本上的更详细<img src="https://api2.mubu.com/v3/document_image/734d9668-6ef0-4ec1-b5e5-78fdfbd75c4c-16175743.jpg" alt="2"></p>
</blockquote>
</li>
</ul>
<h4 id="流水线冲突"><a href="#流水线冲突" class="headerlink" title="流水线冲突"></a>流水线冲突</h4><p>对于具体的流水线，由于相关的存在，指令流中的下一条指令不能在指定的时钟周期开始执行。有三种类型，<strong>结构冲突、数据冲突、控制冲突。</strong><br>流水线冲突的影响：导致错误的执行结果，导致流水线停顿，降低性能。</p>
<p>约定：<strong>当一条指令被暂停时，在该指令之后流出的所有指令都要被暂停，而之前流出的指令仍继续进行</strong>。</p>
<h5 id="1-结构冲突"><a href="#1-结构冲突" class="headerlink" title="1.结构冲突"></a>1.结构冲突</h5><p>某种指令组合因为硬件资源冲突而不能正常执行，称具有结构冲突。功能部件不是完全流水或硬件资源份数不够时发生。解决方法：插入暂停周期（stall），或增加 Cache 等硬件资</p>
<h5 id="2-数据冲突"><a href="#2-数据冲突" class="headerlink" title="2.数据冲突"></a>2.数据冲突</h5><p>相关的指令靠得足够近，他们在流水线中的重叠执行或重新排序会改变指令读&#x2F;写操作数的顺序，使结果错误，谓数据冲突。</p>
<ul>
<li>写后读冲突（R<mark>A</mark>W、WR）：对应真数据相关。<mark>这里的A 是After的意思</mark></li>
<li>写后写冲突（WAW、WW）：对应输出相关。写后写冲突仅发生在“不止一个段可以进行写操作，或指令被重新排序”的流水线中。前述五段流水线不发生 WAW 冲突。</li>
<li>读后写冲突（WAR、RW）：对应反相关。读后写冲突仅发生在“有些指令的写结果操作被提前、有些指令的读操作被滞后，或指令被重新排序”的流水线中。前述五段流水线不发生 WAR 冲突。<br>数据冲突的解决：</li>
<li>定向技术（绿色通道）<br>（旁路技术）减少数据冲突引起的停顿：将计算结果从其产生的地方（ALU 出口）直接送到其他指令需要它的地方（ALU 的入口），可以<strong>避免或者减少流水线的停顿</strong>。</li>
<li>停顿<br>需要停顿的数据冲突（例如 LD 后接一个算术指令）：对于无法通过定向技术解决的数据冲突，需要设置一个“流水线互锁机制”的功能部件保证指令正确执行。其作用是检测和发现数据冲突，并使流水线停顿（stall）直至冲突消失。<blockquote>
<p>补充：访存指令的周期：<br>取指-译码-计算目标地址-访问存储器-写入寄存器</p>
</blockquote>
</li>
<li>编译器解决<br>在编译时让编译器重新组织指令顺序来消除冲突。称为<strong>指令调度</strong>或<strong>流水线调度</strong>。</li>
</ul>
<h5 id="3-控制冲突"><a href="#3-控制冲突" class="headerlink" title="3.控制冲突"></a><mark>3.控制冲突</mark></h5><p>分支指令和其它会改变 PC 值的指令引起的冲突。<strong>处理分支指令最简单的方法是“冻结”(“排空”)流水线</strong> ，“冻结”流水线的处理方式：在 ID 段检测到分支指令时，立即暂停流水线输入，进行 EX、MEM，确定是否分支成功并计算出新的 PC 值，这样带来 3 个时钟周期的延迟。<br>为了减少分支延迟，可以采取：</p>
<ol>
<li>尽早判断出（或猜测）分支转移是否成功。</li>
<li>尽早计算出分支目标地址。<br>这两步工作若提前到ID段完成（针对简单的转移指令是可以做到这一点的），分支延迟将为一个时钟周期。</li>
</ol>
<blockquote>
<p>关于条件分支和无条件分支：<br>条件控制分支包括if-else、while、do-while、for<br>而无条件分支控制包括return、break和continue</p>
</blockquote>
<h6 id="通过编译器减少分支延迟的方法"><a href="#通过编译器减少分支延迟的方法" class="headerlink" title="通过编译器减少分支延迟的方法"></a>通过编译器减少分支延迟的方法</h6><ol>
<li><strong>预测分支失败</strong>：在检测到分支指令之后，沿分支失败的分支继续处理指令。<ul>
<li>当确定分支是失败时（预测分支失败成功），流水线正常流动。</li>
<li>否则（预测分支失败失败），把在分支指令之后取出的指令转化为空操作，按分支目标地址重新取指执行。</li>
<li>预测分支失败成功（分支失败）：0 延迟；预测分支失败失败（分支成功）：1 延迟。</li>
<li><mark>例题</mark><br><img src="https://api2.mubu.com/v3/document_image/b2c28bfc-abfc-432a-8971-cf54d56244a7-16175743.jpg" alt="2"><br><img src="https://api2.mubu.com/v3/document_image/50c33649-5c80-4478-88ae-73975d7f0d49-16175743.jpg" alt="3"></li>
</ul>
</li>
<li><strong>预测分支成功</strong>：这种方法按分支成功的假设进行处理。当流水线ID段检测到分支指令后，一旦计算出了分支目标地址,就开始从该目标地址取指令执行。<br>  在前述<strong>5段流水</strong>线中,由于判断分支是否成功与分支目标地址计算是在同一流水段完成的,所以<strong>这种方法对减少该流水线的分支延迟没有任何好处</strong>。但在其他的一些流水线处理机中,特别是那些具有隐含设置条件码或分支条件更复杂(因而更慢)的流水线处理机中，在确定分支是否成功之前,就能得到分支的目标地址。这时采用这种方法便可以减少分支延迟。</li>
<li><strong>延迟分支</strong>：把无论是否分支成功都必须执行的指令，紧接着分支指令执行（放入延迟槽），延迟槽中的指令替换了原本必须插入的暂停周期。绝大多数延迟槽仅容纳一条指令。</li>
</ol>
<p>  <strong>延迟槽</strong>：一条或几条与转移指令结果无关而有用的指令。<br>     1. 从前调度：被调度的指令必须与分支无关，适合任何情况<br>     2. 从目标处调度：分支成功时起作用。分支成功概率高时采用<br>     3. 从失败处调度：分支失败时起作用。不能从前调度时可用。<br><img src="https://api2.mubu.com/v3/document_image/b5b880e2-8db2-4807-95ff-f440e9c3c736-16175743.jpg" alt="3"></p>
<h6 id="控制冲突的例题"><a href="#控制冲突的例题" class="headerlink" title="控制冲突的例题"></a>控制冲突的例题</h6><p><img src="https://api2.mubu.com/v3/document_image/76E4FD3FFB6A44201679212034.jpg" alt="2"><br>需要特别注意预测分支失败不需要一个额外的周期来计算目标地址，直接拿下一条指令执行就可以了；但是预测分支成功不行，就算赌它成功了也得等它ex出来下一跳地址才行。这也是为什么预测分支失败更好。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="/music/溯.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="/music/mine.mp3"></li>
                        
                    
                        
                            <li title="2" data-url="/music/诀别书.mp3"></li>
                        
                    
                        
                            <li title="3" data-url="/music/七年了，他还是走不出来.mp3"></li>
                        
                    
                        
                            <li title="4" data-url="/music/《溯 Reverse》.mp3"></li>
                        
                    
                        
                            <li title="5" data-url="/music/《託された想い (被寄托的思念)—増田俊郎》.mp3"></li>
                        
                    
                        
                            <li title="6" data-url="/music/【钢琴】《所念皆星河 》.mp3"></li>
                        
                    
                        
                            <li title="7" data-url="/music/【钢琴】陈奕迅《富士山下》.mp3"></li>
                        
                    
                        
                            <li title="8" data-url="/music/【钢琴】花之舞 《Flower Dance》.mp3"></li>
                        
                    
                        
                            <li title="9" data-url="/music/【钢琴】周杰伦《反方向的钟》.mp3"></li>
                        
                    
                        
                            <li title="10" data-url="/music/【钢琴】周杰伦《青花瓷》.mp3"></li>
                        
                    
                        
                            <li title="11" data-url="/music/I Really Like You.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link"
		data-enable="true"
        data-ae="true"
        data-ci="86a92b9df49e55c6beaf"
        data-cs="b740ee88f80bbd33b4109f0c18a4f049a00a6439"
        data-r="CommentRepo"
        data-o="0bluewhale0"
        data-a="0bluewhale0"
        data-d="true"
    >查看评论</div>


    </div>
    
        <div class="side">
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">第一章 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">1.2 计算机系统的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AE%9A%E9%87%8F%E5%8E%9F%E7%90%86"><span class="toc-text">1.2.1 计算机系统设计的定量原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E6%A6%82%E7%8E%87%E4%BA%8B%E4%BB%B6%E4%BC%98%E5%85%88%E5%8E%9F%E7%90%86"><span class="toc-text">大概率事件优先原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Amdahl%E5%AE%9A%E5%BE%8B"><span class="toc-text">Amdahl定律</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-text">程序的局部性原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CPU%E6%80%A7%E8%83%BD%E5%85%AC%E5%BC%8F"><span class="toc-text">CPU性能公式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="toc-text">1.2.2 计算机系统设计的主要内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">1.2.3 系统设计的主要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B"><span class="toc-text">1.3 计算机系统的性能评测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E6%A0%87"><span class="toc-text">指标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MIPS"><span class="toc-text">MIPS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MFLOPS"><span class="toc-text">MFLOPS</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-text">测试程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-text">1.4 计算机系统结构的发展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84"><span class="toc-text">1.4.1 冯诺依曼结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E8%BD%AF%E4%BB%B6%E5%AF%B9%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">1.4.2 软件对系统结构的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E5%99%A8%E4%BB%B6%E5%8F%91%E5%B1%95%E5%AF%B9%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">1.4.3 器件发展对系统结构的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-%E5%BA%94%E7%94%A8%E5%AF%B9%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">1.4.4 应用对系统结构的影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E4%B8%AD%E5%B9%B6%E8%A1%8C%E6%80%A7%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-text">1.5 计算机系统结构中并行性的发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9AWords"><span class="toc-text">补充：Words</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="toc-text">第三章 流水线技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-text">什么是流水线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">流水线的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%92%8C%E5%88%86%E6%9E%90"><span class="toc-text">流水线性能计算和分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E7%8E%87-TP"><span class="toc-text">吞吐率 TP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%80%9F%E6%AF%94-S"><span class="toc-text">加速比 S</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E7%8E%87-E"><span class="toc-text">效率 E</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TP%E3%80%81S%E3%80%81E-%E5%85%B3%E7%B3%BB"><span class="toc-text">TP、S、E 关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%9C%80%E4%BD%B3%E6%AE%B5%E6%95%B0"><span class="toc-text">流水线的最佳段数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9B%B8%E5%85%B3%E4%B8%8E%E5%86%B2%E7%AA%81%EF%BC%88%E4%BA%94%E6%AE%B5%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%89"><span class="toc-text">流水线相关与冲突（五段流水线）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E4%BA%94%E6%AE%B5RISC%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-text">经典五段RISC流水线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3"><span class="toc-text">相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%86%B2%E7%AA%81"><span class="toc-text">流水线冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84%E5%86%B2%E7%AA%81"><span class="toc-text">1.结构冲突</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%86%B2%E7%AA%81"><span class="toc-text">2.数据冲突</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8E%A7%E5%88%B6%E5%86%B2%E7%AA%81"><span class="toc-text">3.控制冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%99%A8%E5%87%8F%E5%B0%91%E5%88%86%E6%94%AF%E5%BB%B6%E8%BF%9F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">通过编译器减少分支延迟的方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%86%B2%E7%AA%81%E7%9A%84%E4%BE%8B%E9%A2%98"><span class="toc-text">控制冲突的例题</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
