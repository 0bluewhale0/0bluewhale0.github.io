
<!DOCTYPE html>
<html lang="zh" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>计网笔记-数据链路层1 - SZH&#39;s blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="shanzhihan&#39;s blog,"> 
    <meta name="description" content="一生所求是做个温柔又强大的人,开头👴先抄一个gzc的思维导图：
3.1数据链路层的设计问题3.1.1提供给网络层的服务
数据链路层的功能

向网络层提供一个定义良好的服务接口。
处理传输错误。
调节数据流,确保慢速的接收方不会,"> 
    <meta name="author" content="szh"> 
    <link rel="alternative" href="atom.xml" title="SZH&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/icoon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="计网笔记-数据链路层1 - SZH&#39;s blog"/>
    <meta name="twitter:description" content="一生所求是做个温柔又强大的人,开头👴先抄一个gzc的思维导图：
3.1数据链路层的设计问题3.1.1提供给网络层的服务
数据链路层的功能

向网络层提供一个定义良好的服务接口。
处理传输错误。
调节数据流,确保慢速的接收方不会,"/>
    
    
    
    
    <meta property="og:site_name" content="SZH&#39;s blog"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="计网笔记-数据链路层1 - SZH&#39;s blog"/>
    <meta property="og:description" content="一生所求是做个温柔又强大的人,开头👴先抄一个gzc的思维导图：
3.1数据链路层的设计问题3.1.1提供给网络层的服务
数据链路层的功能

向网络层提供一个定义良好的服务接口。
处理传输错误。
调节数据流,确保慢速的接收方不会,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 6.0.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">SZH&#39;s blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://blog.szhhh.top"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">计网笔记-数据链路层1</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">计网笔记-数据链路层1</h1>
        <div class="stuff">
            <span>三月 30, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/course/" rel="tag">course</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E8%AE%A1%E7%BD%91/" rel="tag">计网</a></li></ul>


        </div>
        <div class="content markdown">
            <p>开头👴先抄一个gzc的思维导图：<br><img src="https://api2.mubu.com/v3/document_image/f9fae159-374d-41e5-99cf-6bee7b25ccc9-16175743.jpg" alt="思维导图"></p>
<h2 id="3-1数据链路层的设计问题"><a href="#3-1数据链路层的设计问题" class="headerlink" title="3.1数据链路层的设计问题"></a>3.1数据链路层的设计问题</h2><h3 id="3-1-1提供给网络层的服务"><a href="#3-1-1提供给网络层的服务" class="headerlink" title="3.1.1提供给网络层的服务"></a>3.1.1提供给网络层的服务</h3><ol>
<li><p>数据链路层的功能</p>
<ol>
<li>向网络层提供一个定义良好的服务接口。</li>
<li>处理传输错误。</li>
<li>调节数据流,确保慢速的接收方不会被快速的发送方淹没。</li>
</ol>
</li>
<li><p>提供给网络层的服务</p>
<ol>
<li><p>Unacknowledged connectionless service.<br> Most LANs局域网 use unacknowledged connectionless service </p>
</li>
<li><p>Acknowledged connectionless无连接的，也就是不用事先建立通路 service.<br>  This service is useful over unreliable channels, such as wireless  systems。给一个ACK，有确认的服务</p>
</li>
<li><p>Acknowledged connection-oriented service</p>
<pre><code>- Connection establishment
- Timer
- Sequence number 若ACKnumber丢了，防止重复
</code></pre>
</li>
</ol>
</li>
</ol>
<p>当使用面向连接的服务时，数据传输必须经过三个不同的阶段。在第一个阶段,要建立连接，双方初始化各种变量和计数器，这些变量和计数器记录了哪些帧已经接收到，哪些帧还没有收到。在第二个阶段，才真正传输一个或者多个数据帧。在第三个也是最后一个阶段中，连接被释放，所有的变量、缓冲区以及其他用于维护该连接的资源也随之被释放。</p>
<h3 id="3-1-2成帧Framing"><a href="#3-1-2成帧Framing" class="headerlink" title="3.1.2成帧Framing"></a>3.1.2成帧Framing</h3><h4 id="字符计数"><a href="#字符计数" class="headerlink" title="字符计数"></a>字符计数</h4><p><img src="https://api2.mubu.com/v3/document_image/8ed3423d-ef66-42da-aea0-416c2fee6873-16175743.jpg" alt="字符计数"><br>一旦出错：运气不好的话所有的帧都不能正确识别</p>
<h4 id="字符填充法（byte-stuffing）"><a href="#字符填充法（byte-stuffing）" class="headerlink" title="字符填充法（byte stuffing）"></a>字符填充法（byte stuffing）</h4><p><img src="https://api2.mubu.com/v3/document_image/9d9674ff-e6e8-46a2-ae6c-1851829cbd44-16175743.jpg" alt="字符填充法"></p>
<p>帧标志出错了：每两个帧之间至少有一个帧标志，仅影响当前帧。<br>问题：发送的信息含有很多控制字符，需要转译的字符大大增加<br><strong>开销：overhead</strong>，跟需要发送的数据相比，额外添加的转义字符所占的比例，比如全是需要转译的字符的信息，overhead就是100%。</p>
<h4 id="比特填充（bit-stuffing）"><a href="#比特填充（bit-stuffing）" class="headerlink" title="比特填充（bit stuffing）"></a>比特填充（bit stuffing）</h4><p>每个帧的开头结尾都是一个special bit pattern, 01111110 ，也就是16进制的7EH，当数据内容出现连续的1时，每遇到五个1添加一个0（硬件不管这5个1后面是0还是1），接收方做相反的工作。另外在<br><img src="https://api2.mubu.com/v3/document_image/c7e3cce3-443d-4224-b633-bc6f9cefff4b-16175743.jpg" alt="bit stuffing"><br>(a) The original data.<br>(b) The data as they appear on the line.<br>(c) The data as they are stored in receiver’s memory after destuffing.<br>就是每隔五个1插入一个0</p>
<h4 id="物理层编码违例"><a href="#物理层编码违例" class="headerlink" title="物理层编码违例"></a>物理层编码违例</h4><p>Physical layer coding violation （n. 违反, 冒犯, 侵害）<br>对于曼彻斯特Manchester编码，两个跳变表示一个bit，所以当出现长高电平，常低电平，就属于物理层违例了，可以作为帧的边界。</p>
<h3 id="3-1-3差错控制（ERROR-control）"><a href="#3-1-3差错控制（ERROR-control）" class="headerlink" title="3.1.3差错控制（ERROR control）"></a>3.1.3差错控制（ERROR control）</h3><p>可靠的传输：不能少，不能多，顺序不能错</p>
<h3 id="3-1-4流量控制"><a href="#3-1-4流量控制" class="headerlink" title="3.1.4流量控制"></a>3.1.4流量控制</h3><h4 id="两种流量控制"><a href="#两种流量控制" class="headerlink" title="两种流量控制"></a>两种流量控制</h4><ol>
<li>基于反馈信息的流量控制 feedback</li>
<li>基于速率的流量控制（主要是网络层，一种内嵌的机制，浅显的理解是限制速率）rate-based</li>
</ol>
<h4 id="流量控制协议"><a href="#流量控制协议" class="headerlink" title="流量控制协议"></a>流量控制协议</h4><ol>
<li>停等 Stop Aan Wait</li>
<li>滑动窗口 Sliding Window</li>
</ol>
<h2 id="3-2差错检验和纠正"><a href="#3-2差错检验和纠正" class="headerlink" title="3.2差错检验和纠正"></a>3.2差错检验和纠正</h2><ol>
<li><p>错误分类</p>
<ul>
<li>lost frames：一个数据帧完全没能传过去，常常是因为噪音或者掉队</li>
<li>damaged frames：一些bit错了</li>
</ul>
</li>
<li><p>差错检测</p>
<ol>
<li>奇偶校验码(parity):检测单比特错误</li>
<li>Cyclic Redundancy Check:CRC</li>
<li>Atuomatic Repeat reQuest:ARQ</li>
</ol>
</li>
<li><p>差错纠正</p>
<ul>
<li>前向纠错（forward error correction）FEC</li>
</ul>
</li>
</ol>
<h3 id="纠错码"><a href="#纠错码" class="headerlink" title="纠错码"></a>纠错码</h3><hr>
<blockquote>
<p>补充：海明距离Hamming<br>   两个编码异或之后为1的位数<br>   检测到d个errors，需要distance为d+1的编码<br>   纠正d个errors，需要distance为2d+1的编码<br>   这里的距离指的是码表上任意两个编码之间的hamming距离，取最小。对于已知的检错方法，要确定能够检测出几个error应该考虑最坏的情况。</p>
</blockquote>
<h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><p>一个公式：<br>$m+r+1 \le 2^r$<br>m:数据位数<br>r：所需的校验位<br>由该式可以解出需要的最少校验位</p>
<p>海明码的构造：<br><img src="https://api2.mubu.com/v3/document_image/164890187785875d5.jpg" alt="海明码"><br><font size=1>为什么这个人字这么难看啊吐…大概是自己也知道不会再看第二遍了吧…（orz）</font></p>
<p>海明码的作用：<br>可以校验一位差错，并纠正。<br>假如第5位发生了错误，那么第1和4位的校验位会出错，计算1+4可得第5位出错，取反即可纠正。而如果是校验位发生了错误，那么只有那一个校验位错了，就可以知道是校验位出错了。（所有这些都是建立在仅仅发生一个bit的错误上的）<br><img src="https://api2.mubu.com/v3/document_image/1158e3b6-3b70-4032-ae21-3c36c36602e7-16175743.jpg" alt="示例"></p>
<p>如果发生了多位差错呢？<br>correct burst errors：<br>这里👴没懂具体咋搞的，回头机缘巧合懂了再来补文字解释（🕊🕊🕊咕咕咕）<br><img src="https://api2.mubu.com/v3/document_image/c126bef4-a95d-473b-bcbe-27208a333a10-16175743.jpg" alt="correct burst errors："></p>
<p>其他的一些纠错码：<br>卷积码（convolutional code）<br>里德所罗门码（Reed-Solomon code）<br>低密度奇偶校验码（Low-Density Parity Check codes）</p>
<h3 id="检错码"><a href="#检错码" class="headerlink" title="检错码"></a>检错码</h3><p>关于用检错码划算还是用纠错码划算的问题：<br>gzc给了一个Example<br> (<strong>single-bit error</strong>)</p>
<ul>
<li>比特错误率 BER&#x3D;10-6, 1Block&#x3D;1000bits, Data&#x3D;1M bits，也就是说传1M（$10^6$）的数据，每1000bits分一个块块er，然后一共有1000个块块er。</li>
<li>The overhead（开销）<ul>
<li>检错码Error detection + retransmission: 2001 bits （1000+1001）多的那个1是重传的时候的奇偶校验位啦（</li>
<li>纠错码Hamming code : 10,000 bits(1000块*10位校验位)</li>
</ul>
</li>
</ul>
<p>一道👴不理解的题<br>Suppose that data are transmitted in blocks of sizes 1000 bits. What is the maximum error rate under which error detection and retransmission mechanism (1 parity bit per block) is better than using Hamming code? Assume that bit errors are independent of one another and no bit error occurs during retransmission.<br><a target="_blank" rel="noopener" href="https://api2.mubu.com/v3/document_image/5bbff850-5b07-4bc4-b927-def84152dbb8-16175743.jpg"></a></p>
<h4 id="奇偶校验码Parity"><a href="#奇偶校验码Parity" class="headerlink" title="奇偶校验码Parity"></a>奇偶校验码Parity</h4><p>略</p>
<h4 id="校验和Checksums"><a href="#校验和Checksums" class="headerlink" title="校验和Checksums"></a>校验和Checksums</h4><p>gzc说从网上抄了段代码给👴们👀👀</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Word <span class="title">Cksum</span><span class="params">(Word *Buf, Word Num_Words)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    Dword Sum;</span><br><span class="line">  	    <span class="keyword">for</span>  ( Sum=<span class="number">0</span>; Num_Words&gt;<span class="number">0</span>;  Num_Words--)</span><br><span class="line">	         Sum+=*Buf++;</span><br><span class="line">	    Sum = ( Sum &gt;&gt; <span class="number">16</span> ) + ( Sum &amp; <span class="number">0xffff</span> ); </span><br><span class="line">	    Sum += Sum &gt;&gt; <span class="number">16</span>;</span><br><span class="line">	    <span class="keyword">return</span> ~Sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="CRC循环冗余校验"><a href="#CRC循环冗余校验" class="headerlink" title="CRC循环冗余校验"></a><mark>CRC循环冗余校验</mark></h4><p><font size=1>这玩意儿是个重点</font><br>名字：Ploynomial code多项式编码，也就是CRC<br>计算CRC：<br>Frame:要传输的数据帧<br>Generator:生成多项式，可以和二进制串一一对应，（一般第一位是1）如$x^4+x+1$对应串10011，<strong>最高幂次r&#x3D;4，对应r+1&#x3D;5位二进制串</strong>，从低位开始写不容易出错。<br>在计算过程中的法则是模2加法，也就是异或运算，在该运算中，加减等价。<br>计算过程：</p>
<ol>
<li>把Frame左移r位，也就是$\times2^r$</li>
<li>用（1）得到是数模二除Generator（注意这个过程所有的加和减也都是异或运算）</li>
<li>除到（1）得到的数的最后一位得到余数，用（1）中数-余数，但是这里也是模二减，相当于异或“+”，且不产生进位er。</li>
<li>如果最终得到的余数不是刚好r位:就直接当数加上去的，详见例2.</li>
<li>然后算完之后就看gcz说的power，👴就发现，加上余数之后恰好整除Generator</li>
</ol>
<p>一个例子1：<br><img src="https://api2.mubu.com/v3/document_image/66a3abff-51ac-47b2-bdf7-145961822f15-16175743.jpg" alt="例子"><br>例子2：<br><img src="https://api2.mubu.com/v3/document_image/08fdf2e9-eb53-46b8-8baf-2fd57268ceb0-16175743.jpg" alt="例子2"></p>
<p>the power of CRC</p>
<ul>
<li>若不出现差错：收到T(X)</li>
<li>若出现了一些差错：收到E(X)，由于模二加法，0-&gt;1和1-&gt;0都可以用“+”表示</li>
<li>计算[T(X)+E(X)]&#x2F;G(X) &#x3D; E(X)&#x2F;G(X)，所以在E(X)&#x2F;G(X)&#x3D;&#x3D;0的时候，差错不能被检查出来</li>
<li>由此推论：<ol>
<li>添加了r bit的冗余信息的码，一定能检测出$\le r$bit的差错，因为rbit冗余信息意味着最高幂次为r，也就是说G(X)有r+1位。</li>
<li>若让（x+1）是G(X)的一个因子（factor），则所有的奇数位都可以检测出来，<font size=1>这玩意儿可以证，但根据速通理论的高质高效原则，👴忍住了，没去看怎么证。</font></li>
<li>若触发差错的bits长度为（r+1），则检测不出来的概率为$\cfrac{1}{2^{r-1}}$，因为出错长度为r+1个bit,则第一个和最后一个一定是错了也就是E(X)的第一位和最后一位都是1，而剩下的中间r-1位不知道是0（没错）还是1（错了）。</li>
<li>而若触发差错的bits长度更长的时候，触发差错的可能就是$\cfrac{1}{2^r}$</li>
</ol>
</li>
</ul>
<p>生成多项式：</p>
<blockquote>
<ul>
<li>CRC-16<br>$x^{16}+x^{15}+x^2+1$</li>
<li>CRC-CCITT  (HDLC)<br>$x^{16}+x^{12}+x^5+1$</li>
<li>CRC-32 (IEEE802)<br>$x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x^{1}+1$</li>
</ul>
</blockquote>
<h2 id="3-3基本-elementary-数据链路层协议"><a href="#3-3基本-elementary-数据链路层协议" class="headerlink" title="3.3基本(elementary)数据链路层协议"></a>3.3基本(elementary)数据链路层协议</h2><p>几种单工协议：<br>An Unrestricted Simplex Protocol <strong>乌托邦</strong>，Unrestricted没有限制的<br>A Simplex Stop-and-Wait Protocol <strong>停等协议</strong><br>A Simplex Protocol for a Noisy Channel <strong>噪音</strong></p>
<h3 id="Protocol-1-乌托邦Utopia"><a href="#Protocol-1-乌托邦Utopia" class="headerlink" title="Protocol 1: 乌托邦Utopia"></a>Protocol 1: 乌托邦Utopia</h3><p>无差错的channel，完美的接收者，源源不断的发送<br><img src="https://api2.mubu.com/v3/document_image/f2466881-7f1b-498d-b4d2-da1a258399da-16175743.jpg" alt="utopia"></p>
<h3 id="Protocol-2-停等协议"><a href="#Protocol-2-停等协议" class="headerlink" title="Protocol 2:停等协议"></a>Protocol 2:停等协议</h3><p><strong>Stop-and-Wait Protocol for a Error-free Channel</strong><br>考虑flow control，仍然是完美的信道<br><img src="https://api2.mubu.com/v3/document_image/631de808-d162-41ae-a8d0-d198cddf5c7a-16175743.jpg" alt="flow control"><br>↑对于短距离的通信完全是没有问题的，效率很高，远距离就不行了</p>
<h3 id="Protocol-3-有噪音的"><a href="#Protocol-3-有噪音的" class="headerlink" title="Protocol 3:有噪音的"></a>Protocol 3:有噪音的</h3><p><strong>A Simplex Protocol for a Noisy Channel</strong><br><img src="https://api2.mubu.com/v3/document_image/b7928813-66a6-4f48-8c86-023db3689df9-16175743.jpg" alt="Noisy"><br>ACK:<strong>ack</strong>nowledgement character命令正确应答<br>NAK：<strong>n</strong>agative a<strong>ck</strong>nowladge否定应答<br>前3种情况都没有问题，但是第4种，ACK丢了，就可能导致重复发送，这就引入了序列号的使用。<br>此外，一个晚到的ACK也可能导致发送重复的数据</p>
<h4 id="Sequence-Number"><a href="#Sequence-Number" class="headerlink" title="Sequence Number"></a>Sequence Number</h4><p>对于数据链路层的<strong>停等协议，一个bit（0&#x2F;1）就足够了</strong>，可以做到判断是新的还是旧的帧<br>对于传输层，1bit就不够了，需要较大的编号空间使得在编号回卷时，保证同编号的旧帧不可能被缓冲在网络中，如：TFTP<br>protocol3：</p>
<ul>
<li>sender 伪代码<br>课本上的代码见<a target="_blank" rel="noopener" href="https://api2.mubu.com/v3/document_image/bb4f22d1-ddb4-42de-b363-789775f057f3-16175743.jpg">这里</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">从网络层获取一个分组放入buffer</span><br><span class="line">发送buffer中的数据，新启动定时器</span><br><span class="line">label1:</span><br><span class="line"><span class="built_in">wait_for_event</span>()</span><br><span class="line"><span class="keyword">switch</span> (event) &#123;</span><br><span class="line"><span class="keyword">case</span> 收到了坏帧(校验和错):</span><br><span class="line">     重发缓冲在buffer里的数据，重新启动定时器</span><br><span class="line">     <span class="comment">//这里的&quot;重新&quot;和&quot;新&quot;都是指从头开始启动计时器</span></span><br><span class="line"><span class="keyword">case</span> 定时器超时：</span><br><span class="line">     重发缓冲在buffer里的数据，新启动定时器</span><br><span class="line"><span class="keyword">case</span> 收到校验和正确的帧：</span><br><span class="line">     <span class="keyword">if</span>（ack序号正确） &#123;</span><br><span class="line">        关闭旧定时器</span><br><span class="line">        从网络层获取下一个分组放入buffer</span><br><span class="line">        发送buffer中的数据，新启动定时器</span><br><span class="line">     &#125; <span class="keyword">else</span> </span><br><span class="line">         重发缓冲在buffer里的数据，重新启动定时器</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> label1</span><br></pre></td></tr></table></figure>

<p>简化版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">从网络层获取一个分组放入<span class="function">buffer</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">   发送buffer中的数据，启动定时器</span><br><span class="line">   <span class="built_in">wait_for_event</span>()</span><br><span class="line">   <span class="keyword">if</span> (收到校验和正确的帧) &#123;</span><br><span class="line">      <span class="keyword">if</span>（ack序号正确） &#123;</span><br><span class="line">         关闭旧定时器</span><br><span class="line">         从网络层获取下一个分组放入buffer</span><br><span class="line">         &#125; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>receiver伪代码<br>课本上的代码见<a target="_blank" rel="noopener" href="https://api2.mubu.com/v3/document_image/fa67061a-f013-4c8f-9c3f-9fea1dff167d-16175743.jpg">这里</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">frame_expected=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="built_in">wait_for_event</span>()</span><br><span class="line">   <span class="keyword">switch</span>(event) &#123;</span><br><span class="line">   <span class="keyword">case</span> 坏帧：</span><br><span class="line">      do_nothing</span><br><span class="line">   <span class="keyword">case</span> 收到校验和正确的数据帧:</span><br><span class="line">      <span class="keyword">if</span>（序号==frame_expected） &#123;</span><br><span class="line">         向网络层上交分组</span><br><span class="line">         回ACK（序号为frame_expected)</span><br><span class="line">         <span class="built_in">inc</span>(frame_expected)</span><br><span class="line">      &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">         回ACK（序号为frame_expected<span class="number">-1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计时器Timer"><a href="#计时器Timer" class="headerlink" title="计时器Timer"></a>计时器Timer</h4><p>gzc说计时器的间隔是个比较精细的活儿，短了可能收不到，然后每个帧都得发俩遍，间隔长了效率低。实际上设计的比较保守（因为错误实在比较少），但是自己做的实验里面就整个比较合适的值就完了（500ms差不多就完了，这世间卫星都跑到了）。<br><font size=1>👴居然听懂了</font></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="/music/溯.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="/music/【钢琴】《你离开的事实 》The Truth that You Leave 罗曼耶卓 Oskar R - 1.truth_POST(Av586020664,P1).mp3"></li>
                        
                    
                        
                            <li title="2" data-url="/music/【钢琴】《大雾》(demo版）张一乔 - 1.dawu(Av417516306,P1).mp3"></li>
                        
                    
                        
                            <li title="3" data-url="/music/【钢琴】《晴天》Oskar Roman Jezior 周杰伦 - 1.qingtian_POST(Av331213171,P1).mp3"></li>
                        
                    
                        
                            <li title="4" data-url="/music/【钢琴】《撒野》罗曼耶卓 - 1.saye_POST(Av459374452,P1).mp3"></li>
                        
                    
                        
                            <li title="5" data-url="/music/【钢琴】坂本龙一《圣诞快乐 劳伦斯先生》 罗曼耶卓 Oskar Roman Jezior - 1.mr_lawrence_POST(Av885864226,P1).mp3"></li>
                        
                    
                        
                            <li title="6" data-url="/music/【钢琴】陈奕迅《富士山下》罗曼耶卓 Oskar Roman Jezior - 1.fuji_POST(Av288674149,P1).mp3"></li>
                        
                    
                        
                            <li title="7" data-url="/music/【钢琴】花之舞 《Flower Dance》罗曼耶卓 Oskar Roman Jezior - 1.flower_dance_POST(Av331481248,P1).mp3"></li>
                        
                    
                        
                            <li title="8" data-url="/music/【钢琴】暮光之城《A Thousand Years》罗曼耶卓 - 1.thousand_years_POST(Av289839694,P1).mp3"></li>
                        
                    
                        
                            <li title="9" data-url="/music/Young and Beautiful.mp3"></li>
                        
                    
                        
                            <li title="10" data-url="/music/错位时空.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link"
		data-enable="true"
        data-ae="true"
        data-ci="86a92b9df49e55c6beaf"
        data-cs="b740ee88f80bbd33b4109f0c18a4f049a00a6439"
        data-r="CommentRepo"
        data-o="0bluewhale0"
        data-a="0bluewhale0"
        data-d="true"
    >查看评论</div>


    </div>
    
        <div class="side">
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">3.1数据链路层的设计问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1%E6%8F%90%E4%BE%9B%E7%BB%99%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.</span> <span class="toc-text">3.1.1提供给网络层的服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2%E6%88%90%E5%B8%A7Framing"><span class="toc-number">1.2.</span> <span class="toc-text">3.1.2成帧Framing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%A1%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">字符计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%A1%AB%E5%85%85%E6%B3%95%EF%BC%88byte-stuffing%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">字符填充法（byte stuffing）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%EF%BC%88bit-stuffing%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">比特填充（bit stuffing）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E7%BC%96%E7%A0%81%E8%BF%9D%E4%BE%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">物理层编码违例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%EF%BC%88ERROR-control%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">3.1.3差错控制（ERROR control）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">3.1.4流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">两种流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.4.2.</span> <span class="toc-text">流量控制协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E5%B7%AE%E9%94%99%E6%A3%80%E9%AA%8C%E5%92%8C%E7%BA%A0%E6%AD%A3"><span class="toc-number">2.</span> <span class="toc-text">3.2差错检验和纠正</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A0%E9%94%99%E7%A0%81"><span class="toc-number">2.1.</span> <span class="toc-text">纠错码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%B7%E6%98%8E%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">海明码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E9%94%99%E7%A0%81"><span class="toc-number">2.3.</span> <span class="toc-text">检错码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%A0%81Parity"><span class="toc-number">2.3.1.</span> <span class="toc-text">奇偶校验码Parity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8CChecksums"><span class="toc-number">2.3.2.</span> <span class="toc-text">校验和Checksums</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CRC%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.3.3.</span> <span class="toc-text">CRC循环冗余校验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E5%9F%BA%E6%9C%AC-elementary-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.</span> <span class="toc-text">3.3基本(elementary)数据链路层协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Protocol-1-%E4%B9%8C%E6%89%98%E9%82%A6Utopia"><span class="toc-number">3.1.</span> <span class="toc-text">Protocol 1: 乌托邦Utopia</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protocol-2-%E5%81%9C%E7%AD%89%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.2.</span> <span class="toc-text">Protocol 2:停等协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protocol-3-%E6%9C%89%E5%99%AA%E9%9F%B3%E7%9A%84"><span class="toc-number">3.3.</span> <span class="toc-text">Protocol 3:有噪音的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Sequence-Number"><span class="toc-number">3.3.1.</span> <span class="toc-text">Sequence Number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8Timer"><span class="toc-number">3.3.2.</span> <span class="toc-text">计时器Timer</span></a></li></ol></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
