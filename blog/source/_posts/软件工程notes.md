---
title: 软工笔记
date: 2023-02-22 21:10:56
categories:
	- 笔记
		- 软件工程
tags:
	- course
	- 软件工程

cover: /img/Request_ Beautiful scener-105312823.png
---

开个坑，期末复习用。
参考 [这位](https://blog.xqmmcqs.com/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/) 和 [这位](https://bakanetwork.github.io/ComputerArchitecture/#/%E6%9E%81%E9%99%90%E5%A4%8D%E4%B9%A0eXtremeReviewing.md) 的笔记，并做了补充。

## 第一章 软件工程概述

>软件的定义
软件的发展和软件危机
软件工程的概念

程序的定义：程序=算法+数据结构。

软件的定义： ==软件是包括程序、数据及其相关文档的完整集合。== 程序和数据是构造软件的基础，文档是软件质量的保证，也是保证软件更新及生命周期长短的必需品。

**软件危机**：计算机软件在开发和维护过程中遇到一系列严重问题，导致软件行业的信任危机。具体表现在：

1. 软件的开发成本难以估算，无法制定合理的开发计划。
2. 用户的需求无法确切表达。
3. 软件质量存在问题。
4. 软件的可维护性差。
5. 缺乏文档资料。

产生软件危机的原因：

- 软件系统本身的复杂性。
- 软件开发的方法和技术不合理不成熟。

软件工程定义：运用工程化原则和方法，组织软件开发解决软件危机。

软件工程的**三要素**：==方法、工具、过程==。方法提供了“如何做”的技术、工具提供了自动或半自动的软件支撑环境、过程将方法和工具综合起来以达到合理及时地进行计算机软件开发的目的。

软件工程的**目标**：在**给定成本和时间**的前提下，开发出满足用户需求且具有==正确性、可用性==等因素的软件产品。

软件工程**项目三个基本目标**：合理的进度、有限的经费、一定的质量。（和上条类似）

软件工程的终极目标：摆脱手工生产软件的状况，逐步实现软件研制和维护的自动化。

软件工程知识体系指南
SWEBOK（Guide to SoftWare Engineering Body of Knowledge）

![1](https://api2.mubu.com/v3/document_image/338ef7d0-4ea9-4fac-b164-5481d7ad0c84-16175743.jpg)

## 第二章 生命周期模型

points:
>软件生命周期概念
传统软件生命周期模型
新型软件生命周期模型

软件工程项目三个基本目标：合理的进度、有限的经费、一定的质量。

戴明环：**PDCA——Plan，Do，Check，Action**。(美国质量管理专家戴明博士针对工程项目的指令目标提出的)

**软件工程过程**是为了获得软件产品，在软件工具的支持下由软件工程师完成的一系列软件工程活动。主要活动有：

- 软件规格说明：规定软件功能及其使用限制。
- 软件开发：产生满足规格说明的软件。
- 软件确认：通过有效性验证以保证软件能够满足客户要求。
- 软件演进：为了满足客户变更要求，软件在使用过程中不断地改进。

### 软件生命周期概念

软件产品从考虑其概念开始，到该产品不再使用为止的整个时期。包括**概念阶段、分析与设计阶段、构造阶段、移交和运行阶段**等不同时期。

软件生命周期六个基本步骤：PDDDCA
(相当于戴明环PDCA的细分)

- **制定计划 P**
  <font size =2>确定总目标，给出各方面的要求，可行性研究，预估可用资源，提交审查</font>
- **需求分析 D**
  <font size =2>详细进行需求分析，初步编写说明书和用户手册</font>
- **设计 D**
  <font size =2>概要设计、详细设计</font>
- **程序编码 D**
  <font size =2>就是写代码给过程</font>
- **软件测试 C**
  <font size =2>单元测试、组装测试</font>
- **运行维护 A**
  <font size =2>改正性维护，适应性维护，完善性维护。
  软件维护是更加复杂的软件开发活动。
  </font>

软件过程模型：从一个特定角度提出的对软件过程的概括描述，是对软件开发过程的抽象，包括构成软件过程的各种**活动(Activity)**、**软件工件(Artifacts)**、参**与角色(Actors/Roles)**等。

软件生命周期模型：一个框架，描述软件需求定义直至软件经过使用后废弃为止，跨越整个生命期的软件开发、运行、维护所实施的全部**过程、活动、任务**。同时描述生命周期不同阶段产生的**软件工件，明确活动的执行角色**等。

### 传统软件生命周期模型

传统模型种类：瀑布模型、演化模型、增量模型、喷泉模型、V&W 模型、螺旋模型、构件组装模型、快速应用开发模型、原型方法。

#### 瀑布模型 Water Fall Model

**是所有其他软件生命周期模型的基础，最经典。**
1970年提出的，属于是软件危机的关键时期。
![waterfall](https://api2.mubu.com/v3/document_image/2eec8cce-b4f6-4bc3-8d69-a2986079fc79-16175743.jpg)

![backroll](https://api2.mubu.com/v3/document_image/7c061528-7e92-42d8-aab8-24ab33ba4df6-16175743.jpg)

- 特征
  - 文档驱动，本阶段的工作对象来自于上一阶段活动的输出文档。
  - 每个阶段要产生本阶段的输出——软件文件
  - 每个阶段结束都有评审，方便出现问题立即解决。
- 优点
  - 降低开发复杂度、提高透明性可管理性。
  - ==推迟了软件实现，强调必须先分析和设计。==
  - 对本阶段活动执行情况进行评审，以文档评审等手段指导整个开发过程，保证了错误不会留到下一个周期。
- 缺点
  - 缺乏灵活性，无法解决需求不明或不准确的问题。
  - 风险控制能力较弱。
  - 文档过多时，增加工作量。且文档的完成情况并不能完全反映实际项目情况，导致错误结论。

#### 演化模型 Evolutional Model

![yanhua](https://api2.mubu.com/v3/document_image/a4e081e5-94ec-4d25-9f46-a7781364fd41-16175743.jpg)

- 提倡两次开发（Do Twice）：第一次得到试验性的原型产品，探索可行性，明确需求。第二次在此基础上开发成品。

>相对于瀑布模型而言,演化模型的一个明显优点就是可以处理需求不明确的软件项目，对于探索式的演化模型,能够在开发过程中间逐步向用户展示软件半成品,降低系统的开发风险。
另外,演化模型将用户的参与始终贯穿在开发过程中,使最终的软件系统能够真实地实现用户需求,又保障系统质量。

- (1)**探索式**演化模型：其目标是与用户一起工作,共同探索系统需求,直到最后交付系统。
- (2)**抛弃式**演化模型：通过实现一个或多个系统原型理解和明确用户需求,然后给出系统一个较好的需求定义。

- 优点：
明确用户需求、提高系统质量、降低开发风险。
- 缺点：
  - 难于管理、结构较差、技术不成熟。
  - 可能会抛弃瀑布模型的文档控制优点。
  - 缺乏设计，可能导致软件系统结构较差。
- 适用范围：需求不清楚、中小型系统、开发周期短。

#### 增量模型 Incremental Model

- 首先对系统最核心或最清晰的需求进行分析、设计、实现、测试。再按优先级逐步对后续的需求进行上述开发工作。**结合了演化和瀑布模型的优点。**
![incremental](https://api2.mubu.com/v3/document_image/2d117c6c-eef1-4e14-9f71-01b34cbc348f-16175743.jpg)

>在增量模型中,客户大概或模糊地提出系统须提供的服务或功能,即给出系统的需求框架,以及这些服务或功能的重要作用,从而可以确定系统需求实现的优先级。
为了避免多个增量集成时导致不一致的系统体系结构,增量模型在获取系统框架需求后,针对核心需求及系统的性能要求确定系统的体系结构,并以此体系结构指导增量的集成,保证在整个开发过程中体系结构稳定。

- 优点：
  - 第一次增量实现系统核心功能，增强客户使用系统的信心。
  - <u>项目总体失败风险较低,因为先开发核心功能</u>，即使某一次增量失败，核心功能还是能用。
  - 最高优先级的功能先开发，得到最多测试，<u>保障可靠性</u>。
  - 增量在同一体系指导下进行集成，提高稳定性和可维护性。
- 缺点：
  - 难以选择增量粒度。
  - 难以确定所有需求。

#### 喷泉模型（迭代模型）Fountain Model

高情商：各个开发阶段没有特定次序要求，可以并行进行，可以随时补充遗漏的需求（低情商：想到什么做什么，瞎 JB 写）。(比较灵活，用的不多)
优点：提高开发效率、缩短开发周期。
缺点：难于管理。
适用于：需求不明晰。

#### V&W模型

V模型在瀑布模型基础上改进，把测试活动提前，使得模型能够驾驭风险。后来Evolutif公司在V模型的基础上提出了W模型。

![v&w](https://api2.mubu.com/v3/document_image/8e964947-070a-4187-812b-4855c4c8635d-16175743.jpg)

V模型的左半部分就是在测试阶段之前的瀑布模型，即V模型的开发阶段，右半部分是测试阶段。V模型明确地划分测试的级别,并将其与开发阶段的活动对应。

![WW](https://api2.mubu.com/v3/document_image/4b3c2f3d-2380-4a6a-b5f8-e86aeb86556f-16175743.jpg)

W模型强调：测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求和设计同样需要测试，即测试与开发是同步进行的。（相当于测试的时间提前了，并且贯穿整个软件的生命周期）
由于W模型扩展测试的内容：增加确认和验证活动，所以它有利于尽早地全面发现问题。

#### 螺旋模型 Spiral Model

![luoxuan](https://api2.mubu.com/v3/document_image/dfb95e35-8a21-448c-bf25-e5a778cbf75d-16175743.jpg)

- 针对大型软件开发项目的特点而提出来的。
- 分为**四个象限**螺旋上升：风险分析、制定计划、实施工程、客户评价——进入下一回路。
- 适用于：开发周期长、风险高的大型软件。

构件组装模型：

- 模块化思想，使用复用构件库的组件搭建系统。

- 优点：
  - 软件复用、提高效率。
  - 允许多项目同时开发，降低费用、提高可维护性。
- 缺点：
  - 缺乏通用构建组装标准风险较大。
  - 构建可重用性与系统高效性不易协调。
  - 过分依赖构件，构件质量影响产品质量。

#### 构件组装模型

![goujian](https://api2.mubu.com/v3/document_image/a1f1766a-7dc6-4553-8e93-702aa973b0d1-16175743.jpg)

- 模块化思想，使用复用构件库的组件搭建系统。

- 优点：
  - 软件复用、提高效率。
  - 允许多项目同时开发，降低费用、提高可维护性。
- 缺点：
  - 缺乏通用构建组装标准，风险较大。
  - 构建可重用性与系统高效性不易协调。
  - 过分依赖构件，构件质量影响最终产品质量。

#### 快速应用开发模型（RAD）

英文是 Rapid Application Development

![RAD](https://api2.mubu.com/v3/document_image/a3bd5c9f-cc02-4282-b5ba-cb3cd2a64345-16175743.jpg)

- 开发周期 60-90 天(很短)，分小组同步进行软件各部分开发。
- 缺点：时间短，需要强沟通配合。不适合所有应用。
- 适用于：信息管理系统的开发，对于其他系统不太适合。

#### 原型方法 Prototyping Method

原型指的是 模拟某种最终产品的原始模型。
用户通过使用原型系统提出修改意见。
和增量好像也没什么区别
主要用于明确需求，**也可以用于软件开发的其他阶段**。（加粗部分也是它与增量模型和演化模型的区别）

![pm](https://api2.mubu.com/v3/document_image/f4ab4a6b-fc80-4ba7-bcdc-4cd6533dce6d-16175743.jpg)

![2](https://api2.mubu.com/v3/document_image/16775692935997df0.jpg)

### 新型软件生命周期模型
