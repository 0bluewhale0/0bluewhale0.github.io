<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>szh的博客</title>
    <url>/2024/04/11/SZH%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><em>为天地立心，为生民立命，为往圣继绝学，为万世开太平</em></p>
]]></content>
  </entry>
  <entry>
    <title>睡了一整天，头疼</title>
    <url>/2022/03/12/%E7%9D%A1%E4%BA%86%E4%B8%80%E6%95%B4%E5%A4%A9%EF%BC%8C%E5%A4%B4%E7%96%BC/</url>
    <content><![CDATA[<p>又睡了一整天<br>脑壳疼<br>醒着的时间都在无所事事<br>中午喝粥把粥打翻了<br>十九岁了还没学会吃饭，简直比小时候还没用<br>明明知道规律的作息才能让人快乐<br>还是沉溺于一时的安逸，招致更大的痛苦<br>瘫着睡觉的时间出去逛街也好，给影姐姐攒石头也罢<br>总比神志不清的浪费要强<br>以此记录，下不为例。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>少年听雨</tag>
        <tag>废物言论</tag>
      </tags>
  </entry>
  <entry>
    <title>【share】毛概教材2021</title>
    <url>/2022/03/01/%E6%AF%9B%E6%A6%82%E6%95%99%E6%9D%90/</url>
    <content><![CDATA[<p><a href="https://pan.baidu.com/s/1CsdIdIfRZiUktfCOGZgixg">2021新版毛概教材带跳转目录</a><br>提取码：hhhh</p>
<p>若分享链接失效请留言，会及时更新。</p>
]]></content>
      <categories>
        <category>source</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>source share</tag>
      </tags>
  </entry>
  <entry>
    <title>碎碎念</title>
    <url>/2022/02/25/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<p> 在szh坚持不懈的摸鱼之下博客勉勉强强搭起来了，一些后续功能就‘明天’(咳咳)再说。</p>
<p> 这个寒假全程阴间作息，导致对即将到来的网课丝毫没有能好好听课的信心。真是颓废混蛋并且一事无成啊。</p>
<p> 对人际关系也变得十分懒怠，有时候会无缘无故的消失一整天，自己躲起来干一些浪费时间的事情，看一些无聊的小说或者剧，就好像缩在一个安全的壳里一样。等到开学被迫见到许多人的时候这种情况应该会改善很多，到时候会怎么样大概完全取决于我朋友们的肚量(bushi)。</p>
<p> 哦对，寒假学会了擀饺子皮儿，这样看也不算一事无成。</p>
<p> 第二大的遗憾就要数今年冬天没见到雪吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>少年听雨</tag>
      </tags>
  </entry>
  <entry>
    <title>计网阅读笔记_1 引言</title>
    <url>/2022/03/02/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0_1%E5%BC%95%E8%A8%80/</url>
    <content><![CDATA[<h2 id="术语-szh这个电脑垃圾的自我科普"><a href="#术语-szh这个电脑垃圾的自我科普" class="headerlink" title="术语(szh这个电脑垃圾的自我科普)"></a>术语(szh这个电脑垃圾的自我科普)</h2><ul>
<li><strong>CN</strong> computer networks计算机网络</li>
<li>interconnected 相互连接的：这两台计算机能够交换信息</li>
<li><strong>计算机网络</strong>和<strong>分布式系统</strong>的关键差别：由一组独立计算机组成的分布式系统呈现给用户的是一个关联系统。在用户看来，分布式系统只是一个模型或泛型。通常在操作系统之上有一层软件负责实现这个模型，这个软件就称为中间件(middleware)。最著名的分布式系统是万维网(World Wide Web)。分布式系统是建立在网络之上的软件系统。网络与分布式系统之间的区别在于软件(尤指操作系统)，而非硬件。</li>
<li>VPN(virtual private networks) 虚拟专用网络:目的是试图终结“地理位置的束缚”</li>
<li>Server 服务器：数据存储的性能最强大的计算机</li>
<li>client 客户机：其他人使用的机器</li>
<li>IP telephone IP电话：通过计算机网络打电话，如果采用了Internet技术则称为IP语音(VoIP,voice over IP)。</li>
<li>e-commerce，electronic commerce 电子商务：简单来说就是网购</li>
<li><a href="www.acm.org">ACM</a> <a href="www.computer.org">IEEE</a></li>
<li>peer-to-peer 对等通信：每个人可以与一个或者多个其他人通信，这里的客户端和服务器没有明确的分工。许多对等系统没有任何中央内容数据库，如BitTorrent(没错就是那个BT！)</li>
<li>instant messaging 即时消息：UNIX系统有talk程序，允许两人相互实时的输入消息。多人参与的消息服务有Twitter，这样发送的消息称为tweet。</li>
<li>wiki是一个协作型的网站。最著名的Wikipedia，一部任何人都可以编辑的百科全书</li>
<li>由于to和2在英文中发音相同，电子商务有了一些可爱的小标签，B:business，C：customer，G：government<img src="https://api2.mubu.com/v3/document_image/019df50c-e675-4f48-8bc2-40bb369e9264-16175743.jpg" alt="小标签"></li>
<li>ubiquitous computing 普适计算：生活中的各种用电，燃气，传感器读数等</li>
<li><strong>RFID Radio Frequency IDentification 射频识别</strong>：可能将现实世界变成物联网</li>
<li><strong>hotspot 无线热点</strong></li>
<li>m-commerce，mobile-commerce 移动商务：就是手机支付</li>
<li><strong>NFC(Near Field Communication)近场通信</strong>：让手机可以充当RFID的智能卡和附近的RFID读写器互动完成消费支付</li>
<li>sensor network 传感器网络：由感知物理世界状态的结点组成，这些节点收集它们感知到的信息，并通过无线中继发送。</li>
<li>network neutrality 网络中立：通信不应该区分内容，来源，或内容提供者的论点</li>
<li><strong>PAN Personal Area Network 个域网</strong>：蓝牙，RFID等</li>
<li><strong>LAN local area network 局域网</strong>：私有网络，被广泛用来连接个人计算机和消费类电子设备，使他们能够共享资源(打印机)和交换信息。当局域网被用于公司消费时，被称为企业网络。</li>
<li>互联处理器的分类<img src="https://api2.mubu.com/v3/document_image/ffd1649a-0364-40e4-9a71-3dfc1b206f25-16175743.jpg" alt="互联处理器的分类"></li>
<li>AP(Access Point)接入点、(wireless router)无线路由器、(base station)基站：局域网中的一个与每台计算机进行通信的设备。</li>
<li>[quite interesting]无线局域网的一个标准称为<strong>IEEE 802.11</strong>，俗称<strong>WiFi</strong>(chapter 4 详细介绍)。而IEEE802.3的俗称我以太网(ethernet)。具体模型如图。<img src="https://api2.mubu.com/v3/document_image/5aa08c52-c410-4645-a2bd-bf0188f70298-16175743.jpg" alt="无线和有线LAN"></li>
<li><strong>MAN Metropolitan Area Network 城域网</strong></li>
<li><strong>WAN Wide Area Network 广域网</strong>：一般跨越比较大的地理区域。我们把专门运行用户程序的计算机称为<strong>主机(host)<strong>，连接这些主机的网络其余部分称为</strong>通信子网(communication subnet)</strong>,或简称<strong>子网(subnet)</strong></li>
<li>多数广域网中，子网由<strong>传输线路(transmission)</strong> 和 <strong>交换元素(switching element)</strong> 组成。</li>
<li>传输线路：负责在机器之间移动比特，可以是铜线光纤无线链路</li>
<li>交换元素：switching element简称<strong>交换机switch</strong>，是专用的计算机，负责链接两条或者两条以上的线路。</li>
<li>Internet：特指每天使用的互联网</li>
<li>Internet：连接在一起的网络</li>
<li>网关&#x3D;&#x3D;路由器</li>
<li>传输技术的分类：按照transmission technology分类：分为 广播式(broadcast)和点到点(point-to-point)链路</li>
<li>点到点传输只有一个发送方和一个接收方，故也称为单播。</li>
<li>而广播网络上：通信信道被网络上的所有机器共享，一般只要特定的一个机器对其响应，无线网络是一个常见例子。特别的，如果地址字段使用一组特殊的编码，所有机器(Broadcasting广播)或者一组机器(multicasting组播)都会对其响应。</li>
<li>互联网络：两个或多个网络的链接，Internet是最著名的互联网络实例。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记_物理层1</title>
    <url>/2022/03/10/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0-%E7%89%A9%E7%90%86%E5%B1%821/</url>
    <content><![CDATA[<p>学不会了，单纯进行一个复制粘贴<br>可能应该去信通蹭蹭课了 <font size="7">悲</font></p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li>Channel<strong>信道</strong>：传输信息的媒体</li>
<li>Bit Rate<strong>数据率</strong>：数据传输速率（bps）</li>
<li>Baud<strong>波特</strong>：符号&#x2F;码元传输速率 $1Baud &#x3D;(\log_2{V})bps$，其中V是信号的电平级数(理解为<strong>进制数</strong>，每一个电平级数用一个符号表示，换成二进制位数就是这个公式)，比如电平级数为2时，波特速率等于比特速率。如果在数字传输过程中，0V、2V、4V和6V分别表示00、01、10和11，那么每个码元有四种状态00、01、10和11。每个码元代表两个二进制数字。大部分情况下，波特速率&gt; bit速率。<br><img src="https://api2.mubu.com/v3/document_image/164707928280699fe.jpg" alt="111"></li>
<li>Propagation Speed<strong>传播速度</strong>：通信线路上，信号单位时间内传送的距离(m&#x2F;s)。光速：$3\times10^8m&#x2F;s$。</li>
<li>Bandwidth<strong>带宽</strong>：<mark>在单位时间里，能发送的最大比特数</mark>PPT上写“信号占用的频率范围(HZ)不知道是什么意思。但是HZ本身就是($s^{-1}$)，和bps($\tiny\cfrac{比特数}{传输这些比特所用的时间}$)的单位一样。<br>补充↑：带宽的两种意思<br><img src="https://api2.mubu.com/v3/document_image/58cded3d-2107-41e9-8fd9-f601dcece668-16175743.jpg" alt="补充：带宽的两种意思"></li>
<li>Channel Capacity信道容量：信道的<strong>最大</strong>数据率</li>
<li>Throughput吞吐量：网络容量的度量，表示单位时间内网络可以传送的数据位数(bps)</li>
<li>Bit Error Rate误码率(BER):信道传输可靠性指标，可能会很低，如$10^{-12}$等<br>$P&#x3D;\cfrac{传送错误的位数}{传输总位数}$</li>
<li>Delay时延：<mark>从向网络中发送数据块的第一比特开始，到最后一位数据被接收所经历的时间</mark>。包括发送时间+传播时间+处理时间+排队时间，</li>
<li>时延的组成<ul>
<li>传播时延：信号通过传输介质的时间</li>
<li>发送时延：设备发送一个数据块所需要的时间<br>$发送时延&#x3D;\cfrac{数据块长度}{信道带宽}$，这里的带宽指的是<mark>单位时间内能发送的最大比特数</mark>。注意二者单位的统一。</li>
<li>处理时间：交换机&#x2F;路由器检查数据、选路的时间</li>
<li>排队时延：在交换机&#x2F;路由器中排队等待的时间</li>
</ul>
</li>
<li>几种通信方式：Simplex【单工链路】, Half-duplex【半双工链路】, Full-duplex【全双工】，其中，全双工是最常见的。<ul>
<li>Simplex【单工链路】：只能单向，腾讯课堂这样的</li>
<li>Half-duplex【半双工链路】：双方都可发送可接受，但不能同时发送和接受，对讲机</li>
<li>Full-duplex【全双工】：双车道一样的，可以同时发送和接受</li>
</ul>
</li>
<li>并行通信Parallel$\tiny平行的并行的$ transmission<img src="https://api2.mubu.com/v3/document_image/4e3e79a4-f002-46e0-8a92-1c0805542a31-16175743.jpg"></li>
<li>串行通信Serial transmission(在不同机器之间的通信较为常见)<img src="https://api2.mubu.com/v3/document_image/284a2a06-99a7-47f1-9a85-b9c144192557-16175743.jpg"><ul>
<li>同步Synchronous</li>
<li>异步Asynchronous，始终不需要同步，仅需三条线路（一来一回+地线）便可以完成，（同步需要五条线，一来一回需要两个时钟信号）但收发双方的时钟可能出现偏差，一般应用于短距离通信。</li>
</ul>
</li>
</ul>
<h2 id="2-1数据通信的理论基础"><a href="#2-1数据通信的理论基础" class="headerlink" title="2.1数据通信的理论基础"></a>2.1数据通信的理论基础</h2><h3 id="傅里叶分析"><a href="#傅里叶分析" class="headerlink" title="傅里叶分析"></a>傅里叶分析</h3><p>高数学到狗肚子里去了，根本看不懂(大草)。</p>
<h3 id="带宽有限的信号"><a href="#带宽有限的信号" class="headerlink" title="带宽有限的信号"></a>带宽有限的信号</h3><p>不要求会算，但是要求理解带宽对速率的限制。(我不理解，哭哭)</p>
<ul>
<li><p>没有设备能够不损耗能量地传输信号</p>
</li>
<li><p>所有的传输设施对于不同傅里叶分量的衰减程度并不相同，从而导致接收端收到的结果信号发生也就是说，如果等量的衰减，是不会变形的。</p>
</li>
<li><p><strong>带宽的定义</strong>：课本和ppt是这样说的</p>
<blockquote>
<p>一般情况下对导线而言，在0到某个频率$f_c$的这段范围内，振幅在传输过程中不会衰减(这里$f_c$可以用Hz(赫兹)来度量)，而在此截止频率$f_c$之上的所有频率的振幅都将有不同程度的减弱。这段在传输过程中振幅不会明显减弱的频率的宽度就称为带宽(bandwidth)。通常引用的带宽是指从0到使得接收能量保留一半的那个频率位置。ps:滤波器一般可用来进一步限制信号的带宽。</p>
</blockquote>
</li>
<li><p>决定带宽的因素：<strong>带宽是传输介质的一种物理性质</strong>，由以下决定</p>
<ul>
<li>介质的构成</li>
<li>介质的厚度</li>
<li>电线或者光纤(也就是介质 阿巴阿巴)的长度</li>
</ul>
</li>
</ul>
<h3 id="信道的最大数据速率"><a href="#信道的最大数据速率" class="headerlink" title="信道的最大数据速率"></a>信道的最大数据速率</h3><blockquote>
<p>待补充，回头写</p>
</blockquote>
<ol>
<li><p>Nyquist’s theorem (1924)<br>If a signal has been run through a low-pass filter of bandwidth H,  the signal can be completely reconstructed by making 2H samples per second<br>  C&#x3D;2Hlog2V</p>
</li>
<li><p>Shannon’s Theorem (1948)</p>
</li>
</ol>
<blockquote>
<p>$\tiny摘自百度百科$<br>类比：城市道路上的汽车的车速（业务速率）和什么有关系？<br>除了和自己车的动力有关之外，主要还受限于道路的宽度（带宽）和车辆多少、红灯疏密等其他干扰因素（信噪比）。<br>俗话说：“<strong>有线的资源是无限的，而无线的资源却是有限的。</strong>”无线信道并不是可以任意增加传送信息的速率，它受其固有规律的制约，就像城市道路上的车一样不能想开多快就开多快，还受到道路宽度、其他车辆数量等因素影响。这个规律就是香农定理。香农定理是所有通信制式最基本的原理，它描述了有限带宽、有随机热噪声信道的最大传输速率与信道带宽、信号噪声功率比之间的关系。</p>
</blockquote>
<p>香农定理由如下的公式给出: <mark><br>$C&#x3D;W\times\log_2{(1+\frac{S}{N})}$<br></mark>其中C是可得到的链路速度，W是链路的带宽，S是平均信号<strong>功率</strong>,N是平均噪声<strong>功率</strong>，信噪比（S&#x2F;N）通常用分贝（dB）表示，<mark>$分贝数&#x3D;10\times\log_{10}{(\frac{S}{N})}$</mark>,这里的分贝不同于平时认为的声音大小的单位，而在实际上，声音大小的单位也并不是分贝(分贝本身是一个同单位比值),而是用声压大小反映，由于分贝取对数的特性符合日常表达需要，所以用声压对应的分贝来表示声音大小。真正的分贝分为两种，功率之比和幅值之比，香农公式这里采用的是功率之比的定义。详见 <a href="https://zhuanlan.zhihu.com/p/22821588">这里</a> 以及<a href="https://baike.baidu.com/item/%E5%88%86%E8%B4%9D/553473">这里</a>(后者为百度百科)。</p>
<h2 id="2-2引导性传输介质Guided-Transmission-Media"><a href="#2-2引导性传输介质Guided-Transmission-Media" class="headerlink" title="2.2引导性传输介质Guided Transmission Media"></a>2.2引导性传输介质Guided Transmission Media</h2><p>这块儿懒得记，应该是兴趣性了解即可，书上还有点儿笑话看。<br>这儿就记个大纲</p>
<ol>
<li><p>磁介质 Manetic Media<br>“永远不要低估一辆满载着磁带在高速公路上飞驰的旅行车的带宽”<br>高带宽高延迟</p>
</li>
<li><p>双绞线 Twisted Pair<br>  到6类为止，所有的双绞线都成为<strong>非屏蔽双绞线(UTP)</strong>(unsheild twisted pair)<br>  7类双绞线在每对、整个线缆外加一个屏蔽层</p>
</li>
<li><p>同轴电缆 coaxial cable<br>  <font size="2">cable(钢索，电缆)</font><br>  <img src="https://api2.mubu.com/v3/document_image/7fdd5fef-512e-438a-8002-5c152f02f95d-16175743.jpg" alt="1"></p>
</li>
<li><p>电线 Power line</p>
</li>
<li><p>光纤 （Fiber Cables）&amp; 光缆<br>根据中心光纤的直径，分为多模、单模<br>多模以不同的角度来回反射着前进，单模直径只有几光波，几乎沿直线传输</p>
</li>
</ol>
<blockquote>
<p>参考链接<br><a href="https://zhuanlan.zhihu.com/p/350152827#:~:text=%E5%88%86%E8%B4%9D%E4%B8%8E%E4%BF%A1%E5%99%AA%E6%AF%94%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%BA%20%3A%20db%3D10lg%EF%BC%88s%2Fn%EF%BC%89%20%E4%BF%A1%E5%99%AA%E6%AF%94%E6%98%AF%E4%BF%A1%E5%8F%B7%E7%94%B5%E5%8E%8B%E5%AF%B9%E4%BA%8E%20%E5%99%AA%E5%A3%B0%E7%94%B5%E5%8E%8B%20%E7%9A%84%E6%AF%94%E5%80%BC%EF%BC%8C%E9%80%9A%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7%20s%2Fn%20%E6%9D%A5%E8%A1%A8%E7%A4%BA%E3%80%82,%E4%B8%BA45~55db%EF%BC%8C%E8%8B%A5%E4%B8%BA50db%EF%BC%8C%E5%88%99%E5%9B%BE%E5%83%8F%E6%9C%89%E5%B0%91%E9%87%8F%E5%99%AA%E5%A3%B0%EF%BC%8C%E4%BD%86%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E8%89%AF%E5%A5%BD%EF%BC%9B%E8%8B%A5%E4%B8%BA60db%EF%BC%8C%E5%88%99%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E4%BC%98%E8%89%AF%EF%BC%8C%E4%B8%8D%E5%87%BA%E7%8E%B0%E5%99%AA%E5%A3%B0%E3%80%82%20%E7%BD%91%E9%A1%B5%E4%BF%A1%E5%99%AA%E6%AF%94%20%E6%9F%A5%E8%AF%A2%E4%BF%A1%E5%99%AA%E6%AF%94%20%28Signal%2FNoise%29%EF%BC%8C%E5%8E%9F%E6%98%AF%E7%94%B5%20%E5%A3%B0%E5%AD%A6%20%E9%A2%86%E5%9F%9F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%8C%87%E5%A3%B0%20%E9%9F%B3%E6%BA%90%20%E4%BA%A7%E7%94%9F%E6%9C%80%E5%A4%A7%E4%B8%8D%E5%A4%B1%E7%9C%9F%E5%A3%B0%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%BC%BA%E5%BA%A6%E4%B8%8E%E5%90%8C%E6%97%B6%E5%8F%91%E5%87%BA%E5%99%AA%E9%9F%B3%E5%BC%BA%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E7%8E%87%E3%80%82">信噪比</a></p>
</blockquote>
<!---
## 2.4通信卫星

## 2.5数字调制与多路复用

## 2.6公共电话交换网络

## 2.7移动电话系统

## 2.8有线电视

--->
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记-物理层2</title>
    <url>/2022/03/20/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0-%E7%89%A9%E7%90%86%E5%B1%822/</url>
    <content><![CDATA[<h2 id="2-3无线传输"><a href="#2-3无线传输" class="headerlink" title="2.3无线传输"></a>2.3无线传输</h2><p>胡乱写一写，基本都是截图，物理层实在让人不懂。大哭。</p>
<h3 id="电磁频谱-The-Electromagnetic-Spectrum"><a href="#电磁频谱-The-Electromagnetic-Spectrum" class="headerlink" title="电磁频谱 The Electromagnetic Spectrum"></a>电磁频谱 The Electromagnetic Spectrum</h3><ul>
<li>Electromagnetic spectrum and its uses for communication↓</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/8786acbc-2976-43f0-b3f3-f321a9e9f27f-16175743.jpg" alt="111"></p>
<img src="https://api2.mubu.com/v3/document_image/6f159e0b-7dc7-449a-9ccf-c049c2037e08-16175743.jpg" width="400" height="80">

<ul>
<li>Using narrow frequency band大多数信息传输使用窄带通信</li>
<li>Spread Spectrum (bluetooth, wlan, cdma)<br>  FHSS: 跳频扩频Frequency hopping spread spectrum<br>Hedy Lamarr (1913-2000)<br>  DSSS: 直接序列扩频Direct sequence spread spectrum<br>  UWB 超宽带通信(Ultra-WideBand) communication.<br>  UWB sends a series of rapid pulses, varying their positions to communicate information.</li>
<li>除非特别声明，我们假设所有的传输都使用窄带频段</li>
</ul>
<h3 id="无线电传输"><a href="#无线电传输" class="headerlink" title="无线电传输"></a>无线电传输</h3><ul>
<li>无线电传输是像个气球一样沿着各个方向传播的，所以不用刻意对齐(下面那个微波传输就得对齐)</li>
<li>无线电频率RF（Radio Frequency）</li>
<li>路径损耗 不同于引导性介质上的信号衰减是以y&#x3D;b-kx的大致形式衰减，无线电波随着距离增加，信号能量<strong>衰减的速度</strong>以距离的-2次幂下降(相当于下降的斜率在不断减小)，这意味着无线电信号可以传播很长的距离。</li>
</ul>
<h3 id="微波传输"><a href="#微波传输" class="headerlink" title="微波传输"></a>微波传输</h3><p>在超过100MHZ的频段，电磁波沿着直线传播，微波在$10^8$~$10^{10}$之间，所以也沿着直线传播</p>
<p><font size="10" color="green">其余跳过</font></p>
<h2 id="2-5数字调制与多路复用"><a href="#2-5数字调制与多路复用" class="headerlink" title="2.5数字调制与多路复用"></a>2.5数字调制与多路复用</h2><ul>
<li>定义：比特与代表它们的信号之间的转换过程称为数字调制( digital modulation)。</li>
<li>信道通常被多个信号共享。毕竟，用单根线缆传送几个信号比为每个信号铺设一-根线缆要便利得多。这种信道的共享形式称为<strong>多路复用技术( multiplexing)</strong></li>
</ul>
<h3 id="基带传输"><a href="#基带传输" class="headerlink" title="基带传输"></a>基带传输</h3><p><strong>baseband transmission</strong>：如何把数据比特<strong>直接</strong>转换成信号的一些方案。信号的传输占有传输介质上从零到最大值之间的<strong>全部频率</strong>，而最大频率则取决于信令signaling速率。是<strong>有线介质</strong>普遍使用的一种调制方法。</p>
<p><img src="https://api2.mubu.com/v3/document_image/bddb772e-158f-4cb6-bea6-8b23247de897-16175743.jpg" alt="2"></p>
<h3 id="通带传输"><a href="#通带传输" class="headerlink" title="通带传输"></a>通带传输</h3><p><strong>passband transmission</strong>：通过调节载波信号的<strong>幅值、相位或频率</strong>来运载比特的方案。信号占据了以载波信号频率为中心的一段频带。是<strong>无线和光纤信道</strong>最常使用的调制方法。<strong>只能</strong>在<strong>给定的频带</strong>中传输信号。<br><img src="https://api2.mubu.com/v3/document_image/da181503-0649-4509-8685-ccb573dbc8e9-16175743.jpg" alt="5"><br>(a):<!---QPSK Quadrature phase shift keying 正交相移键控---><br>(b):<!---QAM-16 Quadrature Ampllitude Modulation 正交调幅---><br>(c):<!---QAM-64---><br>答案用注释藏起来了，忘记了的话请F12或者看物理层ppt（皮）。</p>
<h3 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h3><p><strong>Frequency Division Multiplexing</strong><br><img src="https://api2.mubu.com/v3/document_image/3330e8fa-d7c5-4714-981e-a11d2c733e0d-16175743.jpg" alt="6"><br>(a) The original bandwidths.<br>(b) The bandwidths raised in frequency.<br>(b) The multiplexed channel.</p>
<h3 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h3><p><strong>Time Division Multiplexing</strong><br><img src="https://api2.mubu.com/v3/document_image/25bd7832-63ea-4af4-bd0b-d3840f628701-16175743.jpg" alt="7"></p>
<h3 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h3><p><strong>CDMA – Code Division Multiple Access</strong><br><img src="https://api2.mubu.com/v3/document_image/872dce89-17c9-4d4a-86b7-917e4d74bf72-16175743.jpg" alt="8"></p>
<h2 id="2-6公共电话交换网络"><a href="#2-6公共电话交换网络" class="headerlink" title="2.6公共电话交换网络"></a>2.6公共电话交换网络</h2><h3 id="本地回路：调制解调器、ADSL和Fiber"><a href="#本地回路：调制解调器、ADSL和Fiber" class="headerlink" title="本地回路：调制解调器、ADSL和Fiber"></a>本地回路：调制解调器、ADSL和Fiber</h3><ul>
<li><p>调制解调器<br>modem&#x3D;modulator调制器+demodulator解调器<br>  <img src="https://api2.mubu.com/v3/document_image/83e23a78-739d-43e5-b983-5d3124d35d73-16175743.jpg" alt="3"><br>  <img src="https://api2.mubu.com/v3/document_image/a57925f1-a68b-4ffc-be9d-670cef75ec7c-16175743.jpg" alt="4"></p>
</li>
<li><p>ADSL<br>OFDM编码方式可以用于这些信道上发送数据，在ASDL文档中经常被称为DMT（Discrete MultiTone 离散多音），<br><img src="https://api2.mubu.com/v3/document_image/d9af3f5c-ec1c-42ed-bd97-bce7a5faecea-16175743.jpg" alt="ADSL"><br><img src="https://api2.mubu.com/v3/document_image/d1dd9c3e-bb15-4b57-a9db-b9e2c51fa569-16175743.jpg" alt="ADSL"></p>
</li>
<li><p>一种典型的ADSL设备配置<br><img src="https://api2.mubu.com/v3/_document_image_/2f6e0473-4016-4f14-b3b1-fc226a81ae3f-16175743.jpg" alt="2"></p>
</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/06a0d98b-2b88-4ffa-b206-fb0bf7da2f77-16175743.jpg" alt="3"></p>
<ul>
<li>FttH:fiber to the home 光纤入户<br><img src="https://api2.mubu.com/v3/document_image/41c22d14-89c8-4ce0-a45a-64ca90f8b07e-16175743.jpg" alt="5"></li>
</ul>
<h3 id="中继和多路复用"><a href="#中继和多路复用" class="headerlink" title="中继和多路复用"></a>中继和多路复用</h3><p>trunk and Multiplexing</p>
<ul>
<li><p>PCM：脉冲编码调制，关于为什么是64bps、125Чsec<br><img src="https://api2.mubu.com/v3/document_image/ebff4d33-7a87-47a8-ae47-d69a7769b288-16175743.jpg" alt="10"></p>
</li>
<li><p>TDM时分多路复用<br><img src="https://api2.mubu.com/v3/document_image/b05b3ba8-0d7f-4a62-8e29-adbbc7c44f1a-16175743.jpg" alt="4"><br>The T1 carrier (1.544 Mbps).<br>E1 2.048<strong>Mbps</strong></p>
</li>
<li><p><strong>TDM数据传输</strong><br><img src="https://api2.mubu.com/v3/document_image/9fc8a918-402c-449e-84cc-0f2a53540d7b-16175743.jpg" alt="2-8TDM数据传输"></p>
</li>
</ul>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>电路交换和包交换的比较<br><img src="https://api2.mubu.com/v3/document_image/6b76cb90-5dc3-4e61-9c76-f241e1418af4-16175743.jpg" alt="比较"><br><img src="https://api2.mubu.com/v3/document_image/ecc4e8fa-fd80-4174-b0e1-e4fa87b63b30-16175743.jpg" alt="比较"></p>
<p><img src="https://api2.mubu.com/v3/document_image/560e8f18-fd1a-430b-a28e-047656cd29eb-16175743.jpg" alt="课本上的图"></p>
<p><img src="https://api2.mubu.com/v3/document_image/74258e7a-36e5-4d57-aa37-097eaccfd52d-16175743.jpg" alt="画图画的包传输"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记-1综述</title>
    <url>/2022/03/09/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0-1%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="1-3网络软件"><a href="#1-3网络软件" class="headerlink" title="1.3网络软件"></a>1.3网络软件</h2><h3 id="协议层次结构Protocol-Hierarchies"><a href="#协议层次结构Protocol-Hierarchies" class="headerlink" title="协议层次结构Protocol Hierarchies"></a>协议层次结构Protocol Hierarchies</h3><ul>
<li>为了降低网络设计的复杂性，绝大多数网络都组成了层次栈(a stack of layer)或(a stack of level)。从某种意义上来说，每一层都是一种虚拟机，第n层向第n+1层提供服务。</li>
<li><strong>协议protocol</strong>：通信双方的一种约定</li>
<li><strong>对等体peers</strong>：不同机器上同一层的实体</li>
<li><strong>物理层次Physical medium</strong>：铜线，光纤</li>
<li><strong>接口interface</strong>：Defines which <mark>primitive operations原语操作</mark> and services the lower layer makes available to the upper one，类似于函数调用的接口</li>
<li><strong>网络体系结构</strong>&#x3D;层+协议A set of layers and protocols 网络体系结构<strong>不包括</strong>协议内部的实现细节，也不包括接口的规范。</li>
<li><img src="https://api2.mubu.com/v3/document_image/3f2c4521-c474-4228-8629-b682619c7f09-16175743.jpg"></li>
<li>支持第五层虚拟通信的信息流：假设在第5层上运行的一个应用进程产生了一.条消息M,并且将它传递给第4层以便传给对等进程;第4层在消息的前面加上一一个头(header)， 用来标识该消息，并且把结果传给第3层;该头包含了一些控制信息，例如地址，主要被目标机器的第4层用来递交消息。某些层次所用的控制信息还可以包含消息序号(以防下层不保留消息顺序)、消息大小、时间等。<br><img src="https://api2.mubu.com/v3/document_image/4bd06528-60a8-4049-8fb3-63709fa51e26-16175743.jpg" alt="支持第五层虚拟通信的信息流"><br>在许多网络中，对于第4层上传递的消息<strong>大小</strong>没有任何限制，但是几乎所有第3层协议对此总会强加一个限制。因此，第3层必须把入境消息分割成较小的单元，即数据包或包(packet)，并且在每个数据包前面加上第3层的头。在这个例子中，M被分割成两部分：M1和M2，这两部分内容是被单独传输的。</li>
</ul>
<p><strong>第3层</strong>决定使用哪些<strong>输出线路</strong>，并且把分组传递给第2层；<strong>第2层不仅在每一个信息上加上一个头信息还要加上一个尾</strong>，然后将结果传输单元送给第1层以便进行物理传输。在接收端的机器上，消息自底向上逐层传递，<strong>在传递过程中各个头被逐层剥离</strong>。没有一个第n层以下的头会被传递到第n层。</p>
<h3 id="层次设计问题Design-Issues-for-the-Layers"><a href="#层次设计问题Design-Issues-for-the-Layers" class="headerlink" title="层次设计问题Design Issues for the Layers"></a>层次设计问题Design Issues for the Layers</h3><ul>
<li>可靠性Reliability</li>
<li>网络发展Network evolution：可拓展性，网络互通性</li>
<li>资源分配Resource allocation：统计复用，流量控制</li>
<li>QoS（服务质量）：quality of service，包括的指标有 带宽bandwidth、延迟delay&#x2F;latency、抖动（Jitter）</li>
<li>安全Security</li>
</ul>
<h3 id="面向连接的服务和无连接的服务"><a href="#面向连接的服务和无连接的服务" class="headerlink" title="面向连接的服务和无连接的服务"></a>面向连接的服务和无连接的服务</h3><ul>
<li>面向连接Connection-oriented: telephone system，需要建立连接</li>
<li>无连接Connection-less: postal system，不需要事先建立连接</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/79af3961-0095-4781-b7a7-31ed1b3022a9-16175743.jpg" alt="Six different types of service"><br><img src="https://api2.mubu.com/v3/document_image/848bcef7-4baa-40fb-a356-7d14ac0f211e-16175743.jpg" alt="Six different types of service"></p>
<p><mark>Point：有链接的服务<strong>不一定</strong>是可靠的！</mark></p>
<h3 id="服务原语Service-Primitives"><a href="#服务原语Service-Primitives" class="headerlink" title="服务原语Service Primitives"></a>服务原语Service Primitives</h3><ul>
<li>原语可能看起来像函数调用中的函数名字</li>
<li>PDU: Protocol Data Unit协议数据单元：信息在对等体之间交换</li>
</ul>
<h3 id="服务与协议之间的关系"><a href="#服务与协议之间的关系" class="headerlink" title="服务与协议之间的关系"></a>服务与协议之间的关系</h3><p>服务和协议是两个截然不同的概念，它们之间的区别非常重要。</p>
<ul>
<li><p><strong><mark>服务是指</mark>某一层向它上一层提供的一-组原语(操作)。服务定义了该层准备代表其用户执行哪些操作，但是它并不涉及如何实现这些操作。</strong> 服务与两层之间的接口有关，<strong>低层是服务提供者，而上层是服务用户</strong>。</p>
</li>
<li><p>与此不同的是，**<mark>协议是</mark>一组规则，规定了同一层上对等实体之间所交换的数据包或者报文的格式和含义<strong>。对等实体利用协议来实现它们的服务定义，它们可以自由地改变协议，只要不改变呈现给它们用户的服务即可。按照这种方式，</strong>服务和协议是完全相分离的**，这是任何一个网络设计者应该很好理解的关键概念。</p>
</li>
<li><p>不改变服务，可以随意改变协议。</p>
</li>
</ul>
<h2 id="1-4-参考模型Reference-Models"><a href="#1-4-参考模型Reference-Models" class="headerlink" title="1.4 参考模型Reference Models"></a>1.4 参考模型Reference Models</h2><h3 id="OSI参考模型-The-OSI-Reference-Model"><a href="#OSI参考模型-The-OSI-Reference-Model" class="headerlink" title="OSI参考模型 The OSI Reference Model"></a>OSI参考模型 The OSI Reference Model</h3><ul>
<li>OSI体系结构是要求记住的，因为计算机网络的核心是计算机体系结构。但是OSI结构在日常生活中也不咋见到，用的人少。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/ba8267b6-e3d1-404d-a27e-4811a15b006f-16175743.jpg" alt="OSI体系结构"></p>
<p>对应的中文对照：<br><img src="https://api2.mubu.com/v3/document_image/89804771-1c92-46b4-b0eb-a65599fe34c4-16175743.jpg" alt="OSI体系结构-zh"></p>
<p>一般的，在网络里的路由设备只需要完成1，2，3层的协议就可以(如框框里圈起来的part)</p>
<ol>
<li>物理层：使用通信的信道传输原始的bit流</li>
</ol>
<ul>
<li>使用多少伏特表示1，多少伏特表示0</li>
<li>每个比特持续多长时间</li>
<li>传输是否能够双向同时(simultaneously)发送信息</li>
<li>初始链接是如何链接以及如何释放的，比如打电话，挂断，一般链接是按时间计费的</li>
</ul>
<ol start="2">
<li><p>数据链路层：把原始的传输转化成逻辑的信道。一句话总结，就是(可靠的)数据帧的传输 <mark><strong>Point To Point点到点</strong></mark></p>
<ul>
<li>将到达的数据变成一块一块的frame(帧）(这个功能仅部分的数据链路层拥有)</li>
<li>如果要求可靠的传输，要对正确的数据帧发送comfirm</li>
<li>流量控制：保持快速传输，防止数据传输缓慢</li>
<li>广播网络：管理共享信道的使用权力(access)</li>
</ul>
</li>
<li><p>网络层：主要控制的是路由和转发的问题，控制子网的运行</p>
<ul>
<li>传递forwarding</li>
<li>路由router：静态路由；规划路由；<strong>动态路由highly dynamic</strong>；</li>
<li>拥塞控制congestion</li>
<li>QoS：delay延迟，transit time传输时间，jitter抖动, 带宽，丢包率etc.</li>
<li>异构网络互联Heterogeneous networks interconnection</li>
<li>广播网络 routing is simple</li>
</ul>
</li>
<li><p>传输层：<mark>End To End端到端</mark></p>
<ul>
<li>从上层接受数据，把这些数据分成小的数据单元(if needed)，把这些数据单元</li>
<li>决定向会话层提供何种服务</li>
<li>控制拥塞</li>
</ul>
</li>
<li><p>会话层：通信的双方(虚拟层面的不同机器)建立会话链接</p>
<ul>
<li>对话控制</li>
<li>令牌Token管理</li>
<li>同步：断点重传</li>
</ul>
</li>
<li><p>表示层：信息传递的 <em>语法和语义</em></p>
<ul>
<li>抽象定义被传输的信息。比如大端小端。</li>
</ul>
</li>
<li><p>应用层：包括通常被用户使用的各种协议</p>
</li>
</ol>
<h3 id="TCP-x2F-IP参考模型-The-TCP-x2F-IP-Reference-Model"><a href="#TCP-x2F-IP参考模型-The-TCP-x2F-IP-Reference-Model" class="headerlink" title="TCP&#x2F;IP参考模型 The TCP&#x2F;IP Reference Model"></a>TCP&#x2F;IP参考模型 The TCP&#x2F;IP Reference Model</h3><p>TCP&#x2F;IP参考模型：<strong>右侧</strong><br><img src="https://api2.mubu.com/v3/document_image/1823c7c6-b736-4899-8148-728753f9aeaa-16175743.jpg" alt="TCP/IP参考模型"></p>
<ul>
<li><p>网络接口层(PPT)，中文书上叫链路层，这不是一个真正意义上的层，而是主机与传输路线之间的一个接口。</p>
</li>
<li><p>互联网层：一个基于无连接互联网络的数据包交换网络</p>
<ul>
<li>定义了一种官方的数据包和协议格式，叫做IP(Internet Protocol)</li>
<li>网络层的工作是把IP数据包发送到他们应该去往的地方，这里面又包括了路由问题，避免拥塞问题</li>
</ul>
</li>
<li><p>传输层：</p>
<ol>
<li><p><strong>传输控制协议TCP (Transmission Control Protocol)</strong></p>
<ul>
<li>面向连接的、可靠的、字节流</li>
<li>碎片化fragment字节流</li>
<li>重新组装接收到的信息到输出流(保证了传输顺序)</li>
<li>流量控制，避免淹没</li>
</ul>
</li>
<li><p><strong>用户数据报协议: The UDP(User Datagram Protocol)</strong></p>
<ul>
<li>无连接的、不可靠的、消息流(一块一块的发送消息)</li>
<li>适用于不想要TCP有序控制和流量控制，而宁可自己提供这些功能的应用程序。比如及时交付比准确交付更重要的应用，比如语音和视频通话</li>
</ul>
</li>
</ol>
</li>
<li><p>应用层：略<br>TCP&#x2F;IP模型以及各种需要学习的协议<br><img src="https://api2.mubu.com/v3/document_image/4eba9cfd-9f3d-4a91-9fec-d12fdf829f32-16175743.jpg" alt="一览表"><br>中文简化版：<br><img src="https://api2.mubu.com/v3/document_image/53465012-ec7b-4b4b-9891-e2637d5dbbbc-16175743.jpg" alt="中文简化版："></p>
</li>
</ul>
<h3 id="OSI参考模型与TCP-x2F-IP参考模型的比较"><a href="#OSI参考模型与TCP-x2F-IP参考模型的比较" class="headerlink" title="OSI参考模型与TCP&#x2F;IP参考模型的比较"></a>OSI参考模型与TCP&#x2F;IP参考模型的比较</h3><p>略，gzc没细讲，有兴趣让看书。</p>
<h3 id="OSI模型和协议的评判"><a href="#OSI模型和协议的评判" class="headerlink" title="OSI模型和协议的评判"></a>OSI模型和协议的评判</h3><p>gzc没讲，书上骂了一通，可以看个乐。截个图感受下。<br><img src="https://api2.mubu.com/v3/document_image/e13d23a0-3431-4a4b-8f63-d2118c9b9c80-16175743.jpg" alt="乐"></p>
<h3 id="TCP-x2F-IP参考模型的评判"><a href="#TCP-x2F-IP参考模型的评判" class="headerlink" title="TCP&#x2F;IP参考模型的评判"></a>TCP&#x2F;IP参考模型的评判</h3><p>没讲，没看</p>
<h2 id="1-5网络实例"><a href="#1-5网络实例" class="headerlink" title="1.5网络实例"></a>1.5网络实例</h2><p>没咋讲，没啥要记的东西，略</p>
<h2 id="网络标准化1-6-Network-Standardization"><a href="#网络标准化1-6-Network-Standardization" class="headerlink" title="网络标准化1.6 Network Standardization"></a>网络标准化1.6 Network Standardization</h2><h3 id="电信领域有影响力的组织"><a href="#电信领域有影响力的组织" class="headerlink" title="电信领域有影响力的组织"></a>电信领域有影响力的组织</h3><p><strong>国际电信联盟ITU (International Telecommunication Union)</strong></p>
<p>主要部门：</p>
<ul>
<li>Radio communications(ITU-R)</li>
<li>Telecommunications Standardization(ITU-T)<br>$\tiny CCITT, Comité Consultatif International Télégraphique et Téléphonique (1956-1993)$</li>
<li>Development(ITU-D)</li>
</ul>
<h3 id="国际标准有影响力的组织"><a href="#国际标准有影响力的组织" class="headerlink" title="国际标准有影响力的组织"></a>国际标准有影响力的组织</h3><ul>
<li>国际标准化组织ISO (International Standards Organization):OSI是在计算机网络里的一个例子</li>
<li>ANSI (American National Standards Institute)</li>
<li>IEEE (Institute of Electrical and Electronics Engineers)<br><img src="https://api2.mubu.com/v3/document_image/8f845344-a835-4a69-8c8f-7cb3557ed8cf-16175743.jpg"><br>TCP&#x2F;IP是属于IETF的</li>
</ul>
<h3 id="计算机网络中的单位换算"><a href="#计算机网络中的单位换算" class="headerlink" title="计算机网络中的单位换算"></a>计算机网络中的单位换算</h3><p>不同于计算内存的KB,MB,GB(2的幂次)，因为内存总是2的幂次。</p>
<p>此外，这种情况下用大写的B表示Byte字节，而小写的b表示bit比特。</p>
<p><img src="https://api2.mubu.com/v3/document_image/50180420-6d48-47d4-ae7c-9647d65a4d18-16175743.jpg" alt="单位"></p>
<p>由于$milli和micro$都以字母m开头，所以两者必须进行区分。通常情况下，$m$ 代表毫(milli),而$μ$ (希腊字母)代表微(micro)。</p>
<p>在本书中，为了避免二义性，我们将使用符号KB、MB、GB和TB分别代表$2^{10}、2^{20}、2^{30}$ 和 $2^{40}$ 字节;用符号 $kbps、Mbps、Gbps$ 和 $Tbps$分别代表$10^3,10^6,10^9和10^{12}$位&#x2F;秒。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记_chapter1</title>
    <url>/2022/03/02/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_chapter1/</url>
    <content><![CDATA[<p>纯纯进行一个课件的CTRL+C、CTRL+V，根本不知道是什么意思，哭。</p>
<h2 id="第1章-计算机概述"><a href="#第1章-计算机概述" class="headerlink" title="第1章  计算机概述"></a>第1章  计算机概述</h2><h3 id="计算机的分类和应用"><a href="#计算机的分类和应用" class="headerlink" title="计算机的分类和应用"></a>计算机的分类和应用</h3><p>通用计算机分类<br><img src="https://api2.mubu.com/v3/document_image/bb50f260-a398-4bd2-9a97-d6af00a88dff-16175743.jpg" alt="通用计算机分类"></p>
<p>面向应用的分类</p>
<ol>
<li>通用计算机</li>
<li>专用计算机&#x2F;嵌入式计算机(Embedded)</li>
</ol>
<p>计算机的应用<br>略</p>
<h3 id="计算机发展简史"><a href="#计算机发展简史" class="headerlink" title="计算机发展简史"></a>计算机发展简史</h3><h4 id="计算机的演进"><a href="#计算机的演进" class="headerlink" title="计算机的演进"></a>计算机的演进</h4><ol>
<li>第0代 机械时代（BC-1940</li>
<li>第1代 电子管时代（1943-1959）</li>
<li>第2代 晶体管时代（1960-1968）</li>
<li>第4代 超大规模集成电路时代（1978－现在）</li>
<li>第5代 量子计算机、光计算机、生物计算机？</li>
</ol>
<p>世界上第一台计算机：ENIAC</p>
<p>摩尔定律：集成电路芯片中晶体<br>管数量大体上每2年翻一番</p>
<h4 id="计算机的性能指标-易考"><a href="#计算机的性能指标-易考" class="headerlink" title="计算机的性能指标(易考)"></a><mark>计算机的性能指标</mark>(易考)</h4><p><img src="https://api2.mubu.com/v3/document_image/7ec2da4e-3831-44cd-b68a-6509f0314ac3-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/099dd094-3f03-436f-afde-e0e84afb42d6-16175743.jpg"></p>
<ol>
<li>响应时间</li>
<li>利用率</li>
<li>处理机字长</li>
<li>总线宽度</li>
<li>吞吐量：通常用KB、MB、GB(gigabit吉比特)和TB表示。B表示Byte(字节)，b表示bit。 $K\equiv2^{10},M\equiv2^{20},G\equiv2^{30}$</li>
<li>存储器带宽：一般用字节数&#x2F;秒表示</li>
<li>主频&#x2F;时钟周期:CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率f称为CPU的主频。<mark>度量单位是MHz（$10^6$）、GHz($10^9$)。</mark>可以理解为每秒有几个CPU时钟周期。<br>主频的倒数称为CPU时钟周期T，T&#x3D;1&#x2F;f，度量单位是微秒，纳秒。</li>
<li>CPU执行时间:表示CPU执行一段程序所占用的CPU时间，也可以用指令数目x每条指令的平均执行时间。而每条指令的平均执行时间可以用每条指令所需的平均时钟周期数目x时钟周期时间。<br> <mark>$\tiny CPU执行时间&#x3D;程序的指令数\times CPI\times CPU时钟周期时间$</mark></li>
<li><strong>CPI（Clock Cycles Per Instruction）</strong>:表示每条指令执行所需要的时钟周期数，或执行一条指令所需的平均时钟周期数。<br><mark>$\tiny CPI&#x3D;程序执行所需的CPU时钟周期总数÷程序的指令总数$</mark></li>
<li>MIPS：每秒百万指令数。<u>M:百万million ($\tiny\underline{10^6}$) ，I:instruction指令，PS:per second每秒</u><br><mark>$\tiny MIPS&#x3D;（指令总数 \div 程序执行时间）\times 10^{-6}$</mark></li>
<li>MFLOPS：每秒百万次浮点操作次数。<u>FLO：浮点操作</u><br>   <mark>$\tiny MFLOPS&#x3D;（程序中的浮点运算次数\div程序执行时间)\times 10^{-6}$</mark></li>
<li>TFLOPS：每秒万亿浮点操作次数。T:trillion兆，也就是万亿，$10^{12}$<br><mark>$\tiny TFLOPS&#x3D;（程序中的浮点运算次数\div程序执行时间)\times 10^{-12}$</mark></li>
<li>例题<br><img src="https://api2.mubu.com/v3/document_image/5e55985c-21a8-465c-bb80-b572227826a7-16175743.jpg" alt="例题"><br>题解<img src="https://api2.mubu.com/v3/document_image/1646144690025ebba.jpg" alt="tijie"><br><img src="https://api2.mubu.com/v3/document_image/304a5e77-8917-4021-8b27-adb2d0e25941-16175743.jpg"></li>
</ol>
<h3 id="计算机的硬件"><a href="#计算机的硬件" class="headerlink" title="计算机的硬件"></a>计算机的硬件</h3><h4 id="计算机的组成-五大部分"><a href="#计算机的组成-五大部分" class="headerlink" title="计算机的组成(五大部分)"></a>计算机的组成(五大部分)</h4><ol>
<li>存储器</li>
<li>运算器</li>
<li>控制器</li>
<li>输入输出设备</li>
</ol>
<ul>
<li>计算机内部，指令和数据均以二进制的形式存储，其中，指令包括操作码和地址码（对谁进行该操作）</li>
<li>关于rax,eax,ax,al:AL是低八位，AX是本名，16位，EAX是extended即扩展的意思，32bits，而RAX则是re-extended，再拓展，64位</li>
</ul>
<h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h3><p><img src="https://api2.mubu.com/v3/document_image/a3c75fab-9dd4-41bb-9fa5-53a7d99b2edf-16175743.jpg" alt="层次结构2"></p>
<p><img src="https://api2.mubu.com/v3/document_image/714d08ad-abe7-4606-8270-1b2566e12ba7-16175743.jpg" alt="层次结构3"></p>
<p>软件与硬件的逻辑等价性,理论上讲，任何软件算法都可以用硬件实现，反之亦然。<br><img src="https://api2.mubu.com/v3/document_image/9bbf4121-a5d0-441c-af82-a56e3781eb3a-16175743.jpg" alt="软件与硬件的逻辑等价性"></p>
<h2 id="第2章-运算方法和运算器I"><a href="#第2章-运算方法和运算器I" class="headerlink" title="第2章 运算方法和运算器I"></a>第2章 运算方法和运算器I</h2><h3 id="数据与文字的表示方法"><a href="#数据与文字的表示方法" class="headerlink" title="数据与文字的表示方法"></a>数据与文字的表示方法</h3><h4 id="常用的数据表示格式"><a href="#常用的数据表示格式" class="headerlink" title="常用的数据表示格式"></a>常用的数据表示格式</h4><ol>
<li>定点表示：小数点的位置是固定的，可以表示纯小数或者纯整数</li>
<li>浮点表示：见CSAPP</li>
<li>十进制数格式：</li>
</ol>
<p>带有符号表示的二进制数：<mark>真值</mark><br>机器中把符号“数字化”的数：<mark>机器数</mark>或者<mark>机器码</mark></p>
<p>常用的机器码包括：(一般针对有符号数)</p>
<ul>
<li>原码：真值的符号位变成0&#x2F;1，0为+。</li>
<li>反码:反码就是二进制数<mark>除符号位以外</mark>的的各位数码</mark>0变为1，1变为0</mark></li>
<li>补码</li>
<li>移码</li>
</ul>
<p>补码整数表示略，记住按位取反再加一就可以<br>补码的定点小数表示如下：<br><img src="https://api2.mubu.com/v3/document_image/535cd946-0888-4aa0-98f7-2b4c95267e57-16175743.jpg" alt="定点小数表示"><br>这里注意，two’s complement是补码的英文，直译为2的补足部分，这里的模的意思和时钟的模为12相同，意为正数负数的补码表示相加就是模值。</p>
<p>反码和补码的关系：定点小数也满足整数的“按位取反再加一”的规则。<br><img src="https://api2.mubu.com/v3/document_image/82299582-3a0e-4d14-92cf-7d23426ff4ad-16175743.jpg" alt="关系"><br>特别的，+0的反码为：00000000(8位)<br>-0的反码为：11111111(8位)</p>
<p>关于移位运算，这是C语言中的<br><a href="https://blog.csdn.net/heiniaoyuyouling/article/details/4696586">C语言中的位移位运算</a></p>
<h2 id="补充：课程概要"><a href="#补充：课程概要" class="headerlink" title="补充：课程概要"></a>补充：课程概要</h2><p><img src="https://api2.mubu.com/v3/document_image/5b9257b0-af72-46f3-9bf1-c75e55e111da-16175743.jpg" alt="课程要求嘿嘿嘿"></p>
<p>课程内容，左边是期中前学的，右边是期中后学的。</p>
<p><img src="https://api2.mubu.com/v3/document_image/d40960c4-d339-42d5-9d88-6b1c4d2cd975-16175743.jpg" alt="课程内容哈哈哈"></p>
<p>实验内容<br><img src="https://api2.mubu.com/v3/document_image/02f22f78-2b45-4c0e-8823-06862639af5d-16175743.jpg" alt="实验内容"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记-数据链路层1</title>
    <url>/2022/03/30/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0_%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%821/</url>
    <content><![CDATA[<p>开头👴先抄一个gzc的思维导图：<br><img src="https://api2.mubu.com/v3/document_image/f9fae159-374d-41e5-99cf-6bee7b25ccc9-16175743.jpg" alt="思维导图"></p>
<h2 id="3-1数据链路层的设计问题"><a href="#3-1数据链路层的设计问题" class="headerlink" title="3.1数据链路层的设计问题"></a>3.1数据链路层的设计问题</h2><h3 id="3-1-1提供给网络层的服务"><a href="#3-1-1提供给网络层的服务" class="headerlink" title="3.1.1提供给网络层的服务"></a>3.1.1提供给网络层的服务</h3><ol>
<li><p>数据链路层的功能</p>
<ol>
<li>向网络层提供一个定义良好的服务接口。</li>
<li>处理传输错误。</li>
<li>调节数据流,确保慢速的接收方不会被快速的发送方淹没。</li>
</ol>
</li>
<li><p>提供给网络层的服务</p>
<ol>
<li><p>Unacknowledged connectionless service.<br> Most LANs局域网 use unacknowledged connectionless service </p>
</li>
<li><p>Acknowledged connectionless无连接的，也就是不用事先建立通路 service.<br>  This service is useful over unreliable channels, such as wireless  systems。给一个ACK，有确认的服务</p>
</li>
<li><p>Acknowledged connection-oriented service</p>
<pre><code>- Connection establishment
- Timer
- Sequence number 若ACKnumber丢了，防止重复
</code></pre>
</li>
</ol>
</li>
</ol>
<p>当使用面向连接的服务时，数据传输必须经过三个不同的阶段。在第一个阶段,要建立连接，双方初始化各种变量和计数器，这些变量和计数器记录了哪些帧已经接收到，哪些帧还没有收到。在第二个阶段，才真正传输一个或者多个数据帧。在第三个也是最后一个阶段中，连接被释放，所有的变量、缓冲区以及其他用于维护该连接的资源也随之被释放。</p>
<h3 id="3-1-2成帧Framing"><a href="#3-1-2成帧Framing" class="headerlink" title="3.1.2成帧Framing"></a>3.1.2成帧Framing</h3><h4 id="字符计数"><a href="#字符计数" class="headerlink" title="字符计数"></a>字符计数</h4><p><img src="https://api2.mubu.com/v3/document_image/8ed3423d-ef66-42da-aea0-416c2fee6873-16175743.jpg" alt="字符计数"><br>一旦出错：运气不好的话所有的帧都不能正确识别</p>
<h4 id="字符填充法（byte-stuffing）"><a href="#字符填充法（byte-stuffing）" class="headerlink" title="字符填充法（byte stuffing）"></a>字符填充法（byte stuffing）</h4><p><img src="https://api2.mubu.com/v3/document_image/9d9674ff-e6e8-46a2-ae6c-1851829cbd44-16175743.jpg" alt="字符填充法"></p>
<p>帧标志出错了：每两个帧之间至少有一个帧标志，仅影响当前帧。<br>问题：发送的信息含有很多控制字符，需要转译的字符大大增加<br><strong>开销：overhead</strong>，跟需要发送的数据相比，额外添加的转义字符所占的比例，比如全是需要转译的字符的信息，overhead就是100%。</p>
<h4 id="比特填充（bit-stuffing）"><a href="#比特填充（bit-stuffing）" class="headerlink" title="比特填充（bit stuffing）"></a>比特填充（bit stuffing）</h4><p>每个帧的开头结尾都是一个special bit pattern, 01111110 ，也就是16进制的7EH，当数据内容出现连续的1时，每遇到五个1添加一个0（硬件不管这5个1后面是0还是1），接收方做相反的工作。另外在<br><img src="https://api2.mubu.com/v3/document_image/c7e3cce3-443d-4224-b633-bc6f9cefff4b-16175743.jpg" alt="bit stuffing"><br>(a) The original data.<br>(b) The data as they appear on the line.<br>(c) The data as they are stored in receiver’s memory after destuffing.<br>就是每隔五个1插入一个0</p>
<h4 id="物理层编码违例"><a href="#物理层编码违例" class="headerlink" title="物理层编码违例"></a>物理层编码违例</h4><p>Physical layer coding violation （n. 违反, 冒犯, 侵害）<br>对于曼彻斯特Manchester编码，两个跳变表示一个bit，所以当出现长高电平，常低电平，就属于物理层违例了，可以作为帧的边界。</p>
<h3 id="3-1-3差错控制（ERROR-control）"><a href="#3-1-3差错控制（ERROR-control）" class="headerlink" title="3.1.3差错控制（ERROR control）"></a>3.1.3差错控制（ERROR control）</h3><p>可靠的传输：不能少，不能多，顺序不能错</p>
<h3 id="3-1-4流量控制"><a href="#3-1-4流量控制" class="headerlink" title="3.1.4流量控制"></a>3.1.4流量控制</h3><h4 id="两种流量控制"><a href="#两种流量控制" class="headerlink" title="两种流量控制"></a>两种流量控制</h4><ol>
<li>基于反馈信息的流量控制 feedback</li>
<li>基于速率的流量控制（主要是网络层，一种内嵌的机制，浅显的理解是限制速率）rate-based</li>
</ol>
<h4 id="流量控制协议"><a href="#流量控制协议" class="headerlink" title="流量控制协议"></a>流量控制协议</h4><ol>
<li>停等 Stop Aan Wait</li>
<li>滑动窗口 Sliding Window</li>
</ol>
<h2 id="3-2差错检验和纠正"><a href="#3-2差错检验和纠正" class="headerlink" title="3.2差错检验和纠正"></a>3.2差错检验和纠正</h2><ol>
<li><p>错误分类</p>
<ul>
<li>lost frames：一个数据帧完全没能传过去，常常是因为噪音或者掉队</li>
<li>damaged frames：一些bit错了</li>
</ul>
</li>
<li><p>差错检测</p>
<ol>
<li>奇偶校验码(parity):检测单比特错误</li>
<li>Cyclic Redundancy Check:CRC</li>
<li>Atuomatic Repeat reQuest:ARQ</li>
</ol>
</li>
<li><p>差错纠正</p>
<ul>
<li>前向纠错（forward error correction）FEC</li>
</ul>
</li>
</ol>
<h3 id="纠错码"><a href="#纠错码" class="headerlink" title="纠错码"></a>纠错码</h3><hr>
<blockquote>
<p>补充：海明距离Hamming<br>   两个编码异或之后为1的位数<br>   检测到d个errors，需要distance为d+1的编码<br>   纠正d个errors，需要distance为2d+1的编码<br>   这里的距离指的是码表上任意两个编码之间的hamming距离，取最小。对于已知的检错方法，要确定能够检测出几个error应该考虑最坏的情况。</p>
</blockquote>
<h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><p>一个公式：<br>$m+r+1 \le 2^r$<br>m:数据位数<br>r：所需的校验位<br>由该式可以解出需要的最少校验位</p>
<p>海明码的构造：<br><img src="https://api2.mubu.com/v3/document_image/164890187785875d5.jpg" alt="海明码"><br><font size=1>为什么这个人字这么难看啊吐…大概是自己也知道不会再看第二遍了吧…（orz）</font></p>
<p>海明码的作用：<br>可以校验一位差错，并纠正。<br>假如第5位发生了错误，那么第1和4位的校验位会出错，计算1+4可得第5位出错，取反即可纠正。而如果是校验位发生了错误，那么只有那一个校验位错了，就可以知道是校验位出错了。（所有这些都是建立在仅仅发生一个bit的错误上的）<br><img src="https://api2.mubu.com/v3/document_image/1158e3b6-3b70-4032-ae21-3c36c36602e7-16175743.jpg" alt="示例"></p>
<p>如果发生了多位差错呢？<br>correct burst errors：<br>这里👴没懂具体咋搞的，回头机缘巧合懂了再来补文字解释（🕊🕊🕊咕咕咕）<br><img src="https://api2.mubu.com/v3/document_image/c126bef4-a95d-473b-bcbe-27208a333a10-16175743.jpg" alt="correct burst errors："></p>
<p>其他的一些纠错码：<br>卷积码（convolutional code）<br>里德所罗门码（Reed-Solomon code）<br>低密度奇偶校验码（Low-Density Parity Check codes）</p>
<h3 id="检错码"><a href="#检错码" class="headerlink" title="检错码"></a>检错码</h3><p>关于用检错码划算还是用纠错码划算的问题：<br>gzc给了一个Example<br> (<strong>single-bit error</strong>)</p>
<ul>
<li>比特错误率 BER&#x3D;10-6, 1Block&#x3D;1000bits, Data&#x3D;1M bits，也就是说传1M（$10^6$）的数据，每1000bits分一个块块er，然后一共有1000个块块er。</li>
<li>The overhead（开销）<ul>
<li>检错码Error detection + retransmission: 2001 bits （1000+1001）多的那个1是重传的时候的奇偶校验位啦（</li>
<li>纠错码Hamming code : 10,000 bits(1000块*10位校验位)</li>
</ul>
</li>
</ul>
<p>一道👴不理解的题<br>Suppose that data are transmitted in blocks of sizes 1000 bits. What is the maximum error rate under which error detection and retransmission mechanism (1 parity bit per block) is better than using Hamming code? Assume that bit errors are independent of one another and no bit error occurs during retransmission.<br><a href="https://api2.mubu.com/v3/document_image/5bbff850-5b07-4bc4-b927-def84152dbb8-16175743.jpg"></a></p>
<h4 id="奇偶校验码Parity"><a href="#奇偶校验码Parity" class="headerlink" title="奇偶校验码Parity"></a>奇偶校验码Parity</h4><p>略</p>
<h4 id="校验和Checksums"><a href="#校验和Checksums" class="headerlink" title="校验和Checksums"></a>校验和Checksums</h4><p>gzc说从网上抄了段代码给👴们👀👀</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Word <span class="title">Cksum</span><span class="params">(Word *Buf, Word Num_Words)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    Dword Sum;</span><br><span class="line">  	    <span class="keyword">for</span>  ( Sum=<span class="number">0</span>; Num_Words&gt;<span class="number">0</span>;  Num_Words--)</span><br><span class="line">	         Sum+=*Buf++;</span><br><span class="line">	    Sum = ( Sum &gt;&gt; <span class="number">16</span> ) + ( Sum &amp; <span class="number">0xffff</span> ); </span><br><span class="line">	    Sum += Sum &gt;&gt; <span class="number">16</span>;</span><br><span class="line">	    <span class="keyword">return</span> ~Sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="CRC循环冗余校验"><a href="#CRC循环冗余校验" class="headerlink" title="CRC循环冗余校验"></a><mark>CRC循环冗余校验</mark></h4><p><font size=1>这玩意儿是个重点</font><br>名字：Ploynomial code多项式编码，也就是CRC<br>计算CRC：<br>Frame:要传输的数据帧<br>Generator:生成多项式，可以和二进制串一一对应，（一般第一位是1）如$x^4+x+1$对应串10011，<strong>最高幂次r&#x3D;4，对应r+1&#x3D;5位二进制串</strong>，从低位开始写不容易出错。<br>在计算过程中的法则是模2加法，也就是异或运算，在该运算中，加减等价。<br>计算过程：</p>
<ol>
<li>把Frame左移r位，也就是$\times2^r$</li>
<li>用（1）得到是数模二除Generator（注意这个过程所有的加和减也都是异或运算）</li>
<li>除到（1）得到的数的最后一位得到余数，用（1）中数-余数，但是这里也是模二减，相当于异或“+”，且不产生进位er。</li>
<li>如果最终得到的余数不是刚好r位:就直接当数加上去的，详见例2.</li>
<li>然后算完之后就看gcz说的power，👴就发现，加上余数之后恰好整除Generator</li>
</ol>
<p>一个例子1：<br><img src="https://api2.mubu.com/v3/document_image/66a3abff-51ac-47b2-bdf7-145961822f15-16175743.jpg" alt="例子"><br>例子2：<br><img src="https://api2.mubu.com/v3/document_image/08fdf2e9-eb53-46b8-8baf-2fd57268ceb0-16175743.jpg" alt="例子2"></p>
<p>the power of CRC</p>
<ul>
<li>若不出现差错：收到T(X)</li>
<li>若出现了一些差错：收到E(X)，由于模二加法，0-&gt;1和1-&gt;0都可以用“+”表示</li>
<li>计算[T(X)+E(X)]&#x2F;G(X) &#x3D; E(X)&#x2F;G(X)，所以在E(X)&#x2F;G(X)&#x3D;&#x3D;0的时候，差错不能被检查出来</li>
<li>由此推论：<ol>
<li>添加了r bit的冗余信息的码，一定能检测出$\le r$bit的差错，因为rbit冗余信息意味着最高幂次为r，也就是说G(X)有r+1位。</li>
<li>若让（x+1）是G(X)的一个因子（factor），则所有的奇数位都可以检测出来，<font size=1>这玩意儿可以证，但根据速通理论的高质高效原则，👴忍住了，没去看怎么证。</font></li>
<li>若触发差错的bits长度为（r+1），则检测不出来的概率为$\cfrac{1}{2^{r-1}}$，因为出错长度为r+1个bit,则第一个和最后一个一定是错了也就是E(X)的第一位和最后一位都是1，而剩下的中间r-1位不知道是0（没错）还是1（错了）。</li>
<li>而若触发差错的bits长度更长的时候，触发差错的可能就是$\cfrac{1}{2^r}$</li>
</ol>
</li>
</ul>
<p>生成多项式：</p>
<blockquote>
<ul>
<li>CRC-16<br>$x^{16}+x^{15}+x^2+1$</li>
<li>CRC-CCITT  (HDLC)<br>$x^{16}+x^{12}+x^5+1$</li>
<li>CRC-32 (IEEE802)<br>$x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x^{1}+1$</li>
</ul>
</blockquote>
<h2 id="3-3基本-elementary-数据链路层协议"><a href="#3-3基本-elementary-数据链路层协议" class="headerlink" title="3.3基本(elementary)数据链路层协议"></a>3.3基本(elementary)数据链路层协议</h2><p>几种单工协议：<br>An Unrestricted Simplex Protocol <strong>乌托邦</strong>，Unrestricted没有限制的<br>A Simplex Stop-and-Wait Protocol <strong>停等协议</strong><br>A Simplex Protocol for a Noisy Channel <strong>噪音</strong></p>
<h3 id="Protocol-1-乌托邦Utopia"><a href="#Protocol-1-乌托邦Utopia" class="headerlink" title="Protocol 1: 乌托邦Utopia"></a>Protocol 1: 乌托邦Utopia</h3><p>无差错的channel，完美的接收者，源源不断的发送<br><img src="https://api2.mubu.com/v3/document_image/f2466881-7f1b-498d-b4d2-da1a258399da-16175743.jpg" alt="utopia"></p>
<h3 id="Protocol-2-停等协议"><a href="#Protocol-2-停等协议" class="headerlink" title="Protocol 2:停等协议"></a>Protocol 2:停等协议</h3><p><strong>Stop-and-Wait Protocol for a Error-free Channel</strong><br>考虑flow control，仍然是完美的信道<br><img src="https://api2.mubu.com/v3/document_image/631de808-d162-41ae-a8d0-d198cddf5c7a-16175743.jpg" alt="flow control"><br>↑对于短距离的通信完全是没有问题的，效率很高，远距离就不行了</p>
<h3 id="Protocol-3-有噪音的"><a href="#Protocol-3-有噪音的" class="headerlink" title="Protocol 3:有噪音的"></a>Protocol 3:有噪音的</h3><p><strong>A Simplex Protocol for a Noisy Channel</strong><br><img src="https://api2.mubu.com/v3/document_image/b7928813-66a6-4f48-8c86-023db3689df9-16175743.jpg" alt="Noisy"><br>ACK:<strong>ack</strong>nowledgement character命令正确应答<br>NAK：<strong>n</strong>agative a<strong>ck</strong>nowladge否定应答<br>前3种情况都没有问题，但是第4种，ACK丢了，就可能导致重复发送，这就引入了序列号的使用。<br>此外，一个晚到的ACK也可能导致发送重复的数据</p>
<h4 id="Sequence-Number"><a href="#Sequence-Number" class="headerlink" title="Sequence Number"></a>Sequence Number</h4><p>对于数据链路层的<strong>停等协议，一个bit（0&#x2F;1）就足够了</strong>，可以做到判断是新的还是旧的帧<br>对于传输层，1bit就不够了，需要较大的编号空间使得在编号回卷时，保证同编号的旧帧不可能被缓冲在网络中，如：TFTP<br>protocol3：</p>
<ul>
<li>sender 伪代码<br>课本上的代码见<a href="https://api2.mubu.com/v3/document_image/bb4f22d1-ddb4-42de-b363-789775f057f3-16175743.jpg">这里</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">从网络层获取一个分组放入buffer</span><br><span class="line">发送buffer中的数据，新启动定时器</span><br><span class="line">label1:</span><br><span class="line"><span class="built_in">wait_for_event</span>()</span><br><span class="line"><span class="keyword">switch</span> (event) &#123;</span><br><span class="line"><span class="keyword">case</span> 收到了坏帧(校验和错):</span><br><span class="line">     重发缓冲在buffer里的数据，重新启动定时器</span><br><span class="line">     <span class="comment">//这里的&quot;重新&quot;和&quot;新&quot;都是指从头开始启动计时器</span></span><br><span class="line"><span class="keyword">case</span> 定时器超时：</span><br><span class="line">     重发缓冲在buffer里的数据，新启动定时器</span><br><span class="line"><span class="keyword">case</span> 收到校验和正确的帧：</span><br><span class="line">     <span class="keyword">if</span>（ack序号正确） &#123;</span><br><span class="line">        关闭旧定时器</span><br><span class="line">        从网络层获取下一个分组放入buffer</span><br><span class="line">        发送buffer中的数据，新启动定时器</span><br><span class="line">     &#125; <span class="keyword">else</span> </span><br><span class="line">         重发缓冲在buffer里的数据，重新启动定时器</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> label1</span><br></pre></td></tr></table></figure>

<p>简化版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">从网络层获取一个分组放入<span class="function">buffer</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">   发送buffer中的数据，启动定时器</span><br><span class="line">   <span class="built_in">wait_for_event</span>()</span><br><span class="line">   <span class="keyword">if</span> (收到校验和正确的帧) &#123;</span><br><span class="line">      <span class="keyword">if</span>（ack序号正确） &#123;</span><br><span class="line">         关闭旧定时器</span><br><span class="line">         从网络层获取下一个分组放入buffer</span><br><span class="line">         &#125; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>receiver伪代码<br>课本上的代码见<a href="https://api2.mubu.com/v3/document_image/fa67061a-f013-4c8f-9c3f-9fea1dff167d-16175743.jpg">这里</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">frame_expected=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="built_in">wait_for_event</span>()</span><br><span class="line">   <span class="keyword">switch</span>(event) &#123;</span><br><span class="line">   <span class="keyword">case</span> 坏帧：</span><br><span class="line">      do_nothing</span><br><span class="line">   <span class="keyword">case</span> 收到校验和正确的数据帧:</span><br><span class="line">      <span class="keyword">if</span>（序号==frame_expected） &#123;</span><br><span class="line">         向网络层上交分组</span><br><span class="line">         回ACK（序号为frame_expected)</span><br><span class="line">         <span class="built_in">inc</span>(frame_expected)</span><br><span class="line">      &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">         回ACK（序号为frame_expected<span class="number">-1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计时器Timer"><a href="#计时器Timer" class="headerlink" title="计时器Timer"></a>计时器Timer</h4><p>gzc说计时器的间隔是个比较精细的活儿，短了可能收不到，然后每个帧都得发俩遍，间隔长了效率低。实际上设计的比较保守（因为错误实在比较少），但是自己做的实验里面就整个比较合适的值就完了（500ms差不多就完了，这世间卫星都跑到了）。<br><font size=1>👴居然听懂了</font></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>凌晨2点，👴未眠</title>
    <url>/2022/04/08/%E5%87%8C%E6%99%A82%E7%82%B9%EF%BC%8C%E7%88%B7%E6%9C%AA%E7%9C%A0/</url>
    <content><![CDATA[<p>先说说没睡的原因。<br>👴从下午开始睡大觉，十点多睡醒了，以至于到现在还是睡不着。另外的一个现在仍旧非常精神的原因是睡醒之后胃不舒服不想喝纯白开，随便搞了点咖啡让自己好受点。<br>睡醒之后看了会儿美人。<br>跟<a href="https://mushroom323.github.io/">🍄神</a>讨论了点儿计网，由于躺着脑子根本不动所以爬起来了。<br>之后听了听歌，发现<a href="https://www.axsl.site/">老板</a>亦未寝。</p>
<p>老板给👴发了关于“大和抚子”的废话。<br>👴发表了非常<del>喜爱</del>欣赏明艳大气美女子的言论。</p>
<p>👴开始看闲书（某z姓大佬推荐的好书）。</p>
<blockquote>
<p>👴：<br><img src="https://s3.bmp.ovh/imgs/2022/04/08/e949dd6f6bd556cd.png" alt="闲书"><br>老板：你可以把自己🧠，拿出来。</p>
</blockquote>
<p>👴们讨论了大脑的跳跃性思维导致我们无法控制自己的大脑去做什么这件事。<br>接着就讨论起到底有没有“真正喜欢的事情”这个话题。（相关性并不强的俩话题，或许佐证了大脑自己愿意想什么是不怎么受👴们控制的）<br>👴本来以为自己没有什么喜欢做的事情。<br>然后发现满足“因为喜欢所以可以一直做下去不产生任何反感情绪和不耐烦的事情”条件的<br>👴还是有的<br>至少在看美人这件事上👴完全满足这个条件（</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://s3.bmp.ovh/imgs/2022/04/08/887278b873c108fc.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">美人论</div>
</center>

<p>最后来点闲书的摘抄</p>
<ul>
<li><p>记得过去老师讲解《论语》中曾子说的“吾日三省吾身”，有两种解释，第一种是我每一天都自我反省三（多）次；第二种是我每一天都以下列三件事来自我反省；管他每天到底是“反省三次”，还是“列出三件事来反省”，都并不重要。<br>  <strong>重要的是，他每天都在“反省”</strong>。<br>  作为一个真正意义上的人，好像没有什么比这个更重要了。</p>
</li>
<li><p>长期来看，我们都是要死的。————约翰·梅纳德·凯恩斯</p>
</li>
<li><p>即使是在极端恶劣的环境里，人们也会拥有一种最后的自由，那就是选择自己的态度的自由。————维克托·弗兰克</p>
</li>
<li><p>最常见的误解就是，当我们觉得自己痛苦时，总是不自觉的把自己想象成全世界最痛苦的人。这是非常自然的，因为我们自己的痛苦我们亲身感受，而别人的痛苦我们又很难真正做到感同身受。</p>
</li>
<li><p>所以说，怀旧是一种错觉。甚至它更可能只不过是幻觉。有人用过这么一个比喻：如果说记忆本身是葡萄，那么回忆的过程就是发酵。</p>
</li>
<li><p>因为人生苦短，如果成功太慢那么幸福必然减半。</p>
</li>
<li><p>我个人觉得，在工作和学习上控制这种天性是最重要的。为了能在这方面控制住自己的天性，有的时候，在其他方面稍微放纵一下是非常有必要的。相信我，偶尔大醉一场没什么不好。偶尔连续打上两天两夜的牌不仅有助于身心健康，也是一种很好的社交活动。<br>  但是，在工作和学习上，坚决不要放纵。工作和学习都是艰苦的，路程都是漫长的，都不可能一蹴而就。经验告诉我们，在工作和学习的过程中当然需要技巧，但是，当场见效的技巧少之又少，而且，就算找到了，也只不过是两种情况之一：a.寻找这个技巧已经花费了太多的时间；b.这个技巧可能有后遗症，只不过是现在还不知道而已。</p>
</li>
<li><p>一个人不应该过分苛求自己————尽管同时也不应该过分放纵自己</p>
</li>
</ul>
<p>现在就快凌晨四点了。<br>川端康成在凌晨四点看海棠花未眠，<br>👴在凌晨看了看<a href="https://baike.baidu.com/item/%E6%B5%B7%E6%A3%A0%E8%8A%B1/969869">海棠花的百度百科</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>少年听雨</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记-数据链路层2</title>
    <url>/2022/04/06/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0_%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%822/</url>
    <content><![CDATA[<p>上一个太长了，再分一个</p>
<h2 id="3-4滑动窗口协议"><a href="#3-4滑动窗口协议" class="headerlink" title="3.4滑动窗口协议"></a>3.4滑动窗口协议</h2><p>英文是：<br><strong>Sliding Window</strong></p>
<h3 id="捎带应答Piggy-backing"><a href="#捎带应答Piggy-backing" class="headerlink" title="捎带应答Piggy backing"></a>捎带应答Piggy backing</h3><p><font size=1>查了一下piggy的意思是贪心的，🐷🐷风评被害</font><br>就是说俩边不停的来回发，（全双工），就可以把ACK信息放在sck field里面，跟着另一方的回复发回去。</p>
<h3 id="发送-x2F-接收窗口Sending-window-amp-Receiving-window"><a href="#发送-x2F-接收窗口Sending-window-amp-Receiving-window" class="headerlink" title="发送&#x2F;接收窗口Sending window &amp; Receiving window"></a>发送&#x2F;接收窗口Sending window &amp; Receiving window</h3><p>发送窗口维护一组序号，一个时间对应一组可以发送的序号<br>接收窗口同理，维护的是一组可以接受的信号。接收窗口大于1的时候，落在接收窗口的帧不能马上接受，需要把没按顺序到达的帧先存起来。</p>
<p>几种协议：（由简到繁，由最简单的调整参数就可以依次实现）</p>
<ul>
<li>A <strong>One-Bit</strong> Sliding Window Protocol 实际上就是停等协议</li>
<li>A Protocol Using <strong>Go Back N</strong>  GBN协议</li>
<li>A Protocol Using <strong>Selective Repeat</strong> SR协议</li>
</ul>
<h3 id="单bit的滑动窗口协议"><a href="#单bit的滑动窗口协议" class="headerlink" title="单bit的滑动窗口协议"></a>单bit的滑动窗口协议</h3><p><strong>Protocol 4</strong><br>发送窗口&#x3D;&#x3D;接收窗口<br><img src="https://api2.mubu.com/v3/document_image/88477f43-1e79-488e-8992-db2a956bad4a-16175743.jpg" alt="单bit"><br>A sliding window of size 1, with a 3-bit sequence number.<br>窗口关闭的意思是没有帧在发送<br>(a) 初始状态<br>(b) 第一个帧发送完成<br>(c) 第一个帧已经被接收<br>(d) 第一个ACK被接收</p>
<p>课本上的代码在<a href="https://api2.mubu.com/v3/document_image/9d4c339e-0bfa-4e7d-9f5e-d9b655f187a5-16175743.jpg">这里1</a>以及<a href="https://api2.mubu.com/v3/document_image/b9392d86-a6db-4331-968c-4a485dca220f-16175743.jpg">这里2</a><br><font size=1>gzc说实际工程里的发送方的序号是期望收到的序号，但是课本上不是，whatever，👴不懂</font></p>
<ul>
<li>关于line utilization（线路利用）<br>👴自己的理解大概就是<font color=blue><br>$\frac{发送端在发送消息的时间}{消息到达并收到ACK的时间}$</font><br>其中<br><font size=2 color=blue>消息到达并收到ACK的时间&#x3D;发送消息的时间+传播(propagation)延迟$\times2$</font></li>
<li>单bit滑动窗口协议的问题就在于<u>线路利用率太低了</u></li>
</ul>
<h3 id="Go-Back-N-协议"><a href="#Go-Back-N-协议" class="headerlink" title="Go Back N 协议"></a>Go Back N 协议</h3><p><strong>Protocol 5</strong><br><img src="https://api2.mubu.com/v3/document_image/70054526-d907-4673-b4b6-1088c625507a-16175743.jpg"></p>
<h3 id="SR协议Selective-Repeat-x2F-Reject"><a href="#SR协议Selective-Repeat-x2F-Reject" class="headerlink" title="SR协议Selective Repeat&#x2F;Reject"></a>SR协议Selective Repeat&#x2F;Reject</h3><p><strong>Protocol 6</strong></p>
<h4 id="关于滑动窗口的数量"><a href="#关于滑动窗口的数量" class="headerlink" title="关于滑动窗口的数量"></a>关于滑动窗口的数量</h4><p>Ws：sender window<br>Wr: reciver window<br>他们的数量关系满足以下式子：</p>
<blockquote>
<p>Ws+Wr &lt;&#x3D;2n<br> Ws&gt;&#x3D;Wr<br>可以推出：<br> Ws,Wr&lt;&#x3D; 2n -1</p>
</blockquote>
<p>课本上的代码在<a href="https://api2.mubu.com/v3/document_image/596a271d-196c-44b1-acbc-ca15be42618d-16175743.jpg">这里1</a>,<a href="https://api2.mubu.com/v3/document_image/89628c93-471f-411e-923b-7df2be7b36bc-16175743.jpg">这里2</a>,<a href="https://api2.mubu.com/v3/document_image/7a115cd0-ad06-4e6b-8d04-d797d631eeee-16175743.jpg">这里3</a>以及<a href="https://api2.mubu.com/v3/document_image/d601ad65-c489-47e6-8273-f64e9c9ba542-16175743.jpg">这里4</a></p>
<h4 id="关于line-utilization（gzc的official理解）"><a href="#关于line-utilization（gzc的official理解）" class="headerlink" title="关于line utilization（gzc的official理解）"></a>关于line utilization（gzc的official理解）</h4><p>当sender只有一个窗口时，也就是单bit的滑动窗口时，示意图如下。（分为a，b两种情况，从上往下为时间推进方向）<br><img src="https://api2.mubu.com/v3/document_image/6679fb30-043e-4701-8fef-a1b044dfd208-16175743.jpg" alt="official理解"></p>
<p>$\alpha&#x3D;\cfrac{t_p}{t_f}$ ，  $t_p$即propagation time，传输时延，$t_f$是发送时延。<br>这里的$\alpha$其实就是sender和reciver之间可以放得下几个Frame。</p>
<p>当sender有W个窗口的时候就是这么个状态<br><img src="https://api2.mubu.com/v3/document_image/9b174992-5855-4a4e-b9e7-57f4c0ea5def-16175743.jpg" alt="W个窗口"><br>常见介质中的信号传播速度<br><img src="https://api2.mubu.com/v3/document_image/750a9a07-002d-4976-aa20-024e882846e0-16175743.jpg"></p>
<blockquote>
<p>throughput:吞吐量&#x3D;利用率*带宽</p>
</blockquote>
<h2 id="3-5数据链路层协议实例"><a href="#3-5数据链路层协议实例" class="headerlink" title="3.5数据链路层协议实例"></a>3.5数据链路层协议实例</h2>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>二十岁的胡言乱语</title>
    <url>/2022/04/13/%E4%BA%8C%E5%8D%81%E5%B2%81%E7%9A%84%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/</url>
    <content><![CDATA[<p>不知道怎么开头，就从最近发生的事情写起吧。<br>前两天二十岁了，但是那个下午忙于写课设，一片焦头烂额，没有留下什么记录。<br>也或许是知道人不是随着时间长大的，跨过某个时间节点并不代表成长，所以有些漫不经心。<br>出乎意料的是还是收到了一些祝福，L姓傻儿给我发她家的猫猫，某个老年人提前好久就张罗着买鼠标，凌晨收到了一份“人类一败涂地”，经常一起玩的家伙们偶然得知之后会祝快乐，平日里联系不多但曾经很铁的朋友也会有人记得。<br>这些，就很珍贵了。<br>总会有一些瞬间觉得废物如我不配有这样的朋友，但转而又自私而小心眼地希望这样的友谊能够继续下去。</p>
<p>今天晚上没什么想做的事情（实际上该做的事情一大堆但是懒怠），看了好久美人，打开Groove放着bgm又看了会儿闲书，感觉里面讲的一些话很有意思，忍不住想记下来（这里不禁感叹Zdalao推荐的闲书确确实实是本好书啊），这也是有这篇博客的另一个原因。</p>
<p>往后的不知道什么时间翻自己的博客看到这些或许可以一笑呢：</p>
<p>关于计划：</p>
<ul>
<li>计划永远赶不上变化。平凡甚至平庸如我，必不可能像《肖申克的救赎》里安迪那样拥有一个计划然后几十年如一日的执行下去。但是尽管如此，计划仍然是必要的，我们需要考虑的是多久的计划能够让自己依靠自己并不出众的天分顺利实施呢？</li>
<li>理想固然应该是有的，但是，理想这东西往往太过遥远，乃至于我们总是看不清楚。不过还好，所谓千里之行始于足下，我们要做的事情是把每一步都走好，踩得足够踏实。至于千里之外的终点，既然看都看不到，就不用花时间去想了，想了也没用。</li>
<li>用各种方法保持乐观就好————乐观是靠努力和挣扎才可以获得的经验。</li>
<li>如果你对你的将来充满迷惑，相信我你并不孤独。然而，充满迷惑本身，并不意味着你要不知所措。</li>
<li>行动是改变自己的众多方法中最有效、最直接的方法。</li>
<li>其间也有不愿意去的时候，但是，我知道那只不过是我的大脑的想法，而不应该是我的想法——只要意识到这个，就不存在什么挣扎</li>
</ul>
<p>关于试错：</p>
<ul>
<li>很多的时候，没必要做计划的原因有两个：除了前面提到过的“大多数计划其实非常简单”之外，另外一个是“初始状态下，我们往往实际上并没有能力去制定合理有效的计划”</li>
<li>我们一生做的事，大多都是一个试错（Trial and Error）的过程，对于人生，没有人能像解释数学那样给出普适的公式。</li>
<li>第一个吃螃蟹的人”是令人敬佩的，不是勇士谁敢去吃它呢？不过鲁迅先生也说，第一个吃过螃蟹的人肯定也吃过蜘蛛，因为两者外形极为相似；只是他觉得螃蟹的味道可口而蜘蛛的味道不可口。</li>
</ul>
<p>关于立场和经验局限：</p>
<ul>
<li>即便我个人是个所谓的“没有信仰的人”，我也不会反对“信仰自由”，同时不应该、也做不到去强迫任何人放弃信仰</li>
<li>观察一下就知道，日常生活中几乎所有主要的“沟通障碍”本质上都是因为沟通双方无法让对方理解与他们的经验相悖的知识或者信息造成的。这种知识和信息的传递，不是仅仅通过“站在对方立场上考虑问题”就可以轻松而彻底解决的。尽管“站在对方立场上考虑问题”确实已经是很有用也很难以掌握的技巧，可是，当我们面对（或者说“背对”可能更准确些）“双方立场都无法考虑到的问题”的时候呢？尽管这样的时候我们甚至可能不知道问题究竟是什么，但有一点是几乎确定无疑的，这种问题不仅确实存在，还往往至关重要。</li>
</ul>
<p>关于阅读：</p>
<ul>
<li>我常常暗骂现在的本科教育，可是我知道骂了也没用，所以，骂的时候只是偶尔才愤怒。不夸张地讲，今天的本科教育很大程度上干脆就是忘了本。本科教育的根本在于培养学生的自学能力。理论上讲，本科毕业之后，学生应该有能力自学自己需要的任何科目。</li>
<li>很多人高中毕业之后就不再读任何书籍；偶尔看看报纸杂志上的短文（或者是互联网上的帖子）却也常常断章取义——他们不是故意断章取义的，他们是无法做到认真仔细地把每个字都看清楚，更不用提揣摩字里行间的逻辑关系了。</li>
<li>我们的教育，把语文和文学过分紧密联系起来，乃至于忘了文字本身最重要的意义是什么。</li>
</ul>
<p>关于时间和进展的函数关系：</p>
<p><img src="https://api2.mubu.com/v3/document_image/726b6a32-bd41-45be-995e-6d9b2c5de282-16175743.jpg" alt="111"></p>
<p>就这样。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>少年听雨</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP_命名空间</title>
    <url>/2022/04/22/CPP_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>纯纯速通一下-2，全是截图，留着忘了基础操作的时候看</p>
<p><img src="https://api2.mubu.com/v3/document_image/ede93f00-ada6-41c0-930b-f99eddb7bba8-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/d1c188d6-5b72-4b6f-8073-e5a9c51f6a90-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/e169c701-afc7-4445-b015-3319774c6982-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/a9e0498b-65e6-49b8-be39-149317a08fa1-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/9aceefe5-7399-4b4a-b253-8aebe74febf3-16175743.jpg">    </p>
<p>全局命名空间<br><img src="https://api2.mubu.com/v3/document_image/e88d9228-e936-4813-902d-32db60e057f3-16175743.jpg"></p>
<p>嵌套命名空间<br><img src="https://api2.mubu.com/v3/document_image/3107728d-9a4d-43c3-b85c-2772611f04a4-16175743.jpg"></p>
<p>无名命名空间<br><img src="https://api2.mubu.com/v3/document_image/3983c0d9-1c52-4f4c-bafa-bf7e8f244157-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/e61473b4-efc8-4bb5-976c-95b1052ec63c-16175743.jpg"></p>
<p>命名空间内名字的查找类似于作用域，先小后大</p>
<p><img src="https://api2.mubu.com/v3/document_image/ff8ca296-7ad1-4e12-b2da-0ca7c582d88f-16175743.jpg"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP_容器类和模板</title>
    <url>/2022/04/22/CPP_%E5%AE%B9%E5%99%A8%E4%B8%8E%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>纯纯速通一下-3，全是截图，留着忘了基础操作的时候看</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>为什么要有模板？<br>比如比较大小的函数，仅仅是参数类型不同，而操作一样，能不能只写一个函数？</p>
<p>模板定义<br><img src="https://api2.mubu.com/v3/document_image/63229055-16fb-4237-821a-750f793ce906-16175743.jpg"></p>
<p>模板分类<br><img src="https://api2.mubu.com/v3/document_image/8a649085-a9a2-46cd-bd88-83c418baddc2-16175743.jpg"><br>使用例子：<br><img src="https://api2.mubu.com/v3/document_image/fe2eaa0b-d5fb-4a43-97d0-3d071ed9f103-16175743.jpg"><br>例子2：<br><img src="https://api2.mubu.com/v3/document_image/5b47f3d4-9855-45f9-8b66-2b36938ff18f-16175743.jpg"></p>
<h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><p><img src="https://api2.mubu.com/v3/document_image/d5499771-36c0-4c5b-95f8-b371bab6f55a-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/d74c7e2e-0031-478a-98d2-ebc0b013356f-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/715754da-d46e-436c-9279-293b7ccdde99-16175743.jpg"></p>
<p>使用条件：<br><img src="https://api2.mubu.com/v3/document_image/04b709f7-45d7-4f50-8b0d-c0dc3a1dd478-16175743.jpg"></p>
<p>使用格式<br><img src="https://api2.mubu.com/v3/document_image/911599db-e41f-4eab-9ef7-78f7aab5f297-16175743.jpg"></p>
<p>初始化方式：<br><img src="https://api2.mubu.com/v3/document_image/77d9cb0b-d50f-4ca3-82a6-844be0582c1b-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/b6db9fe6-4faf-41aa-a7c2-a52a2aaf9029-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/0fdd07cd-813a-4190-9bee-6c6c8fb03941-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/8d434ba7-9a65-4cfc-a6ea-ae94736a8893-16175743.jpg"></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><img src="https://api2.mubu.com/v3/document_image/9b589e00-7f69-4393-932b-ec079764afa2-16175743.jpg"></p>
<p>迭代器的范围<br><img src="https://api2.mubu.com/v3/document_image/b8073103-2d90-46bb-8443-7a853d92cce8-16175743.jpg"></p>
<p>迭代器失效<br><img src="https://api2.mubu.com/v3/document_image/0d66ce77-28ab-4460-b308-469981a67987-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/7d05d222-5e5e-4873-8dbb-e253bb724e84-16175743.jpg"><br>不同标准的C++的迭代器遍历<br>！<a href="https://api2.mubu.com/v3/document_image/727574aa-ef3b-4dc9-9a47-a7d2d761f12a-16175743.jpg"></a></p>
<h3 id="顺序容器的典型操作"><a href="#顺序容器的典型操作" class="headerlink" title="顺序容器的典型操作"></a>顺序容器的典型操作</h3><p><img src="https://api2.mubu.com/v3/document_image/ac2fc968-1f95-4ed9-a99f-ef026a32d566-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/ae5b3b87-2df3-48eb-9def-aff039ea8746-16175743.jpg"></p>
<ol>
<li>vector<br><img src="https://api2.mubu.com/v3/document_image/4b87d4d4-55c1-4f3c-b1da-ba5f6a3ced25-16175743.jpg"></li>
<li>list<br>list的erase操作的参数与vector类似，这里没截到<br><img src="https://api2.mubu.com/v3/document_image/e86767e6-b274-4100-ace0-1ab0bc2922a1-16175743.jpg"></li>
<li>比较<br><img src="https://api2.mubu.com/v3/document_image/a0cbe200-e687-475f-ba2a-93183c68f2ed-16175743.jpg"></li>
</ol>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p><img src="https://api2.mubu.com/v3/document_image/515e9d9d-2735-4f1a-be29-5ac5823e5a05-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/26ab10b8-d08f-4186-b8d8-661b8b20d372-16175743.jpg"></p>
<p>map:<br><img src="https://api2.mubu.com/v3/document_image/9cfa2a79-901f-47ab-b5c3-8eba59d58bf9-16175743.jpg"></p>
<h3 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h3><p><img src="https://api2.mubu.com/v3/document_image/2cf1a1b7-abbf-457d-9e76-34b384383ad6-16175743.jpg"><br>用法<br><img src="https://api2.mubu.com/v3/document_image/cce292c3-6fa2-4edc-a90d-ed92b3a31fcb-16175743.jpg"></p>
<p>模板是泛型编程的基础</p>
<p><img src="https://api2.mubu.com/v3/document_image/8c1036c4-842f-4972-ada3-d0926aa47927-16175743.jpg"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP_对象指针和数组</title>
    <url>/2022/04/22/CPP_%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>纯纯速通一下，全是截图，留着忘了基础操作的时候看</p>
<p>对象数组<br><img src="https://api2.mubu.com/v3/document_image/31a5c70e-fae8-4056-a1bf-f4793606ceed-16175743.jpg"></p>
<p>指针<br><img src="https://api2.mubu.com/v3/document_image/832744f0-a8e1-4136-8ccd-93a8e5eed05b-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/342bb47d-6079-4e1b-b963-ac04f0ddde60-16175743.jpg"></p>
<p>对象指针<br><img src="https://api2.mubu.com/v3/document_image/11342eea-5baa-4e40-ba8a-e409b148f2c5-16175743.jpg"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>形式语言与自动机_3(part)</title>
    <url>/2022/04/17/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA_chapter3/</url>
    <content><![CDATA[<h2 id="3-9-右线性语言的性质"><a href="#3-9-右线性语言的性质" class="headerlink" title="3.9 右线性语言的性质"></a>3.9 右线性语言的性质</h2><ol>
<li><p>等价和可区分的概念<br> 设DFA  M &#x3D; (Q，T，δ，q0，F)<br> 对不同的状态q１， q２∈Q 和<mark>每个</mark>ω∈T*，<br> 如果有</p>
 <!---$(q_１,\omega)┣* (q，ε)$ 和 $(q２,\omega)┣* (q，ε)$ 且 $q\in F$ ，
 则称q１与q２状态等价. 记为 $q_１\equiv q_２$  
 否则，称 $q_１$， $q_２$ 可区分。--->
<p> <img src="https://api2.mubu.com/v3/document_image/3811e33a-5ed3-496b-a7d1-6236a065d13e-16175743.jpg"></p>
</li>
<li><p>不可达状态<br>如果不存在任何$\omega \in T^*$，使$(q_０,\omega)┣* (q,\varepsilon)$，<br>则称状态q∈Q为不可达状态。</p>
</li>
<li><p>最小化<br>若DFA Ｍ不存在互为等价状态及不可达状态，则称DFA Ｍ是最小化的。</p>
</li>
</ol>
<h2 id="最小化算法"><a href="#最小化算法" class="headerlink" title="最小化算法"></a>最小化算法</h2><p>一个DFA Ｍ的最小化，是把Ｍ的状态集Ｑ构成一个划分。即: 任何两个子集的状态都是可区分的；同一子集中的任何两个状态都是等价的。之后，每个子集用一个状态代表，并取一个状态名。<br>构成划分的步骤:<br>  构成基本划分 $\Pi$&#x3D;{$\Pi^{‘}$, $\Pi^{‘’}$}， ($\Pi^{‘}$为终态集， $\Pi^{‘’}$为非终态集)<br>  细分 $\Pi$ &#x3D;{$\Pi^1$，$\Pi^2$,….., $\Pi^n$}，　　 $\forall \Pi^i$  ∈ $\Pi$<br> 　　　 $\Pi^i &#x3D;{ q_１， q_２，…， q_ｍ}$<br>    当输入任意字符a时，若$\Pi^i$中的状态经标a的边可到达的状态集的元素分属于两个不同的子集中，则将$\Pi^i$细分为两个子集.<br>重复步骤(2)，直至不可再细分，得到Ｍ1.<br>若Ｍ1中有不可达状态，将其删除，Ｍ1便是最小化的.</p>
<p>优化步骤：<br><img src="https://api2.mubu.com/v3/document_image/bbf4f270-d234-4327-a011-da023cfb52bd-16175743.jpg"></p>
<p>一个例子：</p>
<p><img src="https://api2.mubu.com/v3/document_image/6815aa4e-3004-48c2-bc91-7665a8a27768-16175743.jpg"></p>
<p>填表法的例子：</p>
<p><img src="https://api2.mubu.com/v3/document_image/7220baf0-ae6a-4d6e-a687-5675b31cdcc5-16175743.jpg"></p>
<!---解释见[视频]()(还没上传)--->

<h2 id="针对正则语言的-Pumping-引理"><a href="#针对正则语言的-Pumping-引理" class="headerlink" title="针对正则语言的 Pumping 引理"></a>针对正则语言的 Pumping 引理</h2><p>中文是 泵浦</p>
<p>泵浦引理的性质和地位：</p>
<ul>
<li>正则语言应满足的一个<strong>必要条件</strong></li>
<li>用于<strong>判定</strong>给定的语言<strong>不是正则集</strong>。</li>
</ul>
<p>物理意义：当给定一个正则集和该集合上一个足够长的字符串时，在该字符串中能找到一个非空的子串，并使子串重复，从而组成新的字符串。该新串必在同一个正则集内。</p>
<p>定理：<br>设L是正则集，存在常数k，对字符串$ω\in Ｌ$ 且$｜ω｜≥ｋ$，<br>则ω可写成$ω_1ω_0ω_２$，其中$｜ω_1ω_0｜≤ｋ$，$｜ω_0｜＞０$，<br>对所有的ｉ≥0有$ω_1ω_0^iω_２$∈Ｌ。</p>
<p>证明：<br>运用了鸽巢原理<br>pumping特性：<br>任一长度不小于状态数目的字符串所标记的路径上，必然出现重复的状态.</p>
<p><img src="https://api2.mubu.com/v3/document_image/6bb5920c-c175-4d29-89e6-c4e8f5261102-16175743.jpg"></p>
<p>泵浦引理的应用</p>
<p><img src="https://api2.mubu.com/v3/document_image/13461ce8-7fa2-4175-ba03-0965e5837558-16175743.jpg"></p>
<p>注意：ω的取法有技巧， 一定要能推出矛盾才可以。<br>如：<br><img src="https://api2.mubu.com/v3/document_image/51cb931e-caac-4349-b905-3ce69bc8ce2c-16175743.jpg"></p>
<p>右线性语言的封闭性 (已经忘光光了草哦)</p>
<blockquote>
<p>自动机到了终态但是串没读完不算到了终态<br> 当从带空的NFA到不带空的NFA转换时，如果状态q0不能接受b，还不能下定论，应该看q0的空闭包能不能接受b</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>形式语言与自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown与希腊字母</title>
    <url>/2022/04/11/markdown%E6%8F%92%E5%85%A5%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<p>经常把希腊字母读音搞混，还不会打不会写<br>码一篇，回头需要直接查</p>
<h2 id="希腊字母读音及大小写"><a href="#希腊字母读音及大小写" class="headerlink" title="希腊字母读音及大小写"></a>希腊字母读音及大小写</h2><p><img src="https://api2.mubu.com/v3/document_image/25324d82-a291-4e66-814f-7cf896f6be81-16175743.jpg" alt="读音及大小写"><br><img src="https://api2.mubu.com/v3/document_image/74a75b17-ddaf-4e7e-bd54-497ab10803c3-16175743.jpg" alt="读音及大小写"></p>
<h2 id="希腊字母手写体"><a href="#希腊字母手写体" class="headerlink" title="希腊字母手写体"></a>希腊字母手写体</h2><p><img src="https://api2.mubu.com/v3/document_image/7c96109c-d01c-499d-aefd-8667815a2242-16175743.jpg" alt="手写体"></p>
<h2 id="markdown对照table"><a href="#markdown对照table" class="headerlink" title="markdown对照table"></a>markdown对照table</h2><p><img src="https://api2.mubu.com/v3/document_image/af6f2305-e91f-4541-a8e4-b4628b6fa968-16175743.jpg" alt="对照table"><br><img src="https://api2.mubu.com/v3/document_image/8b438b32-e596-4ab1-9841-6d33fcd2de58-16175743.jpg" alt="对照table"></p>
<hr>
<center>over</center>
]]></content>
      <categories>
        <category>else</category>
      </categories>
      <tags>
        <tag>else</tag>
      </tags>
  </entry>
  <entry>
    <title>近日的某九爷</title>
    <url>/2022/05/09/%E8%BF%91%E6%97%A5%E7%9A%84%E6%9F%90%E4%B9%9D%E7%88%B7/</url>
    <content><![CDATA[<p><strong><font color=Lavender>白天</font>不醒<font color=    DarkSlateBlue>夜里</font>不睡</strong><br><strong>上课不听作业硬 <em><font size =5>拖</font></em></strong><br><strong>每天<font size=1>最开心</font>的时候是晚上八九点</strong><br><strong>带着耳机穿上西装</strong><br><strong>骑着小电驴满城<font size =5 color =RoyalBlue>飙</font></strong><br><strong>看看放学的高中生和天上的<font color=    Gold>月亮</font></strong><br><strong>路上遇到什么想吃的就<font size =1>恰夜宵</font></strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/1652111074694b540.jpg"><br><img src="https://api2.mubu.com/v3/document_image/1652111074691cd1c.jpg"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>少年听雨</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记_MAC1</title>
    <url>/2022/04/13/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0_MAC1/</url>
    <content><![CDATA[<p>咕咕咕咕咕咕<br>鸽了很久的笔记<br>主要是每天躺着根本不想听课<br>就想着玩儿了</p>
<p>MAC:The Medium Access Control Sublayer 介质访问控制子层</p>
<h2 id="4-1-信道分配问题"><a href="#4-1-信道分配问题" class="headerlink" title="4.1 信道分配问题"></a>4.1 信道分配问题</h2><p>The Channel Allocation Problem</p>
<!---网桥是重点--->
<!---路由是网络层的--->
<!---VLAN虚拟的局域网，是为了安全--->
<h3 id="M-x2F-M-x2F-1-system"><a href="#M-x2F-M-x2F-1-system" class="headerlink" title="M&#x2F;M&#x2F;1 system"></a>M&#x2F;M&#x2F;1 system</h3><p>信道到达信息的概率服从泊松分布<br><img src="https://api2.mubu.com/v3/document_image/db416156-5a59-4ad2-9cd8-e066d232d4a6-16175743.jpg" alt="泊松分布"><br>其中，λ 是 arrival rate (frames&#x2F;sec)<br>标准排队理论的结果是<br>$T&#x3D;\cfrac{1}{\mu C-\lambda}$<br><img src="https://api2.mubu.com/v3/document_image/16501209178869b8a.jpg" alt="标准排队理论"><br>就是说，信道越小，<u>该信道上</u>发送一个帧的平均时延越小。（或许可以考虑一大群黄鳝源源不断的从一段管道中通过？（如果这样想能想明白的话）总之这个T是针对某个信道而言的）</p>
<p>$$信道分配问题\left{<br>\begin{matrix}<br>    静态信道分配Static\<br>    动态信道分配Dynamic<br>\end{matrix}<br>\right.$$</p>
<h3 id="动态信道分配"><a href="#动态信道分配" class="headerlink" title="动态信道分配"></a>动态信道分配</h3><ol>
<li>受控的多路通道<ol>
<li>中心化的：polling，投票，挨个询问</li>
<li>无中心的：token，令牌，谁拿到谁发</li>
</ol>
</li>
<li>随机的多路access<ol>
<li>ALOHA</li>
<li>CSMA, CSMA&#x2F;CD, CSMA&#x2F;CA</li>
</ol>
</li>
</ol>
<h2 id="4-2-多路访问协议"><a href="#4-2-多路访问协议" class="headerlink" title="4.2 多路访问协议"></a>4.2 多路访问协议</h2><h3 id="ALOHA协议（读作allow）"><a href="#ALOHA协议（读作allow）" class="headerlink" title="ALOHA协议（读作allow）"></a>ALOHA协议（读作<del>allow</del>）</h3><h4 id="pure-ALOHA"><a href="#pure-ALOHA" class="headerlink" title="pure ALOHA"></a>pure ALOHA</h4><ol>
<li>数据帧被传输在完全的随机时间，如果有冲突，就等一个随机的时间再发<br><img src="https://api2.mubu.com/v3/document_image/cbafc61d-5bd0-4657-b7dd-0c21070ad96c-16175743.jpg" alt="pure ALOHA"></li>
<li>这里的冲突是指的只要有一个bit的重叠，就被毁掉了，因为是电信号一旦重叠就肯定被毁了。</li>
<li>Collision Demo：<img src="https://api2.mubu.com/v3/document_image/329188b8-47f6-41a0-be49-5333580eb2eb-16175743.jpg" alt="Collision Demo："></li>
<li>Vulnerable period for the shaded frame.就是说在灰色帧发送的t0时刻前后的t时间里，不能有别的帧发送。<img src="https://api2.mubu.com/v3/document_image/b519b5f4-7125-47ec-b943-62f6267d564c-16175743.jpg" alt="11"></li>
<li>假设：帧长固定，帧发送时间也固定</li>
</ol>
<h4 id="Sloted-ALOHA"><a href="#Sloted-ALOHA" class="headerlink" title="Sloted ALOHA"></a>Sloted ALOHA</h4><p>一个重点是S&#x2F;G</p>
<h3 id="CMA-x2F-CD"><a href="#CMA-x2F-CD" class="headerlink" title="CMA&#x2F;CD"></a>CMA&#x2F;CD</h3><p>没写，回头补，咕咕咕</p>
<h2 id="4-4-无线局域网"><a href="#4-4-无线局域网" class="headerlink" title="4.4 无线局域网"></a>4.4 无线局域网</h2><p>Wireless LAN Protocols</p>
<p>需要解决的问题：<br>Hidden station problem<br>Exposed station problem<br>解决方法：</p>
<ul>
<li>PCF (Point Coordination Function)</li>
<li>DCF (Distributed Coordination Function)：<ul>
<li>CSMA&#x2F;CA:CSMA with Collision Avoidance</li>
<li>MACA(Multiple Access with Collision Avoidance)  protocol<br>MACA: Collision Avoidance</li>
</ul>
</li>
<li>A发给B一个RTS（request to send）（30 bytes长，包含将要发送的数据的长度）</li>
<li>B回复一个CTS（clear to send）（contains data length from RTS）</li>
<li>当收到CTS的时候，A开始发送数据</li>
<li>听到RTS的其他站点保持足够长的沉默时间（C,E）</li>
<li>听到CTS的其他站点在即将到来的（upcoming）数据传输中保持沉默。<br><img src="https://api2.mubu.com/v3/document_image/7719c78a-d525-4c61-9d83-1e1033423609-16175743.jpg" alt="传输范围"></li>
</ul>
<h2 id="4-3-以太网Ethernet"><a href="#4-3-以太网Ethernet" class="headerlink" title="4.3 以太网Ethernet"></a>4.3 以太网Ethernet</h2><ol>
<li>以太网cable<br><img src="https://api2.mubu.com/v3/document_image/d4080a82-a43c-40a7-bae6-86dee8e91d33-16175743.jpg" alt="以太网cable"></li>
<li>以太网Topologies(拓扑)</li>
</ol>
<h3 id="Ethernet-MAC-Sublayer-Protocol"><a href="#Ethernet-MAC-Sublayer-Protocol" class="headerlink" title="Ethernet MAC Sublayer Protocol"></a>Ethernet MAC Sublayer Protocol</h3><p>帧的格式（needrem）<br><img src="https://api2.mubu.com/v3/document_image/69a402c2-a4d7-4fad-8f60-83f849e2c4c4-16175743.jpg" alt="frame fromat"></p>
<p>（a）DIX 以太网标准<br>（b）IEEE 802.3标准<br>Preamble:前导&#x2F;序言，同步时钟信号。<br>Type：发送的数据是什么类型的，网上递交交到哪里去<br>Pad：填充字段，保证Data+Pad&gt;&#x3D;46，防止帧长过小<br><a href="https://api2.mubu.com/v3/document_image/16518386874381ff3.jpg">click</a></p>
<ol>
<li>以太网地址，6字节<br>在往上就是IP，然后就是DNS了<br><img src="https://api2.mubu.com/v3/document_image/783326c4-4a41-43e5-819b-3eed68ae5aa0-16175743.jpg" alt="IEEE802"><br>前面3个字节是厂家的标识，后面是厂家给用户分配的地址（网口）<br>这个属于Unicast，其他的还有Multicast，Broadcast（全1）。</li>
<li>帧长<br>最大的帧长是<mark>1514</mark>bytes（<mark>数据是1500bytes</mark>）<br>1514:1500+6+6+2(type)<br>1518:1500+6+6+2+4(CRC)<br>最小帧长是<mark>64bytes</mark>&#x3D;46(pad)+18(跟上面那个一样)<br>也就是 64x8&#x3D;512 bits<br>为什么需要有帧长的下限：<br>Collision Detect Can take as long as 2$\tau$<br><img src="https://api2.mubu.com/v3/document_image/6dca1935-e996-411d-a4aa-3cc560bd73a1-16175743.jpg" alt="为什么需要有帧长的下限"></li>
</ol>
<h3 id="二进制指数退避算法"><a href="#二进制指数退避算法" class="headerlink" title="二进制指数退避算法"></a>二进制指数退避算法</h3><p>Binary Exponential Backoff Algorithm<br>在CMA&#x2F;CD协议中，会等一个随机数，生成这个随机数的时候会需要一个上限<br>随着冲突次数的增加，随机数的上限以2的指数次增加，一直到1024个时间片，就不再增加比如：<br><img src="https://api2.mubu.com/v3/document_image/670fceab-f222-4966-8634-00c372fe590a-16175743.jpg" alt="以2的指数次增加"><br>这个算法是分布式的，即仅考虑自己是第几次冲突</p>
<h3 id="IEEE-802-3-Performance（Ethernet）"><a href="#IEEE-802-3-Performance（Ethernet）" class="headerlink" title="IEEE 802.3 Performance（Ethernet）"></a>IEEE 802.3 Performance（Ethernet）</h3><p>Frame length: F<br>Bandwith: B<br>Cable length: L<br>Speed of signal propagation: c<br>e:就是2.71828那个e<br>channel efficency &#x3D; $\cfrac{1}{1+\cfrac{2BLe}{cF}}$</p>
<p>Efficiency of Ethernet at 10 Mbps with 512-bit slot times<br><img src="https://api2.mubu.com/v3/document_image/3ac99641-5886-4176-93ff-cda58e5c3dcd-16175743.jpg" alt="Efficiency"></p>
<h3 id="Fast-Ethernet-快速以太网"><a href="#Fast-Ethernet-快速以太网" class="headerlink" title="Fast Ethernet 快速以太网"></a>Fast Ethernet 快速以太网</h3><p>所有之前的帧的格式，接口，程序都没有改变<br>减少bit time（100ns-&gt;10ns）<br>减少最大电缆长度为原来的十分之一<br>Cabling:<br><img src="https://api2.mubu.com/v3/document_image/b4c1f47d-ee1a-409f-bdda-379dd76a256d-16175743.jpg" alt="Fast Ethernet cabling"></p>
<p>100Basw-T4:<mark>不用曼彻斯特编码</mark>了<br><img src="https://api2.mubu.com/v3/document_image/7e3c5430-0d8b-4a75-a174-a5cc6bbd862c-16175743.jpg" alt="100Basw-T4"></p>
<h3 id="Gabit-Ethernet"><a href="#Gabit-Ethernet" class="headerlink" title="Gabit Ethernet"></a>Gabit Ethernet</h3><p>千兆的标准仍然向后兼容<br>网络半径变为25米，（速率提高10倍，距离一定缩小）<br>解决方法</p>
<ol>
<li>添加padding，用于填充</li>
<li>让几个短帧拼接在一起</li>
<li>总之就是让帧的尺寸&gt;&#x3D;512bytes<br>最终让网络工作的半径保持在200米<br>Cabling:<br><img src="https://api2.mubu.com/v3/document_image/1c9bce00-30ac-4e23-9335-2565ad825b8b-16175743.jpg" alt="Cabling"><br>Flow Control:(新增功能，因为千兆太快了)</li>
</ol>
<h3 id="10Gabit-Ethernet"><a href="#10Gabit-Ethernet" class="headerlink" title="10Gabit Ethernet"></a>10Gabit Ethernet</h3><p>一般在数据中心内部</p>
<h2 id="4-5-宽带无线"><a href="#4-5-宽带无线" class="headerlink" title="4.5 宽带无线"></a>4.5 宽带无线</h2><h3 id="IEEE802-11-x2F-wifi"><a href="#IEEE802-11-x2F-wifi" class="headerlink" title="IEEE802.11&#x2F;wifi"></a>IEEE802.11&#x2F;wifi</h3><p>All use CSMA&#x2F;CA for multiple access(多路访问采用冲突避免)<br>All have base-station and ad-hoc network versions</p>
<p>尽量避免冲突<br>CSMA：在发送之前sense<br>是一个无线环境，咩办法像在有线的里面一样弄CD（冲突检测），而且也没办法监听到所有的冲突（站隐藏）<br>CSMA&#x2F;CA：用协议来避免冲突叫做CSMA&#x2F;CA,C(ollision)A(voidance)</p>
<p>当一个站点有frame要发送时</p>
<ul>
<li>监听信道直到空闲为止，等一个时间片（DIFS:分布式的帧间隔,一个比较小的时间）</li>
<li>Random backoff：可能要等一个随机的时间（0~15 time slots），这东西是个倒计时，假如是13，就13–。</li>
<li>如果帧发过去了，终点发一个简短的ACK，几乎不等待，认为是立刻发回来</li>
<li>缺少ACK会被推测为显示了一个冲突或者别的错误，把backoff的时间片翻倍，再次尝试。(类似二进制退避算法)<br><img src="https://api2.mubu.com/v3/document_image/46566387-ba5a-4f85-8821-80e5a215ec27-16175743.jpg" alt="CSMA/CA"></li>
</ul>
<p>Chanel sensing:</p>
<ul>
<li>物理监听：check媒介，看有没有信号</li>
<li>虚拟监听：每个站点维护一个逻辑的记录，记录什么时候信道被占用，通过追踪<strong>NAV（network allocation vector）</strong>；每个帧都carries一个NAV，一个数据帧的NAV包含发送一个ack所需的时间</li>
</ul>
<p>RTS:request to send<br>CTS:clear to send<br><img src="https://api2.mubu.com/v3/document_image/23ddd9f5-7de1-4626-8822-b8b2fb2f359c-16175743.jpg" alt="NAV"></p>
<p>802.11 reliability</p>
<ul>
<li>降低传输速度（rate）</li>
<li>fragment burst：碎片突发，将一个大的帧切成小的碎片，帧的尺寸没变。这就好比有一定的误码率，一个很大的帧怎么发都发不出去。</li>
</ul>
<p>802.11 省电<br>就是不定期的让客户端睡觉。然后AP在client睡着的时候，缓存发送的信息</p>
<ul>
<li>Beason frames信标帧<ul>
<li>客户端可以进入省电模式</li>
<li>AP会buffer发送的帧</li>
<li>睡醒之后发送一个poll的信息给AP（就时不时睡醒一下）</li>
</ul>
</li>
<li>APSD（automatic power save delivery）<br>当客户端发数据给AP的时候，AP把buffer的数据发给客户端。</li>
</ul>
<p>802.11 QOS：interframe Spacing(IFS,帧间隔)</p>
<blockquote>
<p>QOS:quality of sevice</p>
</blockquote>
<ul>
<li>DIFS:regular data frames</li>
<li>SIFS:<ul>
<li>ACK</li>
<li>其他的控制帧，比如RTS,CTS</li>
<li>a burst of fragment（碎片突发）</li>
</ul>
</li>
<li>AIFS1:适用于PDF方式，就是语音或者其他优先级较高的传输</li>
<li>AIFS4：后台通信，不太重要</li>
<li>EIFS：异常时间<br><img src="https://api2.mubu.com/v3/document_image/064c30a1-ab7c-4ad0-b669-841bb55fdae1-16175743.jpg" alt="interframe Spacing"></li>
</ul>
<p>QOS：TXOP 传输机会<br>TX:transmit OP:opportunity<br><img src="https://api2.mubu.com/v3/document_image/162edab3-5d51-4133-ab69-abfc80ca1eb9-16175743.jpg" alt="QOS：TXOP"><br>无线局域网中，一个站点发送完了之后其他的站点会抢信道，然后抢到的就接着发。<br>在这个例子中，发送同样长的一个帧，6Mbps的站点花费的时间是54Mbps的站点发送时间的9倍，也就是说，在单位1的时间里，有0.9的时间是6Mbps的站点在发送，0.1的时间是54Mbps的站点在发送，这段时间针对每个站点的平均速率都为5.4Mbps。对于6Mbps的站点：发0.9的时间，等0.1的时间，相当于只发了6x0.9&#x3D;5.4,对于54Mbps的站点，发0.1的时间，等0.9的时间，也相当于只发了54x0.1&#x3D;5.4。<br>用了TXOP之后，两个站点占用的时间一样，都是一半，这样带宽也就降为原来的一半。<br>这样比较公平。</p>
<blockquote>
<p>关于计算多个站点的平均速率：<br> 有公式<br> $\cfrac{1}{\cfrac{n_1}{B_1}+\cfrac{n_2}{B_2}+\cfrac{n_3}{B_3}+…}$<br> 其中，Bi是速率，ni是具有Bi速率的站点的个数。这样算出来的所有站点的速率是一样的。<br> 如果能整除就不要添了，不能整除保留两位。</p>
</blockquote>
<p>802.11的帧格式</p>
<p><img src="https://api2.mubu.com/v3/document_image/b0a79323-b67a-4b67-8176-3e81822aacd4-16175743.jpg" alt="format"></p>
<p>地址1：目的，host或者AP的地址，也就是接受的站点的地址<br>地址2：源，发送站点的地址<br>地址3：router的地址，这个router是AP链接的那个路由器<br><img src="https://api2.mubu.com/v3/document_image/f2d22197-dd21-4b51-9abd-be84897e4c93-16175743.jpg" alt="为啥还得有地址3捏"><br>就是说，AP在发送的时候，不知道router的地址，所以把地址3读出来，作为这个小过程的目的地址，而原本的AP的地址是源地址。在这个小过程中，就相当于是802.3协议了。</p>
<p>802.2：LLC，逻辑电路控制子层<br>是在802.3或者其他802协议上面跑的，就是在MAC上面，使得向网络层提供的服务是单一的，统一的服务。但是大部分设备都是没这一层玩意的。DIX是不需要的，但是802.3一般是要加上这个的。<br>提供3个服务选择<br>（懒得自己写了，抄一个：）</p>
<ul>
<li>Unreliable datagram service 不可考的数据报<br>   (best-efforts datagram service)</li>
<li>Acknowledged datagram service 可靠的数据报<br>   (Error-controlled)</li>
<li>Reliable connection-oriented service 面向链接的<br>   (Error-controlled &amp;  flow-controlled)</li>
</ul>
<blockquote>
<p>LLC头里面有个header，来控制交给上面一层的哪一个模块儿</p>
</blockquote>
<h2 id="4-8-数据链路层交换"><a href="#4-8-数据链路层交换" class="headerlink" title="4.8 数据链路层交换"></a>4.8 数据链路层交换</h2><p>DLLS：Data Link Layer Switching</p>
<h3 id="不同802协议之间的桥接"><a href="#不同802协议之间的桥接" class="headerlink" title="不同802协议之间的桥接"></a>不同802协议之间的桥接</h3><h3 id="本地互联Local-Internetworking"><a href="#本地互联Local-Internetworking" class="headerlink" title="本地互联Local Internetworking"></a>本地互联Local Internetworking</h3><p><img src="https://api2.mubu.com/v3/document_image/610f9006-61fb-4320-8614-5283f9f2dbaa-16175743.jpg"><br>左边那个是通过一个桥接设备连接起两个网络<br>右边那个相当于二层交换机<br><img src="https://api2.mubu.com/v3/document_image/48fe4bcd-5734-496e-8e9b-cf667fe5019d-16175743.jpg" alt="Protocol processing"><br>如果左右两侧的协议不同，那么需要生成一个新的帧头，网桥是工作在数据链路层的。</p>
<p>Bridges from 802.x to 802.y</p>
<p>可能遇到的一些问题</p>
<p>帧格式不一样<br><img src="https://api2.mubu.com/v3/document_image/b21a25c8-afe1-4895-918b-364bd0fd1ac4-16175743.jpg" alt="帧格式不一样"><br>数据速率不同（缓存）<br>最大帧长度不一样<br>安全问题：无限局域网支持加密，以太网不支持<br>QOS问题：802.11支持，以太网不支持</p>
<h3 id="Learning-Bridge-自学习网桥"><a href="#Learning-Bridge-自学习网桥" class="headerlink" title="Learning Bridge 自学习网桥"></a>Learning Bridge 自学习网桥</h3><p>又名Transparent，咩有CPU，便宜。</p>
<blockquote>
<p>bridge和Switch的差别：switch的端口只有以太网，但是bridge上面可能有不同的端口（不同的局域网之间桥接）,其他的工作原理一毛一样。</p>
</blockquote>
<ul>
<li>工作在混杂的mode下<br>不同于仅接受特定地址或者广播的帧，接收所有的帧</li>
<li>站点（转发点）表格<br>自学列出来每个可能的目的地址和应该转发的线路</li>
<li>针对一个正在发过来的帧的路由过程<br>检索站表<br>如果目的LAN和源LAN一样，discard<br>如果目的LAN和源LAN不一样，forward<br>如果目的LAN不知道或者multicast&#x2F;broadcast<br>采用flooding algorithm<blockquote>
<p>所以如果站表是空的，那就把除了输入端口以外的所有端口复制一份。<br>如何判断LAN一样与否？看有咩有网桥在中间做桥接</p>
</blockquote>
</li>
</ul>
<h4 id="Station-Table：Backward-Learning"><a href="#Station-Table：Backward-Learning" class="headerlink" title="Station Table：Backward Learning"></a>Station Table：Backward Learning</h4><p>初始情况是空的<br>因为可以看到所有的帧，然后偷偷看一下某个端口收到的帧是从哪里来的，然后记住想到这里去要从哪个端口走。</p>
<h4 id="Dynamic-topologies-动态拓扑"><a href="#Dynamic-topologies-动态拓扑" class="headerlink" title="Dynamic topologies 动态拓扑"></a>Dynamic topologies 动态拓扑</h4><p>无论最初的hash表有没有建立，都会记录arrival time<br>如果长时间（一般是20min）左右，没有更新，那么就把这东西给删了。</p>
<blockquote>
<p>交换机的站表满了之后，整个网上的数据就处于一个扩散的状态，这也是黑客攻击的一种手段。<br>俩个构造station table 的例子<br><img src="https://api2.mubu.com/v3/document_image/50525ea3-4613-4e02-8d29-4f06d1e3d5fd-16175743.jpg" alt="例子"><br><img src="https://api2.mubu.com/v3/document_image/5cf3f19a-060a-490a-99a3-d56cabbb0888-16175743.jpg" alt="例子"></p>
</blockquote>
<h3 id="spanning-tree-生成树的网桥"><a href="#spanning-tree-生成树的网桥" class="headerlink" title="spanning tree 生成树的网桥"></a>spanning tree 生成树的网桥</h3><p>贵。<br>上面的结构没有环路，生成树网桥是为了解决环路问题的。<br>关于环路的问题：<br>有时候，为了增加可靠性，会多家几条路径<br>这个就导致了拓扑结构中出现环路<br>协议：802.1d: Constructing the Spanning Tree<br>过程：（了解即可）</p>
<ul>
<li>Bridge periodically multicast a message out all of its ports, this message is not forwarded, it includes:<ul>
<li>an ID based on its MAC address</li>
<li>ID of the root it  believe to be</li>
<li>the distance to root</li>
</ul>
</li>
<li>Chose the bridge with the lowest ID to be the root, after enough messages exchanged, all bridges will agree on the root</li>
<li>Remembers the shortest path to root, if there are multiple equivalent paths, the path via bridge with lowest ID is chosen</li>
<li>Turn off ports that are not part of the shortest path</li>
<li>Algorithm continues to run during normal operation to automatically detect topology changes and update the tree</li>
</ul>
<p>Dynamic Topologies</p>
<ul>
<li>BPDU (Bridge Protocol Data Unit)<br>Bridge periodically multicast a message (MAC 01:80:c2:00:00:00) out all of its ports, this message is not forwarded, it includes:<br>an ID based on its MAC address<br>ID of the root it  believe to be<br>the distance to root</li>
<li>Root Bridge of Whole Net<br>Chose the bridge with lowest ID to be the root, after enough messages exchanged, all bridges will agree on the root</li>
<li>Root Port of Every Bridge<br>Remembers the shortest path to root, if there are multiple equivalent paths, the path via bridge with lowest ID is chosen</li>
<li>Algorithm continues to run during normal operation to automatically detect topology changes and update the tree</li>
</ul>
<h3 id="几个设备"><a href="#几个设备" class="headerlink" title="几个设备"></a>几个设备</h3><ol>
<li>物理层：<ol>
<li>repeaters</li>
<li>Hub（纯物理层，长得像switch，将一个设备的输入接口和其他设备的输出接口接起来）</li>
</ol>
</li>
<li>数据链路层<ol>
<li>bridges</li>
<li>Switches（提及一个3层交换机，但不懂）</li>
</ol>
</li>
<li>网络层<ol>
<li>Routers</li>
<li>Gateways（网关）</li>
</ol>
</li>
</ol>
<p><img src="https://api2.mubu.com/v3/document_image/54276143-0987-40c4-857c-ba52f417f484-16175743.jpg" alt="几个设备"><br>(a)不同层对应的设备<br>(b)frames，packet and headers<br><img src="https://api2.mubu.com/v3/document_image/d62cc695-8518-4578-bc8f-85c70fd596db-16175743.jpg" alt="hub，bridge，switch"><br>从左到右：hub，bridge，switch<br>bridge和switch：<br>几个微秒就可以构造出来站表<br>因为速率可能不同，还得有buffer<br>cut-through switch：直通式的交换机（拿到目的地址之后直接就开始转发）</p>
<h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p>人事部，财务部，研发部的设备通过VLan划分开，不允许互相通信<br><img src="https://api2.mubu.com/v3/document_image/69387a3e-a977-4a97-8926-da5df6b88d87-16175743.jpg" alt="长这样"><br>为啥整VLAN捏？</p>
<ol>
<li>广播风暴<ol>
<li>当LAN规模比较大的时候，广播帧太多的时候，所有的设备都需要处理</li>
<li>机器们就残废了</li>
</ol>
</li>
<li>安全问题<ol>
<li>一些部门有不想让别的部门知道的信息<br><img src="https://api2.mubu.com/v3/document_image/0082b05a-9203-4354-a146-19dd170df9f1-16175743.jpg" alt="VLAN"><br>(a)是总线链接的，所以A收发的时候BCD也能听到<br>(b)是交换机型，可以做到仅同组听到</li>
</ol>
</li>
</ol>
<p>VLAN ID</p>
<ol>
<li>用端口号（most方便most常见）</li>
<li>用MAC地址</li>
<li>根据第三层的协议</li>
</ol>
<p><img src="https://api2.mubu.com/v3/document_image/6190f69b-1689-45bd-b4e7-51b3d3e31e87-16175743.jpg" alt="802.1Q"><br>VLAN protocol ID (16 bits): 0x8100<br>Pri (3 bits)<br>CFI (1 bit)<br>VLAN Identifier (12 Bits)<br>802.1Q Max frame length: 1522 bytes</p>
<h2 id="WordTable"><a href="#WordTable" class="headerlink" title="WordTable"></a>WordTable</h2><blockquote>
<p>capicity<br> overlap 重叠，重复<br> garble 混淆，模糊<br> idle 空的<br> carrier sense 载波监听<br> arbitrary 随意的，任意的<br> Vulnerable  adj.易受伤的, 脆弱的, 敏感的<br> Throughout 吞吐量&#x3D;利用率*带宽<br> Beason （啥呀这是草）<br> fragment 碎片<br> promiscuous 混杂的<br> crippled 残废的<br> legacy 遗产，遗留之物。legacy end domain 传统域，翻译为传统的<br> exclude vt. 排除；排斥；拒绝接纳；逐出<br> reserved adj. 保留的，预订的；缄默的，冷淡的；包租的</p>
</blockquote>
<!-- 课听到MAC(6)的一小时多了，不想听了，下次补上（ -->
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>形式语言与自动机_4</title>
    <url>/2022/05/12/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA_chapter4/</url>
    <content><![CDATA[<h1 id="第四章-上下文无关文法与下推自动机"><a href="#第四章-上下文无关文法与下推自动机" class="headerlink" title="第四章  上下文无关文法与下推自动机"></a>第四章  上下文无关文法与下推自动机</h1><p>上下文无关文法：CFG(contex free grammar)<br>2型文法，产生式形如A-&gt;a，A$\in$N</p>
<p><a href="https://api2.mubu.com/v3/document_image/1647178722462b691.jpg">几种文法的特点整理</a></p>
<p>对应的识别器：下推自动机<br>PDA（push down Automata）<br>PDA由输入带，有限控制器和下推栈组成<br><img src="https://api2.mubu.com/v3/document_image/24b4fce5-8f87-4dca-84a9-9352955a2392-16175743.jpg" alt="1"></p>
<h2 id="归约和推导"><a href="#归约和推导" class="headerlink" title="归约和推导"></a>归约和推导</h2><p>推理字符串是否属于文法所定义的语言</p>
<ul>
<li>一种是自下而上的方法，称为递归推理(recursive inference），递归推理的过程习称为归约；</li>
<li>一种是自上而下的方法，称为推导（derivation）.</li>
<li>归约过程   将产生式的右部（body）替换为产生式的左部（ head ）.</li>
<li>推导过程   将产生式的左部（ head ）替换为产生式的右部（ body ）</li>
</ul>
<p>例子：<br><img src="https://api2.mubu.com/v3/document_image/9bd456a1-7f21-40cb-aec1-055eeccc42b8-16175743.jpg" alt="归约"><br><img src="https://api2.mubu.com/v3/document_image/57a9fc01-11d8-4b9b-a469-09a31d167672-16175743.jpg" alt="推导"></p>
<ul>
<li>最左推导(leftmost derivations)<br>若推导过程的每一步总是替换出现在最左边的非终结符。<br><img src="https://api2.mubu.com/v3/document_image/9fb0447a-54b0-4f72-b822-d55cec7336c9-16175743.jpg" alt="l"></li>
<li>最右推导(rightmost derivations)<br>若推导过程的每一步总是替换出现在最右边的非终结符。<br><img src="https://api2.mubu.com/v3/document_image/bf95a2f6-8124-49c1-bd4c-7a68e69df74f-16175743.jpg" alt="r"></li>
</ul>
<h2 id="推导树和文法的二义性"><a href="#推导树和文法的二义性" class="headerlink" title="推导树和文法的二义性"></a>推导树和文法的二义性</h2><h3 id="推导树"><a href="#推导树" class="headerlink" title="推导树"></a>推导树</h3><p>用图的方法表示一个句型的推导，这种图称为推导树（也称语法树或语法分析树）<br>文法的起始符为根，树的枝结点标记是非终结符，叶结点标记为终结符或$\sigma$。<br>若枝结点有直接子孙x1, x2,…, xk，则文法中有生成式A→x1x2…xk<br><img src="https://api2.mubu.com/v3/document_image/378f4ab9-9951-475b-996c-9cc934efc070-16175743.jpg" alt="li"><br><img src="https://api2.mubu.com/v3/document_image/378f4ab9-9951-475b-996c-9cc934efc070-16175743.jpg" alt="tu"><br>推导树是对文法G中一个<u>特定句子形式</u>的派生过程所做的一种自然描述。</p>
<ul>
<li>边缘<br>叶子从左向右组成的字符串称为推导树的边缘。</li>
</ul>
<h3 id="归约、推导与分析树之间关系"><a href="#归约、推导与分析树之间关系" class="headerlink" title="归约、推导与分析树之间关系"></a>归约、推导与分析树之间关系</h3><p>归约<br><img src="https://api2.mubu.com/v3/document_image/034d00dd-d424-4ef1-a4ed-bf831eb1516f-16175743.jpg" alt="归约"><br>推导<br><img src="https://api2.mubu.com/v3/document_image/bfa38244-02b0-4e7b-97f5-16c4befc3faf-16175743.jpg" alt="推导"><br>关系<br><img src="https://api2.mubu.com/v3/document_image/e9d33c57-17f4-4416-b8a8-63bad4e38309-16175743.jpg" alt="关系"><br>证明2-&gt;5:<br>设2型文法G&#x3D;（N，T，P，S），如果存在S<img src="https://api2.mubu.com/v3/document_image/03811fd1-79b9-46ae-9187-fee25974c922-16175743.jpg" alt="推导出">ω，当且仅当文法G中有一棵边缘为ω的推导树。</p>
<ul>
<li>子树：<br>一棵派生树的子树，是树中的某个顶点连同它的全部后裔，以及连接这些后裔的边。<br><a href="https://api2.mubu.com/v3/document_image/09c3c42d-5fd5-415e-983d-4ac2fcbf359e-16175743.jpg">证明</a><br><a href="https://api2.mubu.com/v3/document_image/87352b24-c498-4dae-b762-b8d55e66ec0a-16175743.jpg">证明步骤1</a><br><a href="https://api2.mubu.com/v3/document_image/4650faf7-c73d-46df-aa3d-2f6c57288b96-16175743.jpg">证明步骤2</a></li>
</ul>
<h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><p>2型文法是二义的,当且仅当对于句子ω∈L(G),存在两棵不同的具有边缘为ω的推导树。<br>(即：如果文法是二义的, 那么它所产生的某个句子必然能从不同的最左(右)推导推出)。</p>
<ul>
<li>可有二个文法,一个有二义,一个无二义,但产生相同的语言.</li>
<li>可否通过变换消除二义性? —— 无一般的算法!</li>
</ul>
<h2 id="上下文无关文法的变换"><a href="#上下文无关文法的变换" class="headerlink" title="上下文无关文法的变换"></a>上下文无关文法的变换</h2><ol>
<li>CFG 的简化<ul>
<li>消无用符号</li>
<li>消$\varepsilon$产生式</li>
<li>消单产生式</li>
</ul>
</li>
<li>对生成式形式进行标准化</li>
</ol>
<p>生成式的标准形式:</p>
<ol>
<li>Chomsky范式 ：<br>  CNF - Chomsky Normal Form<br>  <img src="https://api2.mubu.com/v3/document_image/0b972e9e-9103-4285-9f11-7f404d2b45d5-16175743.jpg" alt="CNF"></li>
<li>Greibach范式：(GNF)<br>  <img src="https://api2.mubu.com/v3/document_image/8d0a5097-0bbf-4510-9abb-af14a4c8335e-16175743.jpg" alt="GNF"></li>
</ol>
<h3 id="消去无用符号"><a href="#消去无用符号" class="headerlink" title="消去无用符号"></a>消去无用符号</h3><h4 id="有用符号X"><a href="#有用符号X" class="headerlink" title="有用符号X"></a>有用符号X</h4><p><img src="https://api2.mubu.com/v3/document_image/5c46692f-3ba3-4bd6-9dba-7ee1a79a2591-16175743.jpg" alt="X"></p>
<ul>
<li>生成符号 generating symbol<br><img src="https://api2.mubu.com/v3/document_image/de1c8e4b-b028-48bf-933f-cd2937e22558-16175743.jpg" alt="生成符号"></li>
<li>可达符号 reachable symbol<br><img src="https://api2.mubu.com/v3/document_image/5c6aef7e-f00b-4260-9193-b75193bee158-16175743.jpg" alt="可达符号"></li>
</ul>
<h4 id="无用符号"><a href="#无用符号" class="headerlink" title="无用符号"></a>无用符号</h4><ul>
<li>非生成符号</li>
<li>不可达符号</li>
</ul>
<h4 id="消去无用符号的步骤"><a href="#消去无用符号的步骤" class="headerlink" title="消去无用符号的步骤"></a>消去无用符号的步骤</h4><ul>
<li>计算生成符号集</li>
<li>计算可达符号集</li>
<li>消去非生成符号、不可达符号</li>
<li>消去相关产生式</li>
</ul>
<h4 id="计算生成符号"><a href="#计算生成符号" class="headerlink" title="计算生成符号"></a>计算生成符号</h4><p>思路<br><img src="https://api2.mubu.com/v3/document_image/2872eb33-ddb9-4db1-8834-e79814953a22-16175743.jpg" alt="思路"><br>算法1:找出有用非终结符<br><img src="https://api2.mubu.com/v3/document_image/85a050c1-fc53-4c32-8bb9-ad81abfcd396-16175743.jpg" alt="算法1"><br>算法1图示:<br><img src="https://api2.mubu.com/v3/document_image/e8eeb259-84f4-4948-bced-32389df931f8-16175743.jpg" alt="图示"><br>一层层向外扩展，直至最外两层相等为止。所得集合即是算法1的有用符号。</p>
<h4 id="计算可达符号集"><a href="#计算可达符号集" class="headerlink" title="计算可达符号集"></a>计算可达符号集</h4><p>思路<br><img src="https://api2.mubu.com/v3/document_image/3af1f690-10fa-4b64-b311-f854d46d985c-16175743.jpg" alt="计算可达符号集"><br>算法2：找出有用符号（从S出发可达的符号）<br><img src="https://api2.mubu.com/v3/document_image/e8094e10-e4bf-4ad9-86b2-f034d639b972-16175743.jpg" alt="算法2"><br>图示<br><img src="https://api2.mubu.com/v3/document_image/0f604071-1898-407d-8229-5b6f406f9481-16175743.jpg" alt="图示"></p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p><img src="https://api2.mubu.com/v3/document_image/c9e673b9-0573-4f99-80d6-bdc67adbdef8-16175743.jpg" alt="lizi"><br>注意：在删除一个无用符号时，要把与它相关的式子也删掉。<br>并且，<mark>一定要先执行算法1，保证每个符号是生成符号，再执行算法2，保证每个符号是可达符号。否则可能会导致一些无用符号无法消除。</mark>（这个例子就是不这么干的反例）</p>
<p>一个定理：<br>任何非空的上下文无关语言,可由不存在无用符号的上下文无关语言产生(证明略)</p>
<h3 id="消去-varepsilon-产生式"><a href="#消去-varepsilon-产生式" class="headerlink" title="消去$\varepsilon$产生式"></a>消去$\varepsilon$产生式</h3><p>目的：方便文法的设计, 利于文法规范化.<br>影响：消去$\varepsilon$产生式, 除了文法不能产生字符串$\varepsilon$外，不会影响到原文法相应的语言中其它字符串的产生.</p>
<h4 id="可致空符号"><a href="#可致空符号" class="headerlink" title="可致空符号"></a>可致空符号</h4><p>nullable symbol<br><img src="https://api2.mubu.com/v3/document_image/daace5c0-2d0f-41d8-a022-f245a90d2803-16175743.jpg" alt="可致空符号"></p>
<h4 id="算法3-生成无-varepsilon-文法"><a href="#算法3-生成无-varepsilon-文法" class="headerlink" title="算法3: 生成无$\varepsilon$文法"></a>算法3: 生成无$\varepsilon$文法</h4><p>定义：若G的生成式中无任何$\varepsilon$产生式，或只有一个生成式S→$\varepsilon$且S不出现在任何生成式的右边，则称G为无$\varepsilon$文法。</p>
<p>思路：</p>
<p><img src="https://api2.mubu.com/v3/document_image/1d6d41c1-729e-4ac4-bf47-4e296f3ec652-16175743.jpg" alt="思路"></p>
<p><mark>算法步骤</mark></p>
<p><img src="https://api2.mubu.com/v3/document_image/c2829b36-1400-4476-8955-a96feefca3b5-16175743.jpg" alt="算法步骤"></p>
<p><img src="https://api2.mubu.com/v3/document_image/c9ff1e87-ea57-4e2f-967d-1afa35baf359-16175743.jpg" alt="2"><br>例子：<br><img src="https://api2.mubu.com/v3/document_image/c9c8141b-bc88-45af-8679-df1b572eaaff-16175743.jpg" alt="lizi"></p>
<h3 id="消去单产生式"><a href="#消去单产生式" class="headerlink" title="消去单产生式"></a>消去单产生式</h3><p>什么是单产生式<br>单产生式  形如 A-&gt;B 的产生式，其中A、B 为非终结符.<br>目的：<br>可简化某些证明，减少推导步数, 利于文法规范化.</p>
<h4 id="单元偶对-unit-pairs"><a href="#单元偶对-unit-pairs" class="headerlink" title="单元偶对 unit pairs"></a>单元偶对 unit pairs</h4><p><img src="https://api2.mubu.com/v3/document_image/7f563d59-edfa-4ab2-8303-90203d06e32d-16175743.jpg" alt="unit pairs"></p>
<h4 id="消去单产生式的算法"><a href="#消去单产生式的算法" class="headerlink" title="消去单产生式的算法"></a>消去单产生式的算法</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p><img src="https://api2.mubu.com/v3/document_image/ad2f4c73-516d-47c8-b469-9e1d07a124ce-16175743.jpg" alt="思路"></p>
<h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><p><img src="https://api2.mubu.com/v3/document_image/a2717996-4489-4e8c-8a3c-cc250d9a5e94-16175743.jpg" alt="算法步骤"><br>$N_A$可以理解成所有和A是单元偶对的非终结符的集合<br><img src="https://api2.mubu.com/v3/document_image/859f5d77-0587-4525-94b5-da4095c29ca6-16175743.jpg" alt="算法步骤2"></p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p><img src="https://api2.mubu.com/v3/document_image/c7867368-350a-44d0-89e7-3ef3810d6721-16175743.jpg" alt="例子"><br><img src="https://api2.mubu.com/v3/document_image/aeeffb80-9874-4111-a53c-905b59a41550-16175743.jpg" alt="例子2"><br><img src="https://api2.mubu.com/v3/document_image/ca9cfaa9-3519-4113-a5fa-a990f0f8c1cd-16175743.jpg" alt="例子3"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://api2.mubu.com/v3/document_image/0d85c3d2-3151-4d32-8e7b-1e30e8a4adf2-16175743.jpg" alt="小结"><br>注意 以上简化步骤的次序.<br>设 CFG  G 的语言至少包含一个非  的字符串，通过上述步骤从 G 构造 G1 ，则有 L(G1)&#x3D; L(G) - {$\varepsilon$}.<br>必须按照顺序的原因：<br>消去空生成式的时候，可能会引入一些单生成式，而消除单生成式的时候又可能引入一些无用符号。</p>
<h3 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h3><p>递归定义：<br><img src="https://api2.mubu.com/v3/document_image/7e94dd29-a89f-4f69-bd0b-42af73b3f5be-16175743.jpg" alt="dingyi"></p>
<h4 id="生成式的代换"><a href="#生成式的代换" class="headerlink" title="生成式的代换"></a>生成式的代换</h4><p>引理1：<br><img src="https://api2.mubu.com/v3/document_image/e8952fc6-9135-4689-929b-a8cd7e9763d6-16175743.jpg" alt="引理1"><br>一个小例子：<br><img src="https://api2.mubu.com/v3/document_image/2a7b7faa-e60d-4c0b-a749-5a977b7a2e72-16175743.jpg" alt="一个小例子："></p>
<h4 id="消除直接左递归"><a href="#消除直接左递归" class="headerlink" title="消除直接左递归"></a>消除直接左递归</h4><p>引理2<br><img src="https://api2.mubu.com/v3/document_image/7a19e78c-c34c-4c0b-8306-e92a46b1cf7f-16175743.jpg" alt="引理2"><br>例子：<br><img src="https://api2.mubu.com/v3/document_image/4e5120d2-63e7-476f-b65e-93b2faccee87-16175743.jpg" alt="例子："></p>
<h5 id="为什么要消除左递归？"><a href="#为什么要消除左递归？" class="headerlink" title="为什么要消除左递归？"></a>为什么要消除左递归？</h5><ol>
<li>以后的句法分析算法不适用于左递归,会引起死循环。</li>
<li>对于给定的2型文法, 该文法不存在无用符号, 无循环且是无ε生成式的文法, 为了消除G中可能存在的左递归, 构成一个等效的无左递归的文法G1, 可用算法5。</li>
<li>算法5在原理上与求解正规表达式方程组的算法类似.</li>
</ol>
<h5 id="算法5"><a href="#算法5" class="headerlink" title="算法5"></a>算法5</h5><p><img src="https://api2.mubu.com/v3/document_image/8b1fcac4-46ff-44bc-add8-e1bbb49e997b-16175743.jpg" alt="算法5"></p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p><img src="https://api2.mubu.com/v3/document_image/7d33cbe8-dd03-4731-a2fc-6cc3662ffef8-16175743.jpg" alt="示例"><br><img src="https://api2.mubu.com/v3/document_image/b7130afb-b6ba-4374-9bc4-b69a79cad139-16175743.jpg" alt="示例2"></p>
<h2 id="下推自动机"><a href="#下推自动机" class="headerlink" title="下推自动机"></a>下推自动机</h2><h2 id="上下文无关语言的性质"><a href="#上下文无关语言的性质" class="headerlink" title="上下文无关语言的性质"></a>上下文无关语言的性质</h2><h1 id="Chomsky范式和Greibach范式"><a href="#Chomsky范式和Greibach范式" class="headerlink" title="Chomsky范式和Greibach范式"></a>Chomsky范式和Greibach范式</h1><h2 id="Chomsky-范式"><a href="#Chomsky-范式" class="headerlink" title="Chomsky 范式"></a>Chomsky 范式</h2><p>2型文法G＝（N，T，P，S）<br>生成式形如：<br>A→BC和A→a<br>称为Chomsky Normal Format<br>特别的，若ε∈L（G），则S→ε是P的一个生成式，但<strong>S不能在任何其它生成式的右边</strong></p>
<p>构成步骤：</p>
<ol>
<li>消除ε生成式、无用符号、单生成式</li>
<li>引入新的非终结符，凑</li>
</ol>
<p><img src="https://api2.mubu.com/v3/document_image/2c0e2f24-d00e-4b33-9077-aa2c92baa578-16175743.jpg" alt="CNF"></p>
<h2 id="Greibach范式"><a href="#Greibach范式" class="headerlink" title="Greibach范式"></a>Greibach范式</h2><p>2型文法G＝（N，T，P，S）<br>若生成式的形式都是A→aβ，A∈N，a∈T，β∈N*<br>且G不含ε生成式，则称G为Greibach范式，记为GNF</p>
<p>构成步骤：</p>
<ol>
<li>2型文法变换为CNF。（A→a，A→BC形式）</li>
<li>对非终结符排序</li>
<li>假如按下标递增，不能出现$A1-&gt;A2\beta$（A2高于A1）<ol>
<li>把A2的生成式带入，直至满足上述条件</li>
</ol>
</li>
<li>消除左递归（只对最高的Ai进行消除左递归，消除完了之后Ai就会满足GNF形式，即终结符a开头，但会引入新的非终结符Ai’,这些新的非终结符优先级是最低的）</li>
<li>回代<ol>
<li>依次回代Ai到Ai-1，Ai-1到Ai-2….一直到右部首字符都为终结符</li>
</ol>
</li>
<li>将消除左递归时候引入的带’的右部进行代换，换成右部首字符都为终结符。</li>
</ol>
<p>GNF1：<br><img src="https://api2.mubu.com/v3/document_image/1f5f4619-f44c-4f1d-9120-7cd807e9874c-16175743.jpg" alt="GNF1"><br>GNF2：<br><img src="https://api2.mubu.com/v3/document_image/88f16a4c-5497-4016-b210-fde1e1179f3c-16175743.jpg" alt="GNF2"><br>GNF3：<br><img src="https://api2.mubu.com/v3/document_image/10a971db-617a-4b4f-8153-7db24755a189-16175743.jpg" alt="GNF3"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>形式语言与自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记_chapter4</title>
    <url>/2022/05/07/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_chapter4/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>指令系统<strong>ISA</strong>（Instruction Set Architecture）<br>指令分类：</p>
<ul>
<li>微指令：微程序级的命令，它属于<strong>硬件</strong></li>
<li>宏指令：由若干条机器指令组成的软件指令，它属于软件</li>
<li>机器指令：介于微指令与宏指令之间，每条指令可完成一个独立的算术运算或逻辑运算</li>
</ul>
<p>复杂指令系统计算机 （<strong>CISC</strong>）： Complex Instruction Set Computer<br>精简指令系统计算机（<strong>RISC</strong>）：Reduced Instruction Set Computer</p>
<h2 id="4-2指令格式"><a href="#4-2指令格式" class="headerlink" title="4.2指令格式"></a>4.2指令格式</h2><p>指令字（简称指令）即表示一条指令的机器字<br>指令格式则是指令字用二进制代码表示的结构形式<br>指令的构成</p>
<ul>
<li>操作码字段：表示指令的操作特性与功能，即指令应进行什么样的操作</li>
<li>操作数地址字段：指定参与操作的操作数的地址</li>
</ul>
<h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>操作码字段的位数一般取决于计算机指令系统的规模。例如：<br>如果指令系统只有8条指令，则用3位操作码就可表示<br>如果有32条指令，那么就需要5位操作码<br>定长操作码指令格式<br><img src="https://api2.mubu.com/v3/document_image/ebe16a31-c998-4a1f-b0ec-d3eb36d2945e-16175743.jpg" alt="定长"><br>扩展操作码指令格式:<br><img src="https://api2.mubu.com/v3/document_image/f46b1ac4-19a4-42b3-8c85-ff482d434dc3-16175743.jpg" alt="扩展"></p>
<h3 id="地址码"><a href="#地址码" class="headerlink" title="地址码"></a>地址码</h3><p>按照一条指令中有几个操作数地址，可将该指令称为几操作数指令或几地址指令</p>
<ul>
<li>三地址指令格式</li>
<li>二地址指令格式</li>
<li>一地址指令格式</li>
<li>零地址指令格式</li>
</ul>
<p>不同地址数目指令的形式：<br><a href="https://api2.mubu.com/v3/document_image/6a57c343-2819-4f24-a246-7266f895a1fc-16175743.jpg">零地址码和一地址码</a><br><a href="https://api2.mubu.com/v3/document_image/50587f8f-388f-4803-8523-6f8a9fa8fdad-16175743.jpg">二地址码和三地址码</a>  </p>
<p>根据各个操作数的物理位置不同，地址码可分为3类</p>
<ul>
<li>存储器-存储器（SS）型指令</li>
<li>寄存器-寄存器（RR）型指令</li>
<li>寄存器-存储器（RS）型指令</li>
</ul>
<p>指令字长度：一个指令字中包含二进制代码的位数<br>机器字长：计算机能直接处理的二进制数据的位数，它决定了计算机的运算精度<br><strong>机器字长度通常与寄存器的位数一致</strong><br>指令分类<br>单字长指令：指令字长度等于机器字长度<br>半字长指令：指令字长度等于半个机器字长度<br>双字长指令：指令字长度等于两个机器字<br>使用多字长指令，目的在于ᨀ供更大的地址空间。主要缺点是必须两次或多次访问内存以取出一整条指令，降低了Cpu的运算速度。<br>等长指令字结构：各种指令字长度是相等的。这种指令字结构简单，且指令字长度是不变的。<br>变长指令字结构：各种指令字长度随指令功能而异。结构灵活，代码密度高，能充分利用指令长度，但指令的控制比较复杂。<br>指令助记符：每条指令通常用3个或4个英文缩写字母来表示<br><img src="https://api2.mubu.com/v3/document_image/5a5fe9b9-8f1d-4f8e-81e8-bf254a362157-16175743.jpg" alt="典型助记符"></p>
<h2 id="4-3指令和数据的寻址方式"><a href="#4-3指令和数据的寻址方式" class="headerlink" title="4.3指令和数据的寻址方式"></a>4.3指令和数据的寻址方式</h2><p>在存储器中，写入或读出操作数&#x2F;指令字的方式有：</p>
<ul>
<li><font color=iceblue>地址指定方式</font></li>
<li>相联存储方式（按内容寻址方式）</li>
<li>堆栈存取方式</li>
</ul>
<p>采用<font color=iceblue>地址指定方式</font>时，形成操作数或指令地址的方式，称为寻址方式。<br>寻址方式分为两类</p>
<ul>
<li>指令寻址方式（简单）<ul>
<li>顺序寻址方式</li>
<li>跳跃寻址方式</li>
</ul>
</li>
<li>数据寻址方式（复杂）</li>
</ul>
<h3 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a>指令寻址方式</h3><h4 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h4><p>必须使用程序计数器（又称指令指针寄存器）PC来计数指令的顺序号，该顺序号就是指令在内存中的地址。PC++是指跳过当前指令，到达下一条指令。（PC加几取决于指令长度）<br><img src="https://api2.mubu.com/v3/document_image/9b8210c5-48fb-4e5d-8210-7faef68427a8-16175743.jpg" alt="顺序寻址"></p>
<h4 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h4><p>本条指令给出下一条指令的地址码。<br>一般是条件转移，无条件转移，子程序调用会用到。<br><img src="https://api2.mubu.com/v3/document_image/5cd2947f-fc3b-4023-b9f6-933a2cfb64ac-16175743.jpg" alt="跳跃寻址"></p>
<h3 id="操作数寻址方式"><a href="#操作数寻址方式" class="headerlink" title="操作数寻址方式"></a><mark>操作数寻址方式</mark></h3><p>形成<strong>操作数的****有效地址</strong>的方法，称为操作数的寻址方式<br>一种单地址指令的结构如下所示，其中用X，I，A各字段组成该指令的操作数地址<br><img src="https://api2.mubu.com/v3/document_image/220a471b-f43a-47ce-b34f-e6ce929dbd98-16175743.jpg" alt="单地址指令结构"><br>指令中操作数字段的地址码是由<strong>形式地址A（也称偏移量）</strong>和<strong>寻址方式特征位</strong>等组合形成。</p>
<blockquote>
<p>寻址过程就是把操作数的<strong>形式地址</strong>，变换为操作数的<strong>有效地址</strong>的过程</p>
</blockquote>
<h4 id="1-隐含寻址"><a href="#1-隐含寻址" class="headerlink" title="1.隐含寻址"></a>1.隐含寻址</h4><p>在指令中不是显式而是隐含（默认）给出操作数的地址<br><img src="https://api2.mubu.com/v3/document_image/e44225a1-bd09-47db-ac05-81928d4133ef-16175743.jpg" alt="乘法指令"></p>
<h4 id="2-立即寻址"><a href="#2-立即寻址" class="headerlink" title="2.立即寻址"></a>2.立即寻址</h4><p>指令的地址字段给出的不算操作数的地址，而是操作数本身<br>这种方式的特点是指令执行速度较快，取指令的同时就取到了操作数，<strong>不需要访问内存取操作数</strong>（<font color=iceblue>立即数</font>啦）</p>
<h4 id="3-直接寻址"><a href="#3-直接寻址" class="headerlink" title="3.直接寻址"></a>3.直接寻址</h4><p>在指令的地址字段中直接给出的是操作数在内存的地址。<br>要按照这个地址去读取内存。<br>用直接寻址方式时，指令字中的形式地址A就是操作数的有效地址EA。因此通常把形式地址A又称为直接地址<br><img src="https://api2.mubu.com/v3/document_image/907b5157-8cd1-4074-9365-771bc842e8f9-16175743.jpg" alt="直接寻址"><br>途中的括号表示取地址。</p>
<h4 id="4-间接寻址"><a href="#4-间接寻址" class="headerlink" title="4.间接寻址"></a>4.间接寻址</h4><p>在指令的地址字段中直接给出的不是操作数的直接地址，而是操作数地址的地址。</p>
<blockquote>
<p>间接寻址方式是早期计算机中经常采用的方式，但由于两次访存，执行速度慢，现在已不太使用<br><img src="https://api2.mubu.com/v3/document_image/7688c0fe-f51f-4296-8214-de2e1e793dcd-16175743.jpg" alt="间接寻址"></p>
</blockquote>
<blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/7d846bd8-a82a-430a-aec3-7b1eb3854fc5-16175743.jpg" alt="结合起来的指令格式"></p>
</blockquote>
<h4 id="5-寄存器寻址"><a href="#5-寄存器寻址" class="headerlink" title="5.寄存器寻址"></a>5.寄存器寻址</h4><p>在指令的地址字段中直接给出的操作数地址不是内存的地址，而是<strong>寄存器的编号</strong>。<br><img src="https://api2.mubu.com/v3/document_image/71230b43-fbbd-4de0-acb2-3852c90693d0-16175743.jpg" alt="寄存器寻址"></p>
<h4 id="6-寄存器间接寻址"><a href="#6-寄存器间接寻址" class="headerlink" title="6.寄存器间接寻址"></a>6.寄存器间接寻址</h4><p>类似于上面的间接寻址。<br>在指令的地址字段中直接给出的寄存器不是含有操作数的寄存器编号，而是操作数地址的地址。<br><img src="https://api2.mubu.com/v3/document_image/b9367f6d-0e6e-4803-b961-dd74d7455281-16175743.jpg" alt="jcq间接寻址"></p>
<h4 id="7-偏移寻址"><a href="#7-偏移寻址" class="headerlink" title="7.偏移寻址"></a>7.偏移寻址</h4><p>是直接寻址和寄存器间接寻址方式的结合。EA是有效地址，A是形式地址,也就是偏移量。R代表寄存器。A（偏移量）是一个有符号数。</p>
<p><img src="https://api2.mubu.com/v3/document_image/56c81aa7-de35-43b7-b3cf-6aef2fb60d38-16175743.jpg" alt="偏移寻址"></p>
<ul>
<li>相对寻址 PC，程序计数器</li>
<li>基址寻址 基址寄存器</li>
<li>变址寻址 变址寄存器<br>上面这三者的的不同主要是<strong>寄存器种类不同</strong></li>
</ul>
<h5 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h5><ul>
<li>把<strong>程序计数器PC的内容</strong>加上指令格式中的<strong>偏移量A（有符号数）</strong>而形成<strong>操作数的有效地址</strong>  </li>
<li><strong>程序计数器的内容就是当前指令的地址</strong>，“相对”寻址，就是<strong>相对于当前的指令地址</strong>而言  </li>
<li>好处是<u>程序员无须用指令的绝对地址编程，所编程序可以放在内存任何地方</u></li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/19bf348a-f6ee-4c9a-8d77-6f8c68900b07-16175743.jpg" alt="相对寻址"></p>
<h5 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h5><p>将CPU中<strong>基址寄存器的内容</strong>加上指令格式中的<strong>偏移量A</strong>得到的<strong>操作数有效地址</strong><br>可以<strong>扩大寻址能力</strong>。基址寄存器的位数可以设置得很长，从而可以在较大的存储空间中寻址。<br><img src="https://api2.mubu.com/v3/document_image/70b600ef-a40a-47b6-9a62-4f9312142deb-16175743.jpg" alt="基址寻址"><br>B：基址寄存器</p>
<h5 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h5><p>将CPU中变址寄存器的内容加上指令格式中的偏移量A得到的操作数有效地址。与基址寻址方式类似。但变址寄存器的内容自动递增或递减。<br><img src="https://api2.mubu.com/v3/document_image/106ecb2b-f3cc-4caf-ac7e-a3a6e6670109-16175743.jpg" alt="自动加/减"><br>使用变址寻址方式的目的不在于扩大寻址空间，而在于实现程序块的规律性变化（自动加1减1、或加2减2）</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>例1<br>机器字长16位，<strong>主存按字节编址</strong>，转移指令采用相对寻址，由两个字节组成，第一字节为操作码字段，第二字节为相对位移量字段。假定取指令时，每取一个字节PC自动加1。若Ḁ转移指令所在主存地址为2000H，相对位移量字段的内容为06H，则该转移指令成功转以后的目标地址是<br>A.2006H<br>B.2007H<br>C.2008H<br>D.2009H  </p>
<p>Ans:C<br><mark>PC中存储的是即将执行的下一条指令的地址，也就是PC自动++之后的结果，PC自动加几是看的指令的字节长度,(与机器字长无关)，本题中的指令长度为2字节，所以PC自加加的是2。也就是此时PC中存放的地址是当前指令地址+2，为2002H，然后再加上06H</mark></p>
<p>例2<br>计算机有16个通用寄存器，采用32位定长指令字，操作码字段（含寻址方式位）为8位，Store指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式，若基址寄存器可使用任一通用寄存器，且偏移量用补码表示，则Store指令中偏移量的取值范围是<br>A -32768<del>+32767<br>B -32767</del>+32768<br>C -65536<del>+65535<br>D -65535</del>+65536  </p>
<p>Ans:A<br><mark>32位定长指令，-8位操作码，还剩24位，16&#x3D;2^4个通用寄存器（基址寄存器），由于<u>源操作数采用寄存器直接寻址</u>，所以一共需要4位，<u>目的操作数采用基址寻址</u>，且基址寄存器&#x3D;&#x3D;通用寄存器，所以也需要4位。此时一共用去了16位。偏移量采用补码表示，即计算16位补码能表示上下限，估算2的15次方，注意下限的绝对值比上限大1即可.</mark></p>
<h4 id="8-段寻址"><a href="#8-段寻址" class="headerlink" title="8.段寻址"></a>8.段寻址</h4><p>段寻址看这个图就行<br><img src="https://api2.mubu.com/v3/document_image/865d8ac6-738d-43f5-96a0-4b91e788c716-16175743.jpg" alt="段寻址"></p>
<h4 id="9-堆栈寻址"><a href="#9-堆栈寻址" class="headerlink" title="9.堆栈寻址"></a>9.堆栈寻址</h4><p>所有的操作都是针对栈顶，<strong>后进先出</strong></p>
<h5 id="寄存器堆栈"><a href="#寄存器堆栈" class="headerlink" title="寄存器堆栈"></a>寄存器堆栈</h5><p>存储区域用若干个寄存器组成<br>CPU中有一组专门的寄存器，有16个或者更多，它们称为串联堆栈。数据的进出是通过栈顶实现的<br>CPU通过“进栈”指令把数据送入堆栈，而通过“出栈”指令把数据从堆栈中取出</p>
<p>特点：</p>
<ul>
<li>入栈和出栈时，栈顶不变，数据移动</li>
<li>访问速度快</li>
</ul>
<p>缺点：</p>
<ul>
<li>寄存器的数目有限，所以堆栈大小受限</li>
<li><font color=red>数据的读出是破坏性的</font></li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/5f0003bc-a718-436c-8856-7d60754ee5c8-16175743.jpg" alt="寄存器堆栈"></p>
<h5 id="存储器堆栈"><a href="#存储器堆栈" class="headerlink" title="存储器堆栈"></a>存储器堆栈</h5><p>存储区域是主存的一部分</p>
<ul>
<li>需要一个<strong>堆栈指示器</strong>来指示堆栈中栈顶的位置，它通常是CPU中一个专用的寄存器（<strong>SP：Stack Point</strong>）</li>
<li>比串联堆栈灵活</li>
<li><strong>栈顶变化，由SP指示</strong>，而数据不动</li>
</ul>
<p>优点：</p>
<ul>
<li>堆栈可以根据需要，任何长度</li>
<li>堆栈个数可以根据需要而定</li>
<li>可以用对存储器寻址的任何一条指令来对堆栈进行寻址</li>
</ul>
<!-- 看到4-25-3 20：00-->
<p><img src="https://api2.mubu.com/v3/document_image/bd67a51b-0c26-4107-b371-1dada4bfddb2-16175743.jpg" alt="进栈"></p>
<blockquote>
<p>震惊！8进制300-1居然&#x3D;277！</p>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/e254dee8-829a-4bc6-a08e-472bb0c6f743-16175743.jpg" alt="出栈"></p>
<p>在设计处理器的堆栈操作时，有2种选择：</p>
<ol>
<li>堆栈指示器 SP始终指向空单元<ul>
<li>进栈时，先存入数据，后修改堆栈指示器SP</li>
<li>出栈时，先修改堆栈指示器SP，然后取出数据</li>
<li>这里修改SP可以是加操作，也可以是减操作</li>
</ul>
</li>
<li>堆栈指示器 SP始终指向满单元<ul>
<li>进栈时，先修改堆栈指示器SP，后存入数据</li>
<li>出栈时，先取出数据，然后修改堆栈指示器SP</li>
</ul>
</li>
</ol>
<h4 id="Pentium寻址方式"><a href="#Pentium寻址方式" class="headerlink" title="Pentium寻址方式"></a>Pentium寻址方式</h4><p>没大仔细听，有9种寻址方式<br><img src="https://api2.mubu.com/v3/document_image/a947242f-88bd-4ec0-933c-2ac7e76b71ec-16175743.jpg" alt="9种"></p>
<h5 id="PDP-x2F-11系列机寻址方式"><a href="#PDP-x2F-11系列机寻址方式" class="headerlink" title="PDP&#x2F;11系列机寻址方式"></a>PDP&#x2F;11系列机寻址方式</h5><p>↑写个标题证明老师讲了(</p>
<h5 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h5><p><img src="https://api2.mubu.com/v3/document_image/31d72579-6aba-45e1-8612-f3e2b79dd4da-16175743.jpg" alt="例3"></p>
<p><img src="https://api2.mubu.com/v3/document_image/27c67e1e-2631-435e-a903-fc3040002636-16175743.jpg" alt="答案"></p>
<h5 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h5><p><img src="https://api2.mubu.com/v3/document_image/4e292206-4fb5-47e8-b3dd-2c4a35678aae-16175743.jpg" alt="例4"><br><img src="https://api2.mubu.com/v3/document_image/3e524eeb-6f13-4a26-ba22-a92520bc9a10-16175743.jpg" alt="例4.2"><br><img src="https://api2.mubu.com/v3/document_image/e69aeaed-6df4-4b73-ad34-e93f897f8faa-16175743.jpg" alt="答案"></p>
<h5 id="动手做"><a href="#动手做" class="headerlink" title="动手做"></a>动手做</h5><p><img src="https://api2.mubu.com/v3/document_image/2e5e39ff-8da3-483b-8a35-1bb51b40e76e-16175743.jpg" alt="动手"></p>
<blockquote>
<p>基本上所有的CPU都是按字节编址的，因为是冯诺依曼体系结构，所以指令也被丢在主存里面，按字节编址指的就是对存储器按字节编址，就是说指令的长度得是<mark>8的倍数位</mark><br><a href="https://www.zhihu.com/question/25689240">编址寻址的概念</a></p>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/a1d5abc5-b28f-4841-a4e6-660a501ba001-16175743.jpg" alt="dongshou2"></p>
<h2 id="4-5-典型指令"><a href="#4-5-典型指令" class="headerlink" title="4.5 典型指令"></a>4.5 典型指令</h2><ul>
<li>数据传送指令</li>
<li>算术运算指令</li>
<li>逻辑运算指令</li>
<li>程序控制指令</li>
<li>输入输出指令</li>
<li>串处理指令</li>
<li>特权指令</li>
<li>其他指令</li>
</ul>
<h2 id="CISC-RISC计算机"><a href="#CISC-RISC计算机" class="headerlink" title="CISC RISC计算机"></a><mark>CISC RISC计算机</mark></h2><p>CISC:复杂指令计算机的指令系统一般多达二三百条<br>2-8定律：20%的指令在80%的情况下被使用</p>
<p>复杂指令系统的<strong>特点</strong>:<br><img src="https://api2.mubu.com/v3/document_image/c88812bb-aba7-4617-aa34-6661002d4f45-16175743.jpg" alt="复杂指令系统的特点"></p>
<p>RISC:RISC计算机</p>
<p>精简指令系统的<strong>特点</strong><br><img src="https://api2.mubu.com/v3/document_image/61c9c78d-0c5e-40c6-986e-536dd33fe302-16175743.jpg" alt="精简指令系统的特点"></p>
<p>MIPS指令集被认为是RISC体系中最优雅的一种，DEC的Alpha和惠普的Precision都深受其影响。<br>MIPS指令格式：略</p>
<blockquote>
<p>word table<br> complement 补充，互为补充的东西</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记_chapter5</title>
    <url>/2022/05/09/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_chapter5/</url>
    <content><![CDATA[<p>处理器的功能</p>
<ol>
<li>指令控制</li>
<li>操作控制</li>
<li>时间控制</li>
<li>数据加工</li>
<li>中断处理</li>
</ol>
<p><strong>CPU&#x3D;控制器+运算器+一堆寄存器</strong></p>
<p>控制器<br><img src="https://api2.mubu.com/v3/document_image/55128aff-1bc5-46c0-8f39-c21df4b6815f-16175743.jpg" alt="组成"><br>主要功能</p>
<ul>
<li>从指令cache中<strong>取</strong>出一条<strong>指令</strong>，并<strong>指出下一条指令</strong>在指令cache中的<strong>位置</strong></li>
<li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作</li>
<li>指挥并控制CPU、内存和输入&#x2F;输出设备之间数据流动的方向</li>
</ul>
<p>运算器<br>组成：ALU,累加寄存器，数据缓冲寄存器DR，状态条件寄存器PSW<br>主要功能：</p>
<ul>
<li>执行所有的算数和逻辑运算</li>
<li>并进行逻辑测试，如零值测试或两个值的比较</li>
</ul>
<p>CPU中的主要寄存器（6种）</p>
<ul>
<li>数据缓冲寄存器<strong>DR</strong><br>用来暂时存放：<ol>
<li>向数据cache写入一个数据时，用DR<strong>暂存</strong></li>
<li>ALU计算结果<br> 作用</li>
<li>作为ALU运算结果和通用寄存器之间信息传送中时间上的<strong>缓冲</strong></li>
<li>补偿CPU和内存、外设之间在操作速度上的差别</li>
</ol>
</li>
<li>指令寄存器<strong>IR</strong>(控制器内部)<br>用来<strong>保存当前正在执行的一条指令</strong><br>指令寄存器中操作码字段的输出就是指令译码器的输入<br>操作码经过译码器译码之后，。。。</li>
<li>程序计数器<strong>PC</strong>(控制器内部)<br>也称指令计数器，来确定<strong>下一条</strong>指令的地址<br>在程序开始执行之前，将程序的第一条指令所在的内存单元送入PC<br>执行完之后会自加</li>
<li>地址寄存器<strong>AR</strong><br>用来保存当前处理器所访问的数据cache</li>
<li>通用寄存器<strong>R0~R3</strong>(一般举例子说是4个)<br>在ALU执行运算时，为其提供一个暂存数据的工作区<br><strong>累加寄存器</strong>暂时存放ALU计算结果</li>
<li>状态条件寄存器<strong>PSW</strong>（ALU内部）<br>保存进位标志C，溢出标志O，是否为0Z，结果为负N等等<br>就是存汇编语言中标志位的那个。</li>
</ul>
<h3 id="操作控制器和时序产生器"><a href="#操作控制器和时序产生器" class="headerlink" title="操作控制器和时序产生器"></a>操作控制器和时序产生器</h3><h4 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h4><!-- 等着抄ppt16页 -->
<h4 id="操作控制器"><a href="#操作控制器" class="headerlink" title="操作控制器"></a>操作控制器</h4><p>功能：  </p>
<p>根据设计方法的不同分类：</p>
<ul>
<li>时序逻辑型 硬布线控制器(RISC也是)</li>
<li>存储逻辑性 微程序控制器(CISC也是)</li>
</ul>
<h4 id="时序产生器"><a href="#时序产生器" class="headerlink" title="时序产生器"></a>时序产生器</h4><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p>基本概念</p>
<ul>
<li>指令周期：<strong>取指令、分析指令、执行指令</strong>的time<br>由于各种指令的操作功能不同，各种指令的指令周期长度是不同的。<br>指令周期通常包含若干个CPU周期</li>
<li>CPU周期，也称机器周期<br>内存中读取一个指令字的最短time<br>可以分成若干个时钟周期</li>
<li>时钟周期<br>处理操作的最基本的单位，也成为节拍脉冲&#x2F;T周期</li>
</ul>
<blockquote>
<p>时钟周期是最基本的周期单位<br>如图<br><img src="https://api2.mubu.com/v3/document_image/2fa84ec0-9a03-4917-af3d-46afef8138e3-16175743.jpg" alt="z"><br>↑图中，分析指令过程被包含在执行指令过程中。时钟周期是最小单位，若干时钟周期组成CPU周期，若干CPU周期组成指令周期。</p>
</blockquote>
<p>程序示例<br><img src="https://api2.mubu.com/v3/document_image/936c8718-341d-452a-8b37-fd2951613ea7-16175743.jpg" alt="ex"></p>
<blockquote>
<p>Intel 汇编语言的指令与 AT&amp;T 的指令操作数的方向上正好相反：在 Intel 语法中，第一个操作数是目的操作数，第二个操作数源操作数。而在 AT&amp;T 中，第一个数是源操作数，第二个数是目的操作数。<br><mark>这个程序示例里面是AT&amp;T</mark></p>
</blockquote>
<p>STO为写数指令</p>
<p>凡是RR型指令，都是2个CPU周期，RS型指令，都是3个COU周期。<br>每条指令的<strong>取指令阶段</strong>都是一样的，花费<strong>一个CPU周期</strong>，具体步骤是</p>
<ol>
<li>根据PC的之（将要执行的指令的地址）从内存中取出指令，送到IR</li>
<li>取完之后PC就++</li>
<li>分离操作码和操作数，对指令进行译码</li>
</ol>
<p>RS型指令多一个CPU周期的原因是需要送操作数地址。<br>特别的，JMP指令是无条件的转移指令，相当于是把某个立即数送到寄存器PC，并没有访问memory，所以还是2周期。</p>
<p>最后，检查有无中断的操作也是每条指令都要进行的操作。</p>
<h4 id="方框图"><a href="#方框图" class="headerlink" title="方框图"></a>方框图</h4><ul>
<li>方框：<strong>代表一个CPU周期</strong>，方框中的内容表示数据通路的操作或某种控制操作</li>
<li>菱形：通常用来表示某种判别或测试，在<strong>时间上依附于紧接它的前面一个方框的CPU周期，不单独占用一个CPU周期</strong><br><img src="https://api2.mubu.com/v3/document_image/5e4bf550-24cc-4882-a0c9-18d0c5509a29-16175743.jpg" alt="五条典型指令的周期方框图"></li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://api2.mubu.com/v3/document_image/5a6fedbd-b29d-4fc9-a1d4-785b38f987d7-16175743.jpg" alt="例子1"><br><img src="https://api2.mubu.com/v3/document_image/ce79b93d-c471-4fea-a2bc-4c35ba366fa7-16175743.jpg" alt="例子2"></p>
<p>答案<br>（1）：<br><img src="https://api2.mubu.com/v3/document_image/055d35ce-728f-4576-b6c6-a8ddb7febb09-16175743.jpg" alt="1"></p>
<p>（2）：<br><img src="https://api2.mubu.com/v3/document_image/2b05b876-84ff-40ec-ae72-83b9d1104bda-16175743.jpg" alt="2"></p>
<p>指令周期参考信号图</p>
<p><img src="https://api2.mubu.com/v3/document_image/0d66f063-c178-43a9-96da-8820305d3b97-16175743.jpg" alt="图"></p>
<p>STO指令：<br><img src="https://api2.mubu.com/v3/document_image/2f428f2c-7149-47dc-964a-7c3f019fb45f-16175743.jpg" alt="sto"></p>
<h3 id="5-3时序产生器和控制方式"><a href="#5-3时序产生器和控制方式" class="headerlink" title="5.3时序产生器和控制方式"></a>5.3时序产生器和控制方式</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>时序 Timing</p>
<p>计算机以时序信号为基准完成协调动作</p>
<p>控制器分类：</p>
<ul>
<li>硬布线控制器<br>时序信号一般采用主状态周期-节拍电位-节拍脉冲三级体制。节拍电位的时间&#x3D;CPU周期的时间</li>
<li>微程序控制器<br>时序信号比较简单。一般采用节拍电位-节拍脉冲二级体制</li>
</ul>
<p>微程序控制器中<strong>时序信号产生器</strong>的组成：</p>
<ul>
<li>时钟源</li>
<li>环形脉冲发生器</li>
<li>节拍脉冲和读&#x2F;写时序的译码</li>
<li>启停控制逻辑</li>
</ul>
<p>框图：<br><img src="https://api2.mubu.com/v3/document_image/1fe83be4-8442-43f5-80b9-5d8d8ac87ef5-16175743.jpg" alt="kt"></p>
<h5 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h5><h5 id="环形脉冲发生器"><a href="#环形脉冲发生器" class="headerlink" title="环形脉冲发生器"></a>环形脉冲发生器</h5><ul>
<li>产生一组有序的间隔相等或不等的脉冲序列，以便通过译码电路来产生最后所需的节拍脉冲</li>
<li>为了在节拍脉冲上不带干扰毛刺，环形脉冲发生器通常采用<strong>循环移位寄存器</strong>形式</li>
</ul>
<h5 id="节拍脉冲和读写时序的译码"><a href="#节拍脉冲和读写时序的译码" class="headerlink" title="节拍脉冲和读写时序的译码"></a>节拍脉冲和读写时序的译码</h5><p>译码逻辑：<br>一种环形脉冲发生器：<br><img src="https://api2.mubu.com/v3/document_image/37b5b894-2b32-4972-97de-5ba56743e826-16175743.jpg" alt="图"></p>
<blockquote>
<p>关于D触发器：左边的SD端是清零端，右边的RD端是预置端（置1）（）二者都是低电平有效。<br>分析得，上图的电路状态是一个循环。<br>C1,C2,C3–&gt;<font color=blue>000</font>-&gt;100-&gt;110-&gt;111-&gt;<font color=blue>000</font></p>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/897c66d7-8382-4b42-a508-d879aa65766f-16175743.jpg" alt="t1-t4"></p>
<p>节拍电位与节拍脉冲时序关系图<br><img src="https://api2.mubu.com/v3/document_image/1f6a383c-dd98-4e7e-8ba7-c355e4cafd73-16175743.jpg" alt="y"></p>
<h5 id="启停控制逻辑"><a href="#启停控制逻辑" class="headerlink" title="启停控制逻辑"></a>启停控制逻辑</h5><p>启停控制逻辑<br>u机器一旦接通电源，就会自动产生原始的节拍脉冲信号T1°-T4°。但只有发出启动信号后，才允许时序产生器发出CPU工作所需的完整节拍脉冲</p>
<p>启动信号保证产生完整的CPU周期信号</p>
<p>启停控制逻辑</p>
<p><img src="https://api2.mubu.com/v3/document_image/0dadc9f0-48de-4861-99c1-3c110daaf712-16175743.jpg" alt="电路图"><br>当触发器Cr的Q端为“1”时，原始节拍脉冲和读写信号通过门电路发送出去，变成CPU真正需要的节拍脉冲信号和读写时序，反之，就关闭时序产生器.<br>T4信号取反做时钟信号的原因：<br>保证时序信号以T1,T2,T3,T4的顺序输出。</p>
<h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h4><h5 id="同步控制方式"><a href="#同步控制方式" class="headerlink" title="同步控制方式"></a>同步控制方式</h5><p>Def:在任何情况下，各指令在执行时所需的机器周期数和时钟周期数是固定的</p>
<p>实现方案：</p>
<ol>
<li>采用完全统一的机器周期执行不同的指令。简单指令会导致时间浪费</li>
<li>采用不定长机器周期，复杂指令采取延长机器周期的方法</li>
<li>中央控制与局部控制结合，上面俩结合</li>
</ol>
<h5 id="异步控制方式"><a href="#异步控制方式" class="headerlink" title="异步控制方式"></a>异步控制方式</h5><ol>
<li>每条指令，操作<strong>按需</strong>占用时间</li>
<li>不采用统一的时序信号，而是根据指令或者部件的具体情况而定。“应答”方式，没有时间上的浪费，但控制比较复杂.</li>
</ol>
<h5 id="联合控制方式"><a href="#联合控制方式" class="headerlink" title="联合控制方式"></a>联合控制方式</h5><p>同步和异步相结合</p>
<ol>
<li>大部分操作序列安排在固定的机器周期中，对某些时间难以确定的操作则采用“应答”信号作为本次操作的结束</li>
<li>机器周期的节拍脉冲数是固定的，但是各条指令的机器周期数不固定</li>
</ol>
<h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a><mark>微程序控制器</mark></h3><p>微程序设计技术是利用<strong>软件方法</strong>来<strong>设计硬件</strong>的一门技术<br>微程序控制器与硬布线控制器相比较，具有<strong>规整性、灵活性、可维护性</strong>等一系列优点</p>
<p>基本思想</p>
<ul>
<li>用多条微指令（即：一个微程序）解释每条指令的执行过程。全部的微程序有机地组合在一起，存储在控制存储器（只读存储器）中。</li>
<li>当机器运行时，一条一条地读出这些微指令，从而产生全机所需要的各种操作控制信号，使相应的部件执行特定的操作</li>
</ul>
<h4 id="微命令和微操作"><a href="#微命令和微操作" class="headerlink" title="微命令和微操作"></a>微命令和微操作</h4><p>计算机的构成</p>
<ul>
<li>控制部件–控制器</li>
<li>执行部件–运算器、存储器、外围设备</li>
</ul>
<p><strong>微命令</strong>－控制部件通过控制线向执行部件发出各种控制命令（<strong>即：控制信号</strong>）<br>微操作－执行部件接受微命令后所进行的特定操作</p>
<p>反馈信息<br>通常执行部件使用反馈线向控制部件报告操作情况，控制部件则根据执行部件的“状态”发出新的微命令。</p>
<p>分类：</p>
<ul>
<li>相容性操作：同时或在同一个CPU周期内可以并行执行的微操作</li>
<li>相斥性操作：不能同时或不能在同一个CPU周期内并行执行的微操作</li>
</ul>
<h4 id="微指令"><a href="#微指令" class="headerlink" title="微指令"></a>微指令</h4><ul>
<li>在机器的一个CPU周期中，一组实现一定操作功能的<strong>微命令的组合</strong>，构成一条微指令<br>或者说</li>
<li>用一条微指令对应一条机器指令的一个执行步骤</li>
<li>微指令需要具备的2个功能<ul>
<li>供一条机器指令的一个执行步骤所需要的控制信号，以实现该执行步骤的操作功能</li>
<li>提供读出下一条待用微指令的地址，以便自动有序地读出每一条微指令，解决机器指令执行步骤之间的正确的接续关系</li>
</ul>
</li>
</ul>
<h5 id="微指令基本格式"><a href="#微指令基本格式" class="headerlink" title="微指令基本格式"></a>微指令基本格式</h5><p><img src="https://api2.mubu.com/v3/document_image/383c97cf-53d9-4d5e-bfd6-2bd0436fcd2b-16175743.jpg" alt="tu"></p>
<h4 id="微程序控制器-1"><a href="#微程序控制器-1" class="headerlink" title="微程序控制器"></a>微程序控制器</h4><ul>
<li>控制存储器</li>
<li>微指令寄存器<ul>
<li>微地址寄存器</li>
<li>微命令寄存器</li>
</ul>
</li>
<li>地址转移逻辑</li>
</ul>
<p>原理框图：<br><img src="https://api2.mubu.com/v3/document_image/58a90eb4-a580-405a-ad0f-98de5b7bd62f-16175743.jpg" alt="tu"></p>
<h4 id="微程序的特点"><a href="#微程序的特点" class="headerlink" title="微程序的特点"></a>微程序的特点</h4><ul>
<li><p>一条<strong>机器指令是若干条微指令组成的序列</strong>来实现的</p>
</li>
<li><p>一条机器指令<strong>对应着一段微程序</strong>，而微程序的总和便可实现整个的指令系统</p>
</li>
<li><p>微程序设计可以很容易地在不同的微体系结构上实现相同的</p>
</li>
<li><p>以十进制加法指令操作码为地址，去查微地址映射部件得到微程序在控制存储器中的地址，就可以调出所需要的微程序（如上图中微程序地址为1010）</p>
</li>
<li><p>微地址映射部件是用ROM实现的，地址输入为指令寄存器IR的操作码，输出为该指令对应的微程序段的入口地址</p>
</li>
</ul>
<h4 id="微程序举例"><a href="#微程序举例" class="headerlink" title="微程序举例"></a>微程序举例</h4><p><a href="https://api2.mubu.com/v3/document_image/527b8a8b-2c78-4389-bead-b4b2fbf09e07-16175743.jpg">微程序举例，十进制BCD码加法</a></p>
<h4 id="微指令周期与CPU周期的关系"><a href="#微指令周期与CPU周期的关系" class="headerlink" title="微指令周期与CPU周期的关系"></a>微指令周期与CPU周期的关系</h4><p>微指令周期 &#x3D; 读出微指令的时间 + 执行该条微指令的时间</p>
<p>为了保证整个机器控制信号的同步，可以将一个微指令周期 时间设计得恰好和CPU周期时间相等</p>
<p><img src="https://api2.mubu.com/v3/document_image/59fd1ac9-7829-47ef-ade6-61b48707e9ea-16175743.jpg" alt="微指令周期与CPU周期的关系"></p>
<h4 id="机器指令与微指令的关系"><a href="#机器指令与微指令的关系" class="headerlink" title="机器指令与微指令的关系"></a>机器指令与微指令的关系</h4><p><img src="https://api2.mubu.com/v3/document_image/f617eec9-90f1-48ba-8330-46226f08b2af-16175743.jpg" alt="关系"></p>
<h3 id="5-4微程序设计技术"><a href="#5-4微程序设计技术" class="headerlink" title="5.4微程序设计技术"></a>5.4微程序设计技术</h3><h4 id="微命令编码"><a href="#微命令编码" class="headerlink" title="微命令编码"></a>微命令编码</h4><p>微指令操作控制字段的微命令表示方法可分为3类</p>
<ul>
<li><strong>直接表示</strong>法：操作控制字段中的每一位代表一个微命令</li>
<li><strong>直接编码</strong>表示法：<br>把一组<strong>相斥性</strong>的微命令信号组成一个小组(即一个字段) ，然后通过小组(字段）译码器对每一个微命令信号进行译码 ，译码输出作为操作控制信号<blockquote>
<p>编码表示法使微指令字的长度大大缩短。但由于增加译码电路，微程序的执行速度稍稍减慢编码表示法使用较</p>
</blockquote>
</li>
<li><strong>混合</strong>表示法：见图<br><img src="https://api2.mubu.com/v3/document_image/0bf4a4b1-ae5e-44c8-92d9-0614a2408d6b-16175743.jpg" alt="ru"></li>
</ul>
<p>在微指令中还可附设一个常数字段</p>
<ul>
<li>可作为操作数送入ALU运算</li>
<li>也可作为计数器初值用来控制微程序循环次数</li>
</ul>
<h4 id="微地址的形成方法"><a href="#微地址的形成方法" class="headerlink" title="微地址的形成方法"></a>微地址的形成方法</h4><p>产生后继微地址的方法</p>
<ul>
<li>计数器方式(类似PC)</li>
<li>多路转移方式(跳转)<ul>
<li>当微程序不产生分支时，后继微地址直接由微指令的顺序控制字段给出</li>
<li>当微程序出现分支时，有若干“候选”微地址可供选择：即按顺序控制字段P的“判别测试”和“状态条件”标志来选择其中一个微地址</li>
<li>“状态条件”有n位标志，可实现微程序2n路转移，且涉及微地址寄存器的n位</li>
</ul>
</li>
<li>由指令的操作码转换得到，典型方式为查表方式</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/8d5d9a41-8571-40d9-9b96-e223391e222e-16175743.jpg" alt="例子"></p>
<h4 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h4><ul>
<li>水平型微指令</li>
<li>竖直型微指令</li>
</ul>
<p>简单说，水平行比较长，上面那三种译码方式都是针对水平指令的，一次能定义并执行多个并行操作微命令。效率高，灵活性强，但基本别想凭肉眼看懂，因为每一位代表一个操作，然后每条指令就是微操作的组合（位的组合），然后最后写出来的微程序比较短，整体是个躺着的长方形（不恰当的比喻）。</p>
<p>竖直型指令就有点像经常见的指令了，有操作码，有源地址和目的地址。<br>每条指令完成的功能比较简单，所以最后写出来的微程序比较长，整体看就是个竖着的长方形。特别的，竖直型指令虽然完成的功能简单，这玩意儿执行时间还长。</p>
<h3 id="5-5硬连线控制器"><a href="#5-5硬连线控制器" class="headerlink" title="5.5硬连线控制器"></a>5.5硬连线控制器</h3><p>基本概念：<br><img src="https://api2.mubu.com/v3/document_image/97adce27-8881-477a-8751-ce093f4cb6a4-16175743.jpg" alt="j"></p>
<p>硬连线控制器原理框图：<br><img src="https://api2.mubu.com/v3/document_image/11d6c042-cf3a-4b9d-a329-937fc81f0065-16175743.jpg" alt="图"></p>
<p>写出以下控制信号的逻辑表达式：<br>例子：<br><img src="https://api2.mubu.com/v3/document_image/55d7ec59-90e7-4335-9d91-4f078eb0e28a-16175743.jpg" alt="例子"></p>
<p>另一个举例：<br>这里需要注意的是T信号的划分：<br><mark>一般一个微操作分配一个时钟周期，读写内存分配两个时钟周期</mark><br><img src="https://api2.mubu.com/v3/document_image/afbb828f-3d6b-4e56-b3af-618153c6d530-16175743.jpg" alt="例子"></p>
<h3 id="5-6流水CPU"><a href="#5-6流水CPU" class="headerlink" title="5.6流水CPU"></a>5.6流水CPU</h3><p>流水方式CPU：指令部件、指令队列、执行部件</p>
<ul>
<li>指令部件</li>
<li>指令队列：FIFO寄存器栈</li>
<li>执行部件：可以有多个采用流水线方式构成的算术逻辑部件构成，可以将定点运算部件和浮点运算部件分开</li>
</ul>
<p>几个缩写的含义：</p>
<ul>
<li>IF（Instruction Fetch取指）</li>
<li>ID（Instruction Decode指令译码）</li>
<li>EX（Execution执行）</li>
<li>WB（Write Back写回</li>
</ul>
<p>4级指令流水线<br><img src="https://api2.mubu.com/v3/document_image/e26adf24-76a8-422a-9bdf-c676e98102f3-16175743.jpg" alt="4"></p>
<p>几个概念：</p>
<p>线性流水线的时钟周期</p>
<p>$$<br>\tau&#x3D;\max {\tau_i}+\tau_1&#x3D;\tau+m+\tau_1;<br>$$</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记_chapter2</title>
    <url>/2022/03/23/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_chapter2/</url>
    <content><![CDATA[<h2 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h2><p>规格化表示：<br><img src="https://api2.mubu.com/v3/document_image/edff1550-2019-44d5-94b3-a8bca0ca4809-16175743.jpg" alt="规格化"></p>
<p>特殊的浮点数<br><img src="https://api2.mubu.com/v3/document_image/42891536-e62d-4cd9-b358-64b73d22d52e-16175743.jpg" alt="特殊的浮点数"></p>
<p>浮点数表示的范围<br><img src="https://api2.mubu.com/v3/document_image/1bca8a53-b91b-4811-b0f9-799f3261da15-16175743.jpg" alt="浮点数表示的范围"></p>
<p>小结：<br>对32位浮点数N：<br>◼ 若0 &lt; E &lt; 255，则<br>N ＝ (-1)s ×1.M ×2<br>E-127 ，规格化数表示<br>◼ 若E &#x3D; 0且M ＝ 0，则<br>N ＝ (-1)s 0，机器+0、-0表示<br>◼ 若E &#x3D; 0且M ≠ 0，则<br>N ＝ (-1)s × 0.M× 2<br>1-127 ，非规格化数表示<br>◼ 若E&#x3D; 255且M ＝ 0，则<br>N＝(-1)s∞（正无穷大，负无穷大）<br>◼ 若E &#x3D; 255且M ≠ 0，则<br>N ＝ NaN，非数NaN(Not a Number)</p>
<blockquote>
<p>十进制小数转二进制：<br>十进制的小数转换为二进制，主要是小数部分乘以2，取整数部分依次从左往右放在小数点后，直至小数点后为0。</p>
</blockquote>
<h2 id="ACSII码"><a href="#ACSII码" class="headerlink" title="ACSII码"></a>ACSII码</h2><p>数字：48（0011 0000）~ 57（0011 1001）   +10-1<br>大写字母：65（0100 0001）～90（0101 1010）   +26-1<br>小写字母：97（0110 0001）～122（0111 1010）   +26-1</p>
<h2 id="存储器中的字节序"><a href="#存储器中的字节序" class="headerlink" title="存储器中的字节序"></a>存储器中的字节序</h2><p>每个字节内部的顺序都是固定的，仅需考虑多个字节的字节间关系</p>
<ul>
<li>小端方式Little Endian<ul>
<li>低字节存放在小地址处，即低字节在前高字节后<br>x86处理器</li>
</ul>
</li>
<li>大端方式Big Endian<ul>
<li>低字节存放在大地址处，即高字节在前低字节后<br>SPARC处理器，IBM Power处理器</li>
</ul>
</li>
</ul>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p><img src="https://api2.mubu.com/v3/document_image/16483863477285a79.jpg" alt="证明补码减法"></p>
<h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>正溢：运算结果为正，且超出机器所能表示的范围<br>负溢：运算结果为负，且超出机器所能表示的范围<br><img src="https://api2.mubu.com/v3/document_image/32378a93-fd0e-418c-932b-209ba715160d-16175743.jpg" alt="整数溢出"></p>
<h3 id="小数溢出"><a href="#小数溢出" class="headerlink" title="小数溢出"></a>小数溢出</h3><p>上溢：结果的绝对值大于机器所能表示的最大绝对值（+∞，－∞）<br>（overflow）<br>下溢：结果的绝对值小于机器所能表示的最小绝对值 （ 机器零 ）<br>（underflow）<br><img src="https://api2.mubu.com/v3/document_image/f3691e63-d615-4caa-9043-dbb945ed07bc-16175743.jpg" alt="小数溢出"></p>
<h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><ol>
<li><p><strong>双符号位</strong>法，又称<strong>变形补码</strong>，或者模四补码<br> 双符号位的补码也遵循加法法则。<br> 在计算中：<br> 两个符号位均参加运算<br> 最高符号位上产生的进位要丢掉</p>
<p> 溢出检测规则：<br> ◆两数相加后，结果的符号位出现“01”或“10”两种情况时，表示发生溢出（也就是<strong>最高的两位异或</strong>）<br> ◆最高符号位永远表示结果的正确符号</p>
</li>
<li><p><strong>单符号位</strong>法<br> 溢出的逻辑表达式为<br> $V&#x3D;C_f⊕C_0$<br> $C_f$为符号位产生的进位，$C_0$为最高有效位产生的进位</p>
</li>
</ol>
<h2 id="定点乘法运算算法"><a href="#定点乘法运算算法" class="headerlink" title="定点乘法运算算法"></a>定点乘法运算算法</h2><h3 id="原码一位乘法运算"><a href="#原码一位乘法运算" class="headerlink" title="原码一位乘法运算"></a>原码一位乘法运算</h3><h3 id="无符号的阵列乘法"><a href="#无符号的阵列乘法" class="headerlink" title="无符号的阵列乘法"></a>无符号的阵列乘法</h3><h3 id="有符号的阵列乘法"><a href="#有符号的阵列乘法" class="headerlink" title="有符号的阵列乘法"></a>有符号的阵列乘法</h3><p>补码一位乘法运算（不要求）<br>原码两位乘法运算（不要求）<br>直接补码并行乘法（不要求）</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记_chapter3</title>
    <url>/2022/04/27/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_chapter3/</url>
    <content><![CDATA[<h2 id="3-1-存储器概述"><a href="#3-1-存储器概述" class="headerlink" title="3.1 存储器概述"></a>3.1 存储器概述</h2><ul>
<li><strong>易失性</strong>半导体存储器统称为RAM<ul>
<li>静态RAM（SRAM）</li>
<li>动态RAM（DRAM）</li>
</ul>
</li>
<li><strong>非易失性</strong>的半导体存储器统称为ROM<ul>
<li>掩膜ROM（MASK ROM）:出厂的时候就写好了，不能改了捏</li>
<li>可编程ROM（PROM）<ul>
<li>一次性可编程ROM（OTP ROM）</li>
<li>可擦除PROM（EPROM）<ul>
<li>紫外线擦除EPROM（UV EPROM）</li>
<li>电擦除EPROM（EEPROM，E2PROM）</li>
<li>闪速存储器（FLASH ROM)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>存储器的目标<ul>
<li>大容量</li>
<li>高速度</li>
<li>低价格</li>
</ul>
</li>
<li>现代计算机的层次存储器系统<ul>
<li>Register</li>
<li>On-Chip Cache</li>
<li>Second Level Cache(SRAM)</li>
<li>Main Memory(DRAM)</li>
<li>Secondary Storage(Disk)</li>
<li>Tertiary Stroage(Disk)</li>
</ul>
</li>
</ul>
<blockquote>
<p>其中，内存&#x3D;Cache+主存</p>
</blockquote>
<p>内存的主要技术指标</p>
<ul>
<li>访问时间TA：<br>从存储器接收到读写命令道信息被读出或写入完成所需的时间，取决于存储介质的物理特性和寻址部件的结构</li>
<li>存取周期TM：<br>在存储器连续读写过程中一次完整的存取操作所需的时间（CPU连续两次访问存储器的最小时间间隔）</li>
<li>功耗</li>
<li>可靠性</li>
</ul>
<p>主存储器的读写过程</p>
<ul>
<li>读过程:<ul>
<li>给出地址</li>
<li>给出片选与读命令</li>
<li>保存读出内容</li>
</ul>
</li>
<li>写过程:<ul>
<li>给出地址</li>
<li>给出片选与数据</li>
<li>给出写命令</li>
</ul>
</li>
</ul>
<h2 id="3-2-随机读写存储器"><a href="#3-2-随机读写存储器" class="headerlink" title="3.2 随机读写存储器"></a>3.2 随机读写存储器</h2><p>存储器芯片的基本结构</p>
<ul>
<li>地址线</li>
<li>数据线（双向）</li>
<li>片选信号</li>
<li>读写控制线</li>
</ul>
<p>n位存储器芯片的结构<br><img src="https://api2.mubu.com/v3/document_image/32de5b46-4a1e-44a0-9f79-07893d6352e0-16175743.jpg" alt="n位存储器芯片的结构"></p>
<h3 id="SRAM基本电路"><a href="#SRAM基本电路" class="headerlink" title="SRAM基本电路"></a>SRAM基本电路</h3><blockquote>
<p>关于MOS管：<br> <img src="https://api2.mubu.com/v3/document_image/9af0e8b2-247c-40d4-8668-44e85d9cc555-16175743.jpg" alt="MOS管"><br> 当G极电压大于导通电压时，DS导通，G极仅有电压而无电流。</p>
</blockquote>
<h4 id="SRAM读操作"><a href="#SRAM读操作" class="headerlink" title="SRAM读操作"></a>SRAM读操作</h4><p><img src="https://api2.mubu.com/v3/document_image/ca7d354f-54ce-4fbc-a7ff-68b180d76484-16175743.jpg" alt="读操作"></p>
<h4 id="SRAM写操作"><a href="#SRAM写操作" class="headerlink" title="SRAM写操作"></a>SRAM写操作</h4><p><img src="https://api2.mubu.com/v3/document_image/4f97314f-340d-414a-ad41-88b706d3ec3a-16175743.jpg" alt="写操作"></p>
<h4 id="SRAM存储器的结构"><a href="#SRAM存储器的结构" class="headerlink" title="SRAM存储器的结构"></a>SRAM存储器的结构</h4><p><img src="https://api2.mubu.com/v3/document_image/704b1a9d-4bdd-40b6-94e2-2bba8b20768a-16175743.jpg" alt="SRAM存储器的结构"></p>
<h4 id="SRAM实例"><a href="#SRAM实例" class="headerlink" title="SRAM实例"></a>SRAM实例</h4><p><img src="https://api2.mubu.com/v3/document_image/b63aa862-bd86-4a2d-bfb0-030536d5ccbd-16175743.jpg" alt="实例"></p>
<h4 id="字扩展-amp-位扩展"><a href="#字扩展-amp-位扩展" class="headerlink" title="字扩展&amp;位扩展"></a>字扩展&amp;位扩展</h4><p><a href="https://blog.csdn.net/qq1350975694/article/details/107290348">这位老哥</a>讲的不错，能看懂，就是容易记不住。</p>
<h3 id="动态存储器DRAM"><a href="#动态存储器DRAM" class="headerlink" title="动态存储器DRAM"></a>动态存储器DRAM</h3><p>可以减少晶体管的数目，但是存储的电荷会泄露，所以需要动态刷新电路。</p>
<h4 id="四管动态存储单元"><a href="#四管动态存储单元" class="headerlink" title="四管动态存储单元"></a>四管动态存储单元</h4><p>DRAM刷新是对一行进行刷新的。</p>
<h4 id="单管动态存储单元"><a href="#单管动态存储单元" class="headerlink" title="单管动态存储单元"></a>单管动态存储单元</h4><p><img src="https://api2.mubu.com/v3/document_image/392de6a0-3436-4afc-a57f-fcb955c5e5e7-16175743.jpg" alt="单管动态存储单元"><br>word line是字线，bit line是数据线</p>
<h4 id="DRAM写操作"><a href="#DRAM写操作" class="headerlink" title="DRAM写操作"></a>DRAM写操作</h4><ul>
<li>字线高电平，T导通<ul>
<li>写1: 数据线为高电平，通过T对C充电</li>
<li>写0: 数据线为低电平，C通过T放电<br><img src="https://api2.mubu.com/v3/document_image/3658afcf-ccf6-49fe-87a9-7dcf1007bd7c-16175743.jpg" alt="写操作"></li>
</ul>
</li>
</ul>
<h4 id="DRAM读操作-amp-刷新操作"><a href="#DRAM读操作-amp-刷新操作" class="headerlink" title="DRAM读操作&amp;刷新操作"></a>DRAM读操作&amp;刷新操作</h4><ul>
<li>数据线预充电至VDD&#x2F;2</li>
<li>当字线为高电平，T导通，若原来C充有电荷，则C放电使数据线电位小幅上升，经放大后读出为1；若原来C上无电荷，则C充电使数据线电位小幅下降，经放大器后读出为0。</li>
<li>单管DRAM单元的读出是破坏性的，在读出信息后要立即对单元进行“回写”，以恢复原信息。<br><img src="https://api2.mubu.com/v3/document_image/2c510ee9-446e-4aaf-adc4-a55cedbd7002-16175743.jpg" alt="读操作&amp;刷新操作"></li>
</ul>
<h3 id="DRAM和SRAM的比较"><a href="#DRAM和SRAM的比较" class="headerlink" title="DRAM和SRAM的比较"></a>DRAM和SRAM的比较</h3><ul>
<li>DRAM<ul>
<li>主存</li>
<li>电容+1晶体管</li>
<li>需要刷新（2~8ms）</li>
<li>读操作是破坏性的</li>
<li>密度高</li>
<li><font color=red>地址线分时复用</font>:管脚是稀缺资源，通常是行地址和列地址进行分时复用</li>
</ul>
</li>
<li>SRAM<ul>
<li>Cache</li>
<li>速度比DRAM快</li>
</ul>
</li>
</ul>
<h3 id="DRAM读时序"><a href="#DRAM读时序" class="headerlink" title="DRAM读时序"></a>DRAM读时序</h3><p><img src="https://api2.mubu.com/v3/document_image/4de50a3c-bb58-4609-ab18-1d9e66e6fdcc-16175743.jpg" alt="DRAM读时序"><br>OE_L是输出使能信号，WE_L是写使能信号，RAS_L是row 行地址有效，CAS_L是column 列地址有效。_L代表低电平有效。<br>OE_L可以在CAS之前或者之后有效，区别是是否读出一些垃圾数据。<br>了解即可<br><img src="https://api2.mubu.com/v3/document_image/9eeef8a0-7f7c-4e4e-8d6c-0b23c3b37721-16175743.jpg" alt="了解即可"></p>
<h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h3><p>刷新周期一般是几毫秒</p>
<h4 id="集中式刷新"><a href="#集中式刷新" class="headerlink" title="集中式刷新"></a>集中式刷新</h4><p>在整个刷新间隔里，前大半部分可以读写，后小半部分刷新。<br>在后小半部分里，CPU无法访问存储器，也就是不能执行指令，响应系统紧急事件。</p>
<h4 id="分散式刷新"><a href="#分散式刷新" class="headerlink" title="分散式刷新"></a>分散式刷新</h4><p>例如：某DRAM有1024行，若刷新周期为8ms，则必须在8ms内把所有1024行刷新一遍。<br>8000µs÷1024≈7.8µs，即每隔7.8µs刷新<strong>一行</strong>。<br>有点像时分复用。<br>需要一些相应的辅助电路，比如记录刷新到第几行了，以及一个额外的计时器etc.</p>
<p>两种常用的传递刷新信号的方式</p>
<ol>
<li>只用RAS刷新操作</li>
<li>CAS在RAS之前的刷新操作</li>
</ol>
<h3 id="DRAM控制器"><a href="#DRAM控制器" class="headerlink" title="DRAM控制器"></a>DRAM控制器</h3><!-- 长[这样]()，感觉不重要。 -->

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://api2.mubu.com/v3/document_image/7ac2c0db-93d3-4115-9163-c1426997f1b6-16175743.jpg" alt="例子"><br>4Mx8位指的是：<br>一片里面有4M，有8片。<br>所以8位是数据位。<br>1M是2的20次方。<br>4M是2的22次方。<br>也就是行列线一共有22条。<br>因为DRAM是行列地址分时复用，所以地址线仅11条。<br>这里的行地址线和列地址线不一定是一样多的，但是没说的情况下默认平分。</p>
<h3 id="其他的一些补充"><a href="#其他的一些补充" class="headerlink" title="其他的一些补充"></a>其他的一些补充</h3><ul>
<li><p>增强型的DRAM：EDRAM（Enhanced）<br>由于CPU的数据经常需要访问某个地址相邻地址的数据，加一个SRAM临时存储读出的这一行，可以加快读取速度。<br>在行地址不变的情况下，连续的变换列地址，称为Brust Mode，这种情况下的增强型DRAM读取速度尤其快。</p>
</li>
<li><p>SDRAM：同步DRAM<br>S：synchronous a.同步的<br>添加了一个时钟信号，让CPU和读写存储变成了一个同步的操作。<br>只在时钟的上升沿进行数据的读取<br>为了提升速率：<br>DDR：在上升下降沿都进行读取。<br>DDR2：外部时钟的频率提高一倍，也是在上升下降沿都进行读取。</p>
</li>
<li><p>CAS Latency 参数<br>列地址有效时候还要多久才能读取到数据，越小越好。</p>
</li>
<li><p>DRAM主存读&#x2F;写的正确性校验<br>为了提高DRAM存储器读写操作的正确性与可靠性，在写入m位数据的同时还需写入k位附加位，即写入的数据是经过纠错码编码的数据。</p>
</li>
</ul>
<h2 id="3-4-只读存储器和闪速存储器"><a href="#3-4-只读存储器和闪速存储器" class="headerlink" title="3.4 只读存储器和闪速存储器"></a>3.4 只读存储器和闪速存储器</h2><h3 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h3><p>Read Only Memory<br>没有易失性</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>掩膜ROM（MASK ROM）:出厂的时候就写好了，不能改了捏<br>可靠性高，便宜</li>
<li>可编程ROM（PROM）<ul>
<li>一次性可编程ROM（OTP ROM）<br>（双极型PROM，熔断型，PN结击穿型）</li>
<li>可擦除PROM（EPROM）<ul>
<li>紫外线擦除EPROM（UV EPROM）</li>
<li>电擦除EPROM（EEPROM，E2PROM）</li>
<li>闪速存储器（FLASH ROM）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="EPROM"><a href="#EPROM" class="headerlink" title="EPROM"></a>EPROM</h4><p>原理略<br>举例：<br><img src="https://api2.mubu.com/v3/document_image/7730146f-b3b1-401b-8db7-880d9e220254-16175743.jpg" alt="1"><br><img src="https://api2.mubu.com/v3/document_image/f545b500-4648-4e43-a869-349c29d89aca-16175743.jpg" alt="2"><br><img src="https://api2.mubu.com/v3/document_image/34f620ab-acab-433c-bc7e-ff7ef604db18-16175743.jpg" alt="3"></p>
<h4 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h4><p>与EPROM相比，集成度低（两个晶体管存一个单位），寿命长。</p>
<h3 id="闪速存储器"><a href="#闪速存储器" class="headerlink" title="闪速存储器"></a>闪速存储器</h3><p>闪速存储器FLASH是目前唯一的具有大容量、非易失性、低价格、可在线改写和较高速度几个特性共存的存储器。<br>之所以称为FLASH，是因为<strong>擦除速度快</strong>，擦除整个存储矩阵所花时间，与EEPROM擦除一个存储单元的时间相同。<br>FLASH具有<strong>非易失性</strong>，比SRAM成本低<br>但是擦写次数和速度都比DRAM差不少，故不能取代DRAM</p>
<p>闪存分为两类：</p>
<ol>
<li>NOR闪存</li>
<li>NAND闪存</li>
</ol>
<h4 id="NOR闪存"><a href="#NOR闪存" class="headerlink" title="NOR闪存"></a>NOR闪存</h4><ul>
<li>擦除写入时间比较长</li>
<li>有完整的地址&#x2F;数据接口，能<strong>随机存取</strong></li>
<li>存储容量比NAND小很多</li>
</ul>
<h4 id="NAND闪存"><a href="#NAND闪存" class="headerlink" title="NAND闪存"></a>NAND闪存</h4><ul>
<li>擦除写入时间比较快</li>
<li>与NOR闪存比较具有较高的密度和较低的位成本，10倍的擦除次数。</li>
<li>没有完整的地址&#x2F;数据接口，I&#x2F;O接口只允许<strong>顺序存取</strong>数据</li>
</ul>
<p>闪存特点：<br>可在线写入数据，具有ROM的非易失性<br>可以取代全部的UV EPROM和大部分的E$^2$PRO</p>
<p>闪存的主要用途：<br>存储监控程序、引导程序等基本不变或不经常改变的程序：可使用NOR闪存<br>保存掉电时需要保持的系统配置等不常改变的数据：可使用NOR闪存<br>固态盘：采用NAND闪存</p>
<h2 id="3-5-并行存储器"><a href="#3-5-并行存储器" class="headerlink" title="3.5 并行存储器"></a>3.5 并行存储器</h2><h3 id="双端口存储器"><a href="#双端口存储器" class="headerlink" title="双端口存储器"></a>双端口存储器</h3><p>DRRAM:dual port RAM<br>同一个存储器具有两组独立的控制线，地址线和数据线。<br>比其他的线多了一个忙线（busy line），作用是解决读写冲突。<br>实例：<br>IDT7133<br>容量为2K×16位SRAM<br><a href="https://api2.mubu.com/v3/document_image/df269406-2bbc-4477-af34-1a6e7c0a846a-16175743.jpg">功能方框图</a><br>当两个端口同时存取存储器同一存储单元时，便发生读写<br>冲突,为了解决读写冲突，设置了<span style="text-decoration:overline">BUSY</span>标志线</p>
<ul>
<li>由判断逻辑部件来决定对哪个端口优先进行读写操作，另<br>一个端口的BUSY标志有效，读写操作延迟执行。</li>
<li>判断逻辑部件的判断方式：<ol>
<li>CE判断：如果地址匹配且在CE之前有效，片上的控制逻辑在CEL和CER之间进行判断来选择端口</li>
<li>地址有效判断：如果CE在地址匹配之前变低，片上的控制逻辑在左、右地址间进行判断来选择端口</li>
</ol>
</li>
</ul>
<h3 id="多模块交叉存储器"><a href="#多模块交叉存储器" class="headerlink" title="多模块交叉存储器"></a>多模块交叉存储器</h3><p>各模块地址安排有2种方式</p>
<ul>
<li>顺序方式<br><img src="https://api2.mubu.com/v3/document_image/ff771aed-21ae-4267-8573-0ed40c1edfc5-16175743.jpg" alt="顺序方式"></li>
<li>交叉方式(Interleaving)也称为多通道方式<br><img src="https://api2.mubu.com/v3/document_image/62967547-6e6e-4d9a-afac-bc1503b863e8-16175743.jpg" alt="交叉模式"></li>
</ul>
<p>主存被分成4个独立、容量相同的模块M0&#x2F;M1&#x2F; M2&#x2F;M3<br><img src="https://api2.mubu.com/v3/document_image/b4df61d4-a217-4b4b-9adf-1f7509019ffe-16175743.jpg" alt="基本结构"></p>
<ol>
<li>每个模块均有自己的读写控制电路、地址寄存器和数据寄存器，<br>以相同的方式与CPU传送信息</li>
<li>CPU同时访问四个模块，由存储器控制部件控制它们分时使用<br>数据总线进行信息的传递（读取T相对于数据传递$\tau$要慢很多</li>
</ol>
<p><img src="https://api2.mubu.com/v3/document_image/6e562469-71e6-40fc-8571-0328990c5864-16175743.jpg" alt="读取模式"><br>假设模块字长等于数据总线宽度，且模块存取一个字的存储周期为T，总线传送周期为τ，存储器的交叉模块数为m<br>那么，m＝T&#x2F;τ被为交叉存取度，连续读取m个字所需的时间为t1&#x3D;T+(m-1)τ<br>对于顺序方式存储器，连续读取m个字所需的时间为t2&#x3D;mT</p>
<p>例子：<br><img src="https://api2.mubu.com/v3/document_image/e252126f-ed53-41c0-a0c2-bca3f9cf6bf1-16175743.jpg" alt="例子："><br>解答：<br><img src="https://api2.mubu.com/v3/document_image/16519072863582123.jpg" alt="解答："></p>
<p>零等待存取<br><img src="https://api2.mubu.com/v3/document_image/8bef93b1-f2ba-4efc-b643-78b5bc768899-16175743.jpg" alt="零等待存取"></p>
<h2 id="3-6-Cache存储器"><a href="#3-6-Cache存储器" class="headerlink" title="3.6 Cache存储器"></a>3.6 Cache存储器</h2><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>principle of locality，讨论的就是双重for循环取二维数组那个，执行速度的问题。</p>
<ul>
<li>时间局部性 temporal locality<br>在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用</li>
<li>空间局部性 spatial locality<br>在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在近期引用附近的一个内存位置</li>
</ul>
<h3 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h3><p><img src="https://api2.mubu.com/v3/document_image/ef2fd587-0459-41e2-be5c-8a2ba15b4eeb-16175743.jpg" alt="结构"></p>
<h3 id="高速缓存Cache-x2F-kaeʃ-x2F"><a href="#高速缓存Cache-x2F-kaeʃ-x2F" class="headerlink" title="高速缓存Cache&#x2F;kæʃ&#x2F;"></a>高速缓存Cache&#x2F;kæʃ&#x2F;</h3><p>Cache是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓存区域</p>
<ol>
<li>Cache通常采用高速SRAM来实现</li>
<li>利用局部性原理，在Cache中完成大多数访问，从而缩短平均访问时间</li>
<li>CPU和主存之间的速度差很大通常采用两级或多级Cache系统</li>
<li>全由硬件调度，对用户透明</li>
</ol>
<p>不同层次之间Cache<br><img src="https://api2.mubu.com/v3/document_image/f1187756-8075-42a9-b96a-ff42adf70110-16175743.jpg" alt="基本原理1"></p>
<p>Cache 命中与缺失<br><img src="https://api2.mubu.com/v3/document_image/abf3fed0-9cde-40f8-8dec-04015df1ae48-16175743.jpg" alt="命中与缺失"></p>
<blockquote>
<p>LRU :Least Recently Used最近最少使用</p>
</blockquote>
<p>Cache缺失类型</p>
<ol>
<li>冷启缺失&#x2F;义务缺失（Cold miss or Compulsory miss）<ul>
<li>当cache为空时就产生冷启缺失，比如刚开机</li>
</ul>
</li>
<li>冲突缺失（Conflict miss）<ul>
<li>层k+1的数据块通常只能映射到层k的有限位置上。尽管层k中cache足够大，但层k+1有多个数据块全都映射到层k的同一位置上，则产生冲突缺失</li>
</ul>
</li>
<li>容量缺失（Capacity miss）<ul>
<li>当活动的cache块的数量超过cache的容量就产生容量缺失</li>
</ul>
</li>
</ol>
<h3 id="内容可寻址CAM"><a href="#内容可寻址CAM" class="headerlink" title="内容可寻址CAM"></a>内容可寻址CAM</h3><p>（Content Addressable Memory）是一种用内容进行寻址的存储器。将一个输入数据项与存储的所有数据项同时进行比较，若存在匹配，输出该数据项对应的匹配信息（或地<br>址）。同时也能按地址进行读和写。</p>
<h3 id="主存和Cache的分块"><a href="#主存和Cache的分块" class="headerlink" title="主存和Cache的分块"></a>主存和Cache的分块</h3><p>主存和cache间以数据块为单位进行复制，为便于管理，将主存和cache都划分为大小相等的数据块（也称行）</p>
<p><img src="https://api2.mubu.com/v3/document_image/27912974-d4e5-482f-a56a-3210c8c23b3e-16175743.jpg" alt="主存&amp;cache容量"><br><img src="https://api2.mubu.com/v3/document_image/2c0711cb-fc8a-4b2a-92f4-3311f88ef522-16175743.jpg" alt="映射方法"><br>总的映射过程<br><img src="https://api2.mubu.com/v3/document_image/0c35d8b0-967a-47b2-82aa-776ab2d01ab9-16175743.jpg" alt="过程"></p>
<h3 id="主存与Cache的地址映射"><a href="#主存与Cache的地址映射" class="headerlink" title="主存与Cache的地址映射"></a><mark>主存与Cache的地址映射</mark></h3><ol>
<li>全相联映射（ Fully Associative Mapping）</li>
<li>直接映射（Direct Mapping）</li>
<li>组相联映射（Set Associative Mapping）</li>
</ol>
<h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><p><img src="https://api2.mubu.com/v3/document_image/2e922423-4875-4c5f-ab9f-08e313b59c6c-16175743.jpg" alt="1"><br><img src="https://api2.mubu.com/v3/document_image/93b3ef69-428b-4a6f-8942-587a10e2ec58-16175743.jpg" alt="2"></p>
<p>就是弄个表，其实就是前面那个<a href="#%E5%86%85%E5%AE%B9%E5%8F%AF%E5%AF%BB%E5%9D%80cam">内容可寻址CAM</a><br><img src="https://api2.mubu.com/v3/document_image/a56ec8fa-f145-4baa-9eda-82156e49e5b8-16175743.jpg" alt="示例"><br>例子：<br><img src="https://api2.mubu.com/v3/document_image/5d635f1b-e733-45ff-b34b-98a3fb66bda5-16175743.jpg" alt="例子："></p>
<h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p><img src="https://api2.mubu.com/v3/document_image/4737d462-58d4-4288-a61f-fd0484e904ef-16175743.jpg" alt="直接映射"><br>这也是能产生冲突缺失的情况</p>
<p>直接映射的Cache标签和行号<br><img src="https://api2.mubu.com/v3/document_image/e4592538-4dd4-48a3-8fef-294e7d40c57f-16175743.jpg" alt="直接映射的Cache标签和行号"><br>直接映射Cache的检索过程<br><img src="https://api2.mubu.com/v3/document_image/2c75c351-38df-41c4-a5b1-c032864a55e1-16175743.jpg" alt="检索过程"><br>示例<br><img src="https://api2.mubu.com/v3/document_image/cab14266-1809-4e39-aa54-937d06549bad-16175743.jpg" alt="示例"></p>
<h3 id="v路（v-way）组相联映射"><a href="#v路（v-way）组相联映射" class="headerlink" title="v路（v-way）组相联映射"></a>v路（v-way）组相联映射</h3><p><img src="https://api2.mubu.com/v3/document_image/f0e63664-1cde-42b8-b783-f5a3a0f306e6-16175743.jpg" alt="v路（v-way）组相联映射"><br><strong>主存块存放到哪个组是固定的，放在组内的哪一行是任意的</strong><br>检索过程<br><img src="https://api2.mubu.com/v3/document_image/6bd4d8f2-75ee-4e35-a527-c126b8b555cf-16175743.jpg" alt="jsgc"><br>2路组相联映射示例1<br><img src="https://api2.mubu.com/v3/document_image/7af08504-1981-4f84-88d6-2feee4d4cbaa-16175743.jpg" alt="shili"><br>2路组相联映射示例2<br><img src="https://api2.mubu.com/v3/document_image/c7af876a-6747-4241-b5f6-c398545c9385-16175743.jpg" alt="shili"></p>
<h2 id="wordtable"><a href="#wordtable" class="headerlink" title="wordtable"></a>wordtable</h2><blockquote>
<p>Interleaving 交叉模式<br> Compulsory a.必修做的强制的<br> CAM 内容可寻址存储器</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记_网络层</title>
    <url>/2022/05/17/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0_%E7%BD%91%E7%BB%9C%E5%B1%821/</url>
    <content><![CDATA[<h2 id="5-1网络层设计问题"><a href="#5-1网络层设计问题" class="headerlink" title="5.1网络层设计问题"></a>5.1网络层设计问题</h2><h2 id="5-2路由算法"><a href="#5-2路由算法" class="headerlink" title="5.2路由算法"></a>5.2路由算法</h2><h3 id="路由算法的职责"><a href="#路由算法的职责" class="headerlink" title="路由算法的职责"></a>路由算法的职责</h3><ol>
<li>负责决定一个到来的包应该被传输到哪条输出线路<br>如果子网内部使用数据报文，自从最好的路由上次被改变之后，对于每个数据包这个决定必须重新做。<br>如果子网用的是虚拟电路，路由决定会被做出仅当一个新的虚拟电路被建立之后。在这之后，数据包只是follow之前已经被建立的路由</li>
<li>转发&amp;路由</li>
</ol>
<h3 id="路由算法的目标"><a href="#路由算法的目标" class="headerlink" title="路由算法的目标"></a>路由算法的目标</h3><ol>
<li>正确</li>
<li>简单</li>
<li>健壮性</li>
<li>稳定性（抖动的问题）</li>
<li>公平性</li>
<li>最优性<ol>
<li>最小化包时延</li>
<li>最大化网络通量</li>
</ol>
</li>
</ol>
<h3 id="路由算法的分类"><a href="#路由算法的分类" class="headerlink" title="路由算法的分类"></a>路由算法的分类</h3><ol>
<li>static（静态的）<br>路由选择不会根据当前的拓扑和流量改变<br>线路断了也不会改变<br>就是路由器启动的时候下载到路由器里面的<blockquote>
<p>拓扑的变化：<br> 加&#x2F;减一条线路，</p>
</blockquote>
</li>
<li>adaptive 适应性的<br>随着 拓扑结构的变化，通常也包括traffic的变化 改变路由。<br>由于考虑traffic比较复杂，所以现在学的一般只考虑拓扑结构的变化。<br>拓扑结构的变化就是指的这个图上任何一个节点或者边发生变化，其他节点都能感受到。</li>
</ol>
<h3 id="最优化原则"><a href="#最优化原则" class="headerlink" title="最优化原则"></a>最优化原则</h3><p><img src="https://api2.mubu.com/v3/document_image/1f996d7b-76c8-4be2-8767-de89bb4c465e-16175743.jpg" alt="最优化"><br>如果J在I-&gt;K的最短路径上，显然，J-&gt;K的最短路径也是同样的route</p>
<h3 id="sink-tree"><a href="#sink-tree" class="headerlink" title="sink tree"></a>sink tree</h3><p>从所有的源到某个特定的的目的地的最优化的路由形成了一个根节点是目的地的树。<br>不含任何loop，所以每个包会被在有限跳内传输<br>routing 算法的目标：</p>
<ul>
<li>针对所有的router发现并使用sink tree</li>
<li>不用的router针对现有的拓扑结构可能有不同的理解，或者掌握的信息不一样<br><img src="https://api2.mubu.com/v3/document_image/56b996e5-cf09-4bd7-802c-f43c1b4ec12c-16175743.jpg" alt="sinktree"></li>
</ul>
<h3 id="最短路径路由（Shortest-Path-Router）"><a href="#最短路径路由（Shortest-Path-Router）" class="headerlink" title="最短路径路由（Shortest Path Router）"></a>最短路径路由（Shortest Path Router）</h3><ol>
<li>建立一个有向带权图</li>
<li>权值的方法：<ol>
<li>几跳就是几</li>
<li>地理上的千米距离</li>
<li>排队和传输时延，决定于时间</li>
<li>一个关于距离，带宽，平均traffic，交流开销，等等的函数</li>
</ol>
</li>
<li>Dijkstra算法（已知拓扑，计算是容易的，难的是构造拓扑）</li>
</ol>
<h3 id="Flooding-路由算法"><a href="#Flooding-路由算法" class="headerlink" title="Flooding 路由算法"></a>Flooding 路由算法</h3><ol>
<li>不需要网络拓扑信息</li>
<li>每个路由器将收到的包发往除了输入端口之外的所有线路</li>
</ol>
<p>可能遇到的问题：<br>产生超级超级多的包</p>
<p>措施：</p>
<ol>
<li>每个包的头有一个hop counter，每转发一次，计数器减一，计数器减小到0的时候，就discard</li>
<li>源在每个包里面放一个sequence number，每个router记录收到的最大的seq，来判断那些包已经收到过了</li>
<li>选择性的flooding<ol>
<li>每个router记录收到的数据item，在数据库里面</li>
<li>每个item有一个版本号</li>
<li>只有新的data item才会被flooded</li>
</ol>
</li>
</ol>
<p>特征：</p>
<ol>
<li>所有可能的路线都会被尝试<ol>
<li>非常滴鲁棒，适合用于部队内部通信这样的。</li>
</ol>
</li>
<li>至少一个包会采用最小</li>
<li>所有的节点都会被访问到</li>
</ol>
<h3 id="Distance-Vector-Routing：DV算法"><a href="#Distance-Vector-Routing：DV算法" class="headerlink" title="Distance Vector Routing：DV算法"></a>Distance Vector Routing：DV算法</h3><p>又叫贝尔曼·福特算法</p>
<ol>
<li>每个router维护一个表<ol>
<li>到每个目的地的已知最好的距离<ol>
<li>这里的distance可能是<strong>hops</strong>的数目，时延ms，etc.</li>
</ol>
</li>
<li>使用哪条line</li>
</ol>
</li>
<li>这个表会不断的通过跟邻居交换信息来update<ol>
<li>发送routing信息（distance，destination）<ol>
<li>周期性的发送</li>
<li>当表改变的时候</li>
</ol>
</li>
<li>接受routing信息<ol>
<li>如果收到了一个更好的route，就更新</li>
<li>refresh已经存在的routes（有个时戳，对应下面那个times out）</li>
</ol>
</li>
<li>如果某个item times out 了，就删除这一项</li>
</ol>
</li>
</ol>
<p>例子1：<br><img src="https://api2.mubu.com/v3/document_image/1832a33b-d231-44c8-9aa1-6664c35a5c61-16175743.jpg" alt="E1"></p>
<p>A I H K四列都是J收到的的邻居发的distance vector  </p>
<p>下面那个大括号是J到几个邻居的最新距离。<br>假如要计算J到D的距离<br>那就是看D-&gt;X-&gt;J的最短距离，X是J的几个邻居<br>X&#x3D;A:40+8<br>X&#x3D;I:27+10<br>X&#x3D;H:8+12<br>X&#x3D;K:24+6  </p>
<p>例子2：</p>
<blockquote>
<p>有时候无穷大认为是16</p>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/38282183-0872-4cf3-8343-e3beca5c7b8d-16175743.jpg" alt="E2"><br><img src="https://api2.mubu.com/v3/document_image/9b1baf0a-f80f-42b1-b12d-648ffea3f545-16175743.jpg" alt="E2-1"><br><img src="https://api2.mubu.com/v3/document_image/8e32db72-e676-4442-8949-f49f359f580b-16175743.jpg" alt="E2-2"><br><img src="https://api2.mubu.com/v3/document_image/779adf84-9aa6-4b69-80ed-5d9822fcac7c-16175743.jpg" alt="E2-3"><br><img src="https://api2.mubu.com/v3/document_image/02571fad-26d6-4173-87e7-1c531eb533f7-16175743.jpg" alt="E2-4"><br><img src="https://api2.mubu.com/v3/document_image/786d8b13-9f8e-4c40-81d0-b414ec279794-16175743.jpg" alt="E2-5"></p>
<p>可以发现，当网络规模不是特别大的时候，路由算法会收敛，也就是会稳定下来。</p>
<p>一个问题：<br>Count-to-infinity<br>计数到无穷<br><img src="https://api2.mubu.com/v3/document_image/70eca855-4644-45dd-966b-ef781afc9919-16175743.jpg" alt="cti"><br>（a）是正常的时候，从无到收敛的过程<br>（b）是稳定之后，A出现故障的时候，由于A故障了，所以B只能从C得到到A的距离，然后依次这样，一直扩散扩散，形成环路，而实际上A已经不能到达了。直到到达无穷（16）的时候，会认为不可达了。通过这个例子可以知道网络的规模不能太大。</p>
<p>另一个关于这个问题的说明：<br>初始：<br><img src="https://api2.mubu.com/v3/document_image/c9b4128c-4f24-422d-9d0c-98114a727f4e-16175743.jpg" alt="初始"><br>若干时间之后：<br><img src="https://api2.mubu.com/v3/document_image/cb4d204a-3e51-42b6-b6da-4bcbc184d1fb-16175743.jpg" alt="若干时间之后："></p>
<p>RIP:set infinity to 16<br>这个RIP是routing information protocol</p>
<p>可能出现的其他情况：<br><img src="https://api2.mubu.com/v3/document_image/1ccfc686-a470-4b0d-83f1-2442d4cfaf1f-16175743.jpg" alt="其他"></p>
<p>一个09考研的例子  没题目，好像是让写出路由<br><img src="https://api2.mubu.com/v3/document_image/925c7b0c-6669-45b8-a1c4-7872519d00ac-16175743.jpg" alt="例"></p>
<ul>
<li>diatance vector routing<ul>
<li>RIP协议</li>
<li>CIsco EIGRP协议</li>
</ul>
</li>
<li>一些问题：<ul>
<li>当X告诉Y它有一条路，Y不知道自己是不是在这条路里面</li>
<li>通过rumor构建路由</li>
</ul>
</li>
<li>Path Vector Routing PV算法</li>
</ul>
<h3 id="Link-State-Routing-：LS算法"><a href="#Link-State-Routing-：LS算法" class="headerlink" title="Link State Routing ：LS算法"></a>Link State Routing ：LS算法</h3><p>中文名叫 链路状态路由选择算法<br>LS算法：<br>每个路由器都要干下面这些事儿：</p>
<ol>
<li>发现它的neighbors，学到他们的网络地址，就是通过打招呼找到的。（A跟B说hi~这样）</li>
<li>按照统一的度量标准设置到自己邻居的distance或者cost</li>
<li>建立一个链路状态数据包(LSP:Link-state Packet)，显示它“学”到的所有信息</li>
<li>把这个包发给<strong>所有的</strong>路由器，用flooding扩散</li>
<li>计算到除自己以外每个router的距离</li>
</ol>
<h4 id="从邻居那里学一些信息"><a href="#从邻居那里学一些信息" class="headerlink" title="从邻居那里学一些信息"></a>从邻居那里学一些信息</h4><ol>
<li>HELLO包<br>广播网络broadcast network：使用广播报文<br>不是广播网络的：发unicast HELLO</li>
<li>邻居发一个reply告诉它自己是谁<br>Names (Route IDs) must be globally unique</li>
<li>简化拓扑<br>When two or more routers are connected by a LAN or other multi-access network</li>
</ol>
<h4 id="Artificial-Node"><a href="#Artificial-Node" class="headerlink" title="Artificial Node"></a>Artificial Node</h4><p>伪节点<br><img src="https://api2.mubu.com/v3/document_image/abf96ed0-62dd-4e68-bdcf-132664724d3d-16175743.jpg" alt="wjd"><br>这个N可以是A也可以是C，也可以是F，任选一个。假如选了A，那么A内部就可以有两个邻接矩阵。</p>
<h4 id="设置-Link-Cost"><a href="#设置-Link-Cost" class="headerlink" title="设置 Link Cost"></a>设置 Link Cost</h4><ul>
<li>The cost to each of its neighbors</li>
<li>The cost to reach neighbors can be set automatically</li>
<li>Configured by the network operator</li>
<li>Make the cost inversely proportional to the bandwidth of the link</li>
</ul>
<h4 id="构造链路状态数据包"><a href="#构造链路状态数据包" class="headerlink" title="构造链路状态数据包"></a>构造链路状态数据包</h4><p><img src="https://api2.mubu.com/v3/document_image/1a39d0fd-bbfa-4b21-9a32-9325e5f98aff-16175743.jpg" alt="LSP"></p>
<p>啥时候构造 LSP：</p>
<ol>
<li>周期性的构造</li>
<li>当“大事情”发生的时候构造一下<br>就比如是一个line或者neighbor going down了&#x2F;come back up了，或者显著的改变性质了</li>
</ol>
<h4 id="分发LSP"><a href="#分发LSP" class="headerlink" title="分发LSP"></a>分发LSP</h4><p>懒得翻译了<br><img src="https://api2.mubu.com/v3/document_image/ae9dc435-cb6a-4395-9893-9529dbad3971-16175743.jpg" alt="distribute"></p>
<h4 id="关于LSP"><a href="#关于LSP" class="headerlink" title="关于LSP"></a>关于LSP</h4><ul>
<li>sequence number<ul>
<li>新的LSP：向所有人转发</li>
<li>复制的LSP：discard</li>
<li>小于目前收到的最大的序列号：认为是废旧的</li>
<li>如果一个router down（关掉）了，然后又restart（重启）了，（这样可能导致版本低了）就拒绝（旧版本的）</li>
<li>如果序号wrap（回绕）了，具体的协议中是2^32次方个数，基本上用不完，可能需要100多年才能回绕</li>
<li>受损：因为是可靠传输，所以会重传</li>
</ul>
</li>
<li>age<ul>
<li>指的是LSP的存活时间</li>
<li>应用状态&#x2F;解决的问题<ul>
<li>如果路由器关了</li>
<li>如果路由器改变了它的routerid</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="LSP-flooding-算法的精巧-x2F-改进之处"><a href="#LSP-flooding-算法的精巧-x2F-改进之处" class="headerlink" title="LSP flooding 算法的精巧&#x2F;改进之处"></a>LSP flooding 算法的精巧&#x2F;改进之处</h4><p><img src="https://api2.mubu.com/v3/document_image/b97927b2-7246-4bae-9508-50b4d74362a0-16175743.jpg" alt="sdf"></p>
<h4 id="计算新的Route"><a href="#计算新的Route" class="headerlink" title="计算新的Route"></a>计算新的Route</h4><p>当一个router收集到了一整套的LSP，它就可以建立整个图了<br>然后运行迪杰斯特拉算法，算最短路径<br>计算结果就被扔到routing table里面  </p>
<p>一个例子</p>
<!-- 还没抄过来（ -->
<p><img src="https://api2.mubu.com/v3/document_image/a96a5f6b-ec04-405f-ae8a-53ac8967b566-16175743.jpg" alt="图1"><br><img src="https://api2.mubu.com/v3/document_image/2e9fdd3c-9238-434c-a947-ee2a75110d28-16175743.jpg" alt="图2"></p>
<h4 id="LSR的例子"><a href="#LSR的例子" class="headerlink" title="LSR的例子"></a>LSR的例子</h4><p>了解即可<br><img src="https://api2.mubu.com/v3/document_image/3dcbe875-82ec-458a-9270-0b2b43cbc0c6-16175743.jpg" alt="例子"></p>
<h3 id="Hierarchical-Routing-分层次的路由"><a href="#Hierarchical-Routing-分层次的路由" class="headerlink" title="Hierarchical Routing 分层次的路由"></a>Hierarchical Routing 分层次的路由</h3><p>简化路由表的例子：<br><img src="https://api2.mubu.com/v3/document_image/13296af2-2cea-4809-8140-bb2ed03a6062-16175743.jpg" alt="简化路由表"><br>就是把几个离得近的路由器划分成一个小组，然后抽象成原本的一个点</p>
<h2 id="5-3-Congestion-Control-算法"><a href="#5-3-Congestion-Control-算法" class="headerlink" title="5.3 Congestion Control 算法"></a>5.3 Congestion Control 算法</h2><p>congestion：拥塞<br>出现拥塞的原因：太多的traffic被提供，网络性能剧烈下降<br><img src="https://api2.mubu.com/v3/document_image/4da34490-29fa-4712-a50a-04b3e19d3a3a-16175743.jpg" alt="yongsai"><br>次要因素：突发流量与缓冲队列(太长&#x2F;太短)<br>慢CPU忙于维护操作，转发操作太慢导致线路容量浪费<br>弄很长的内存可行吗？不能完全解决了，因为排的队比较长，时间太长，超时了，数据就无效了。</p>
<h3 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h3><p>拥塞控制是一个<strong>全局的问题</strong><br>流量控制是<strong>2个站点之间的</strong>问题，是通过一些反馈信息减缓发送端的发送速度，从而使发送端的速度与接收端的接收或者处理速度相适配。</p>
<h3 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h3><p><img src="https://api2.mubu.com/v3/document_image/d37a41af-0644-44c7-b3d9-b8cfb6a777e3-16175743.jpg" alt="approach"></p>
<p>从左往右：<br>网络供给增加<br>流量感知路由<br>许可证的控制<br>流量的限制&#x2F;调节<br>Load shedding 甩负荷</p>
<h3 id="Traffic-aware-Routing"><a href="#Traffic-aware-Routing" class="headerlink" title="Traffic-aware Routing"></a>Traffic-aware Routing</h3><p>有一些危险：<br>routing 表可能会剧烈的震荡，当两部分之间有两条类似的线路时</p>
<h3 id="Admission-Control-准入控制"><a href="#Admission-Control-准入控制" class="headerlink" title="Admission Control 准入控制"></a>Admission Control 准入控制</h3><p>在<strong>虚电路</strong>中广泛被使用<br>如果网络拥塞了，就不让建立新的虚电路<br>traffic的描述：通过rate和shape来描述<br>shape有两种：leaky bucket，token bucket  </p>
<h3 id="Traffic-Throttling-流量限制"><a href="#Traffic-Throttling-流量限制" class="headerlink" title="Traffic Throttling 流量限制"></a>Traffic Throttling 流量限制</h3><!-- 9：01 ppt66页-->
<p>当即将发生拥塞的时候，网络告诉sender节流。<br>（有趣的是这里的“网络”指的是路由器，能“告诉”的只有路由器了）  </p>
<ul>
<li>路由器需要决定什么时候拥塞正在迫近，理想情况下是在拥塞到来之前就判定</li>
<li>一般根据下面这些来判定：<ul>
<li>输出线路的利用率</li>
<li>队列的长度</li>
<li>现在丢包的数量</li>
<li>算平均值的方法：<br> EWMA：Exponentially Weighted Moving Average<br> $$d_{new}&#x3D;\alpha d_{old}+(1-\alpha)s$$<br> 上式中,s是当前的量，阿尔法是一个系数，一般取0.8</li>
</ul>
</li>
<li>路由器需要<strong>周期性的</strong>向导致拥塞的sender发送反馈信息<ul>
<li>Choke packets</li>
<li>ECN</li>
<li>Hop-by-Hop backpressure</li>
</ul>
</li>
</ul>
<h4 id="Choke-packets-抑制分组"><a href="#Choke-packets-抑制分组" class="headerlink" title="Choke packets 抑制分组"></a>Choke packets 抑制分组</h4><p>路由器选择一个在拥塞线路上发送的分组（拥塞分组），然后<strong>给源</strong>发送一个choke packet<br>（internet source quech message），让源端降速的一个消息</p>
<h4 id="ECN（Explicit-Congestion-Notification）"><a href="#ECN（Explicit-Congestion-Notification）" class="headerlink" title="ECN（Explicit Congestion Notification）"></a>ECN（Explicit Congestion Notification）</h4><p>显式的拥塞通知<br>（其实上面那个也算显式的）</p>
<ul>
<li>路由器对每个packet加tag，来标记它<strong>沿途有</strong>拥塞</li>
<li>当网络传输这个packet的时候，destination可以发现这个标记的拥塞，然后在回复的时候告诉sender（有另外一个可以打tag的bit位，reply的时候给打上）</li>
<li>sender就像之前一样，节流了。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/5df7da5e-9fa5-48a0-a6dc-3c7c92fc74e0-16175743.jpg" alt="图示"></p>
<h4 id="隐式的拥塞通知"><a href="#隐式的拥塞通知" class="headerlink" title="隐式的拥塞通知"></a>隐式的拥塞通知</h4><p>当一个包经过了拥塞，就丢掉它，这样sender就会超时，而且本身网络的错误是比较少的，这样sender就会节流。</p>
<h4 id="Hop-by-Hop-Choke-Packets"><a href="#Hop-by-Hop-Choke-Packets" class="headerlink" title="Hop-by-Hop Choke Packets"></a>Hop-by-Hop Choke Packets</h4><p>没听</p>
<p>问题：<br>解决：  </p>
<p>它可以很快的把流量降下来</p>
<h3 id="Loading-Shedding"><a href="#Loading-Shedding" class="headerlink" title="Loading Shedding"></a>Loading Shedding</h3><p>当router已经满了，就扔掉它们</p>
<p>Polices：</p>
<ul>
<li>Wine&amp;Milk<ul>
<li>对应File transfer和multimedia</li>
</ul>
</li>
<li>需要senders的配合</li>
<li>包的优先级<ul>
<li>视频压缩算法，重要的包打上tag，尽量保重点</li>
<li>允许主机超过协议说好的带宽，但是超出的部分标上比较低的优先级</li>
</ul>
</li>
</ul>
<p>RED（random early detection）<br>随机早期检测</p>
<ul>
<li>在网络情况没有变成没有希望的时候就开始扔包</li>
<li>router如何让source知道出现了问题呢？<ul>
<li>发一个choke包</li>
<li>丢掉选出来的包</li>
</ul>
</li>
<li>sources 降低发送速率</li>
</ul>
<p>ECN&amp;RED</p>
<ul>
<li>RED 在剩余缓存空间到达临界值（不一定满）的时候就开始扔包，而ECN只在路由器的buffer满了的时候才会丢包。</li>
<li>ECN 是通常更愿意选择的, 它显示的产生一个拥塞信号 rather than as a loss; 当主机不能接收显示的信号时，RED 就派上用场了。</li>
</ul>
<h2 id="5-4-QOS"><a href="#5-4-QOS" class="headerlink" title="5.4 QOS"></a>5.4 QOS</h2><ul>
<li>Reliability</li>
<li>Delay</li>
<li>Jitter 抖动</li>
<li>Bandwidth</li>
</ul>
<p>一些应用对上述几个标准的要求：<br><img src="https://api2.mubu.com/v3/document_image/da6848db-edd8-4cf5-b0c7-e44057adaef5-16175743.jpg" alt="需求"></p>
<h3 id="Traffic-Shaping"><a href="#Traffic-Shaping" class="headerlink" title="Traffic Shaping"></a>Traffic Shaping</h3><p>需要解决的问题：<br>主机发送的数据包是不规律的，对网络不友好，可能产生拥塞  </p>
<p>SLA:服务等级的约定（Service Level Agreement）<br>Between the user and the subnet</p>
<ul>
<li>The user: traffic shaping reduces congestion and helps carrier live up to its promise</li>
<li>The carrier: traffic policing<br>(CAR: Committed Access Rate)</li>
</ul>
<p>Traffic shaping：</p>
<ul>
<li>Regulate the average rate and burstiness of data transmission, smooth out the traffic</li>
</ul>
<p>Traffic Policing：</p>
<ul>
<li>Monitoring a traffic flow</li>
<li>Packets in excess of the agreed pattern might be dropped or marked as having lower priority</li>
</ul>
<h3 id="The-Bucket-Algorithm"><a href="#The-Bucket-Algorithm" class="headerlink" title="The Bucket Algorithm"></a>The Bucket Algorithm</h3><p><img src="https://api2.mubu.com/v3/document_image/03268813-0970-46e7-ae2b-a30b2c687aeb-16175743.jpg" alt="桶"></p>
<h4 id="leaky-bucket"><a href="#leaky-bucket" class="headerlink" title="leaky bucket"></a>leaky bucket</h4><p>桶里面攒的是数据，固定速率，<strong>平缓</strong>的发送，减少拥塞的机会。</p>
<h4 id="token-bucket"><a href="#token-bucket" class="headerlink" title="token bucket"></a>token bucket</h4><p>桶里面攒的不是数据，而是一堆<strong>令牌</strong>。相当于是有段时间没发送，然后攒了一堆令牌，然后突然有大量数据一下来了，就可以一下子发挺多。</p>
<p>token bucket algorithm</p>
<p><img src="https://api2.mubu.com/v3/document_image/8015024c-8d10-4347-a49b-f8efa474b6c2-16175743.jpg" alt="几张图"><br>这个图里面，每行是一组。<br>最后一组，令牌桶的容量是0，所以就相当于是漏桶。</p>
<p>几个关键参数：</p>
<p>S：burst length ，单位是sec，突发时间<br>B：，单位是byte，令牌桶的容量<br>R：，byte&#x2F;sec，令牌到达的速度  </p>
<p>最大的output速度：M ，单位是byte&#x2F;sec</p>
<p>$$<br>   B+RS&#x3D;MS<br>$$<br>$$<br>   S&#x3D;B&#x2F;(M-R)<br>$$</p>
<p>举个例子：<br><img src="https://api2.mubu.com/v3/document_image/cb3bfe9f-3804-4aae-9f14-b97affcc1a9a-16175743.jpg" alt="例子"></p>
<p>另一个例子：</p>
<p>突发速率为10Mbps的一台主机通过一个令牌桶进行流量调整。令牌桶的令牌到达速率为2Mbps，令牌桶的初始容量为8Mb。请问该主机以10Mbps速率可以传输多长时间？</p>
<p>相当于求S<br>$$<br>   S&#x3D;B&#x2F;(M-R)&#x3D;1*8Mbits&#x2F;(10-2)&#x3D;1s<br>$$</p>
<h4 id="Packet-Scheduling-分组调度"><a href="#Packet-Scheduling-分组调度" class="headerlink" title="Packet Scheduling  分组调度"></a>Packet Scheduling  分组调度</h4><p>简单了解即可\</p>
<p>算法：</p>
<ul>
<li>FIFO，（FCFS），tail drop 先来先服务（out）</li>
<li>RED，讲过，随机早期检测，隐式的拥塞控制，扔包。</li>
<li>FQ:fair queue，公平队列</li>
</ul>
<p>Round-robin Fair Queueing</p>
<p><a href="https://api2.mubu.com/v3/document_image/bc9b9f80-9e04-41f0-95e4-1365c363a956-16175743.jpg">循环调度</a><br>就轮着拿包，问题在于数据包的大小不一样，包小的就吃亏了。</p>
<p>WFQ: Weighted Fair Queueing</p>
<p><a href="https://api2.mubu.com/v3/document_image/ab416ed4-692e-410c-9c9c-27a10444e99d-16175743.jpg">WFQ</a></p>
<p>还有一种叫PQ：优先级队列<br>优先级高的先发送。</p>
<h2 id="5-5-Internetworking"><a href="#5-5-Internetworking" class="headerlink" title="5.5 Internetworking"></a>5.5 Internetworking</h2><h3 id="网络不同在哪？"><a href="#网络不同在哪？" class="headerlink" title="网络不同在哪？"></a>网络不同在哪？</h3><p><img src="https://api2.mubu.com/v3/document_image/388f7267-9836-4e76-88b9-3bdae17dd795-16175743.jpg" alt="differ"></p>
<p>不同的网络进行互联：</p>
<ol>
<li>用一种设备，转换一种网络到另一种网络，适用于网络种类比较少的情况</li>
<li>在不同网络的上面加一个层次，在这一层进行转换，是目前ip网络选择的方案<br>俩人弄的这个，搞到了图灵奖：Vinton Cerf, Robert Kahn 1974, Turing Award 2004</li>
</ol>
<h3 id="不同网络是如何进行互联的呢？"><a href="#不同网络是如何进行互联的呢？" class="headerlink" title="不同网络是如何进行互联的呢？"></a>不同网络是如何进行互联的呢？</h3><p><img src="https://api2.mubu.com/v3/document_image/4a8a2b46-e403-481b-9df4-3053128597b6-16175743.jpg" alt="图片"></p>
<p>网桥&amp;路由器</p>
<h3 id="Tunneling隧道"><a href="#Tunneling隧道" class="headerlink" title="Tunneling隧道"></a>Tunneling隧道</h3><p><img src="https://api2.mubu.com/v3/document_image/0a08d72e-f114-44cb-b22f-1b02ad0c32f6-16175743.jpg" alt="tunneling"><br>vpn就是这个道理。</p>
<h3 id="互联网络的路由"><a href="#互联网络的路由" class="headerlink" title="互联网络的路由"></a>互联网络的路由</h3><p>路由器看作顶点，网络看作路由。<br>内部网关协议 LS,DV<br>外部网关协议 PV</p>
<h3 id="MTU-最大传输单元"><a href="#MTU-最大传输单元" class="headerlink" title="MTU 最大传输单元"></a>MTU 最大传输单元</h3><p>maximum transmission unit</p>
<p><img src="https://api2.mubu.com/v3/document_image/f79652c4-50fe-44da-8727-213094823a7f-16175743.jpg" alt="数据包分段"></p>
<p>MTU是一个<strong>网络内部</strong>允许（用户）传输的最大尺寸  </p>
<p>Fragmentation 分片</p>
<p>来了个大的数据包我就切成小的碎片。</p>
<ol>
<li>透明<strong>transparent</strong>分片，网络里的透明就是看不见的意思，简单来说，透明分片就是进入一个网络的时候切片，出去的时候再组装回去。<br>但透明分片太复杂了，因为每次都得这么倒腾一回，而且每个数据包都必须到达同一个路由器出口。<br>Recombination occurs at the exit gateway (ATM)</li>
<li>非透明<strong>nontransparent</strong>分片，避免在任何一个路由器上重新组合。每个小分段都被当做一个完整的数据包来对待，只有到了目标主机才进行组合。<br>Recombination occurs only at the destination host (IP)<br>但是这个的问题在于，任何一个碎片丢了，目的端主机就装不回去了。</li>
</ol>
<p>IP协议是这么干的<br><img src="https://api2.mubu.com/v3/document_image/ff4ef6ff-885e-4c17-9760-7be8a054293e-16175743.jpg" alt="IP 分组命名"><br>头的中间那个东西是一个序号标识，就代表我这一个分段里，对应到原始包里，第一个字节前面有多少字节，拿（b）举例，I字节前面有8个字节，所以写8.</p>
<h4 id="path-MTU-discovering的策略"><a href="#path-MTU-discovering的策略" class="headerlink" title="path MTU discovering的策略"></a>path MTU discovering的策略</h4><p>就是不断尝试，找到这一条路由能发送的最大的MTU，就是向下兼容，找到最小的口。<br><img src="https://api2.mubu.com/v3/document_image/69e1313a-a225-4d94-a438-d665e72ac930-16175743.jpg" alt="path"></p>
<h2 id="5-6-The-Network-Layer-in-the-Internet"><a href="#5-6-The-Network-Layer-in-the-Internet" class="headerlink" title="5.6 The Network Layer in the Internet"></a>5.6 The Network Layer in the Internet</h2><p>其实就是ip<br>这里谈的就是<a href="#%E7%BD%91%E7%BB%9C%E4%B8%8D%E5%90%8C%E5%9C%A8%E5%93%AA%EF%BC%9F">不同网络进行互联</a>里面的第二个</p>
<h3 id="10大通用设计原则（RFC文档）"><a href="#10大通用设计原则（RFC文档）" class="headerlink" title="10大通用设计原则（RFC文档）"></a>10大通用设计原则（RFC文档）</h3><p>由重要到不重要<br><img src="https://api2.mubu.com/v3/document_image/0c103f9e-0077-4b76-9e77-2f34f06336c3-16175743.jpg" alt="原则"></p>
<h3 id="IPV4协议"><a href="#IPV4协议" class="headerlink" title="IPV4协议"></a>IPV4协议</h3><p><mark>（各个字段的作用&#x2F;含义是要掌握的）</mark></p>
<p><img src="https://api2.mubu.com/v3/document_image/28d88ffa-961e-4848-bd87-89f72c438a34-16175743.jpg" alt="字段"></p>
<p><a href="https://api2.mubu.com/v3/document_image/1653290130860975a.jpg">图片1</a></p>
<p><a href="https://api2.mubu.com/v3/document_image/7b21e493-d5e7-4a54-9235-3283a7ed1e39-16175743.jpg">图片2</a></p>
<p>下面是一些option的功能：<br><img src="https://api2.mubu.com/v3/document_image/60a00c2e-65d7-44b2-90dd-d3d38764009b-16175743.jpg" alt="一些option"></p>
<h3 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h3><p><img src="https://api2.mubu.com/v3/document_image/b02ef65c-9295-469e-87d0-6a163a5baa76-16175743.jpg" alt="dizhi"></p>
<p>地址分为5类，其中ABC三种是给用户设备用的，其余的是特定的地址，不是给用户用的。<br>A B C:unioncast，<br>D：分组转发，multicast<br>E: broadcast  </p>
<p>一些特殊的地址：<br><img src="https://api2.mubu.com/v3/document_image/c391e25c-6d9d-4ec6-a2ee-6be453d5e3ef-16175743.jpg" alt="special"></p>
<p>全0：本机地址，我不知道我自己的地址，就全写0，一段时间之后，网上的服务器会给分配一个地址<br>network 全0：本网络的地址<br>全1：<strong>本地网络</strong>的广播<br>network+全1：<strong>远程的某个网络</strong>的广播<br>127+其他的任何东西：比如127.0.0.1，指的是本机的地址。<br>查看本地的ip路由表：netstat -rn<br>还有一共ipconfig 忘了是干啥的了。<br><strong>本地的计算机还是有路由表的</strong>。</p>
<h4 id="prefix-前缀"><a href="#prefix-前缀" class="headerlink" title="prefix:前缀"></a>prefix:前缀</h4><p>两种表示方法，表示网络号的位数</p>
<ol>
<li>128.208.0.0&#x2F;24 (prefix length)<br>代表前24位是网络号</li>
<li>128.208.0.0&#x2F;255.255.255.0 (netmask)这个东西就叫掩码<br>也代表前24位是网络号，具体实现是做与运算<br><img src="https://api2.mubu.com/v3/document_image/e9ab6305-179a-4223-bf8b-e5a56a6b8e16-16175743.jpg" alt="tup "></li>
</ol>
<p>两种方法的对应关系：<br><img src="https://api2.mubu.com/v3/document_image/c64b92f1-7672-47cf-ac59-31551f51cfa9-16175743.jpg" alt="关系"></p>
<h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>有点像指令地址的划分，但又不是平均分的。<br>它是先一分为2，然后把其中一份再一分为2…..这样，根据$log_2(需要的地址数目)向上取整$，来决定怎么划分。<br>就是一个学校有一个网络号，然后拿出几个bit来标记分给不同的院系来使用。<br><img src="https://api2.mubu.com/v3/document_image/6b64d790-7ed2-46a2-b312-2473c2000476-16175743.jpg" alt="这样的"></p>
<p><img src="https://api2.mubu.com/v3/document_image/3cfc998d-0a82-4d16-bf43-0377207fbfec-16175743.jpg" alt="一个例子"></p>
<p>就有点像切西瓜这样，先切一半，然后对其中一半再切。<br>由于全0全1基本不用，所以一般可用地址的数目要-2。<br>比如 8位，$2^8$个不同的数，但是只有$2^8-2$个有效地址。<br>然后可用的地址范围，拿这道题里面的LAN1来说，写1~95是不对的，因为划分范围是7位数的地址，满足大于95，它不一定是连续的，可以这一个用了，下一个不用这样，地址范围是$2^7-2$，然后写可用范围就是</p>
<p>$$<br>   192.168.1.1~192.168.1.126<br>$$</p>
<h4 id="CIDR——无类域间路由（子网划分的逆）"><a href="#CIDR——无类域间路由（子网划分的逆）" class="headerlink" title="CIDR——无类域间路由（子网划分的逆）"></a>CIDR——无类域间路由（子网划分的逆）</h4><p>Route aggregation：路由聚合</p>
<p>多条路由汇聚成一条路由，跟子网划分是完全相反的一个过程。使得路由表长度减少。</p>
<p>而且还比子网划分要简单，就找出来这几个路由的前面多少位是一样的就行了（</p>
<p><img src="https://api2.mubu.com/v3/document_image/d286b872-4f74-4321-a90b-5ae139cce7bf-16175743.jpg" alt="聚合"></p>
<p>但是一个问题是，右边的那几个地址没完全用完，如果不幸出现了下图状况：</p>
<p><img src="https://api2.mubu.com/v3/document_image/821de0b4-2ab4-4747-9b64-55b16c4dc506-16175743.jpg" alt="状况"></p>
<p>就本来应该去san francisco 的就被发到lodon去了。<br>所以路由器匹配的一个基本原则就是<font color=red>“Longest matching prefix routing”</font>最长前缀匹配原则。</p>
<h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>一个array包括[IP address, netmask, outgoing line, Next hop]</p>
<p>扫描路由表：</p>
<ol>
<li>netmask 掩码和目的地址做与运算，然后到表里匹配。</li>
<li>很可能多个都匹配，原则是最长匹配（longest mask）</li>
</ol>
<p>09年一个题<br><img src="https://api2.mubu.com/v3/document_image/47634218-05fb-4475-a67d-a1fb3917824b-16175743.jpg" alt="09年一个题"></p>
<p>根据已知路由表进行路由选择：</p>
<p><img src="https://api2.mubu.com/v3/document_image/79b358f5-fe0d-4082-8ba5-74821d3c3da7-16175743.jpg" alt="route选择"></p>
<h2 id="NAT-Network-address-translation"><a href="#NAT-Network-address-translation" class="headerlink" title="NAT(Network address translation)"></a>NAT(Network address translation)</h2><p>是为了解决ip地址不够用的速战速决的一个临时方法。<br><img src="https://api2.mubu.com/v3/document_image/a078a0c3-e306-4e19-a1c2-2825627247e5-16175743.jpg" alt="nat"><br><img src="https://api2.mubu.com/v3/document_image/a72a44f2-47f8-4492-89a6-45fd94fcc32f-16175743.jpg" alt="nat2"></p>
<h2 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h2><p>128位地址，换算成16字节，可以说是永远用不完了。<br>IPV6的固定头：<br><img src="https://api2.mubu.com/v3/document_image/27efd199-d436-4582-923c-987f0cb77fa0-16175743.jpg" alt="ipv6头"><br><img src="https://api2.mubu.com/v3/document_image/53dd55cf-ad4a-4d45-9329-4ef1112ca503-16175743.jpg" alt="头"><br><img src="https://api2.mubu.com/v3/document_image/9039cc76-2ef8-4701-bd80-1027aa81a849-16175743.jpg" alt="解释"></p>
<p>没有checksum字段了。没有protocol字段了。<br><img src="https://api2.mubu.com/v3/document_image/20074302-05da-4145-8c74-0e28b8cdf64a-16175743.jpg" alt=" "><br>虽然头部精简了很多，但是地址太长了。<br>IPV6还有扩展头，ppt134<br><img src="https://api2.mubu.com/v3/document_image/0c153a46-407e-42c9-bba0-f097b30a8243-16175743.jpg" alt="这样"></p>
<p>IPV6的地址：<br>IPV4是点分16进制，IPV6叫冒分16进制表示法，两个字节一组，分8组。<br><img src="https://api2.mubu.com/v3/document_image/6aa3c2ea-4013-4c3a-9403-18319c9b0003-16175743.jpg" alt="j"><br>下面是3种简化的表示方法。<br>最后那个是v4地址转换成v6地址的方法，前面全0</p>
<h2 id="Internet-控制协议"><a href="#Internet-控制协议" class="headerlink" title="Internet 控制协议"></a>Internet 控制协议</h2><h3 id="ICMP-Internet-Control-Message-Protocol"><a href="#ICMP-Internet-Control-Message-Protocol" class="headerlink" title="ICMP (Internet Control Message Protocol)"></a>ICMP (Internet Control Message Protocol)</h3><p>互联网控制消息协议<br>封装在IP packet里面<br>当路由器处理一个数据报出现了意外，可以通过ICMP向源端报告有关事件<br><img src="https://api2.mubu.com/v3/document_image/8089eea0-c411-4589-92d1-39a33fd3aeb8-16175743.jpg" alt="1"></p>
<p>这里的回显ECHO和回显应答其实就是ping。所以ping是通过ICMP工作的。</p>
<p>关于Trace route<br><img src="https://api2.mubu.com/v3/document_image/abce1be7-0bb5-4de3-9d8d-1f240fd860e0-16175743.jpg" alt=" "></p>
<h3 id="ARP-Address-Resolution-Protocol"><a href="#ARP-Address-Resolution-Protocol" class="headerlink" title="ARP Address Resolution Protocol"></a>ARP Address Resolution Protocol</h3><p>地址解析协议<br>需要ARP的原因：<br><img src="https://api2.mubu.com/v3/document_image/4249195d-368f-41c1-9a72-3a3fcd60947c-16175743.jpg" alt=" "><br><img src="https://api2.mubu.com/v3/document_image/f5e07ad5-bee0-47ad-a1fa-537acda58cc6-16175743.jpg" alt=" "><br>路由表，直接交付与间接交付<br><img src="https://api2.mubu.com/v3/document_image/8f880e18-934d-44f5-b105-3e95b9d3a568-16175743.jpg" alt=" "><br>这里是IPi是ip地址，Ei是mac地址<br><img src="https://api2.mubu.com/v3/document_image/4249195d-368f-41c1-9a72-3a3fcd60947c-16175743.jpg" alt=" "><br><img src="https://api2.mubu.com/v3/document_image/f5e07ad5-bee0-47ad-a1fa-537acda58cc6-16175743.jpg" alt=" "></p>
<p>一个形象的例子：<br><img src="https://api2.mubu.com/v3/document_image/07bb0e82-b88b-4daa-b258-8a5f8c90d867-16175743.jpg" alt=" "></p>
<p>一些优化：</p>
<p>找到目的地址之后还会放在缓存里保存一段时间。设置超时时间或者让每台新加入的机器广播他的映射关系。<br><img src="https://api2.mubu.com/v3/document_image/00b95e76-e204-46e2-8c2a-764cff369ea0-16175743.jpg" alt=" "></p>
<p>ARP 代理：<br><img src="https://api2.mubu.com/v3/document_image/0bdb802d-a7b2-47a3-9d6b-b9d318e188c6-16175743.jpg" alt=" "><br>这个是为了解决早期一些机器的网络掩码不能改变，导致的问题</p>
<h3 id="DHCP-Dynamic-Host-Configuration-Protocol"><a href="#DHCP-Dynamic-Host-Configuration-Protocol" class="headerlink" title="DHCP (Dynamic Host Configuration Protocol)"></a>DHCP (Dynamic Host Configuration Protocol)</h3><p>动态主机配置协议</p>
<p>差不多是完成主机配置初始化这样一个工作，然后是自动完成的。<br><img src="https://api2.mubu.com/v3/document_image/30e67667-1f96-445d-9989-6d911d14d8e9-16175743.jpg" alt=" "><br>关键词：计算机初始接入网络没有IP地址，广播DISCOVER 报文，DHCP 转播助手(relay agent) ，DHCP服务器，IP租赁</p>
<h2 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF (Open Shortest Path First)"></a>OSPF (Open Shortest Path First)</h2><p>开放最短路径优先，是一个普遍使用的 域内路由算法&#x2F;内部网关路由协议 （interior gateway protocol），开放指的是开源。<br><img src="https://api2.mubu.com/v3/document_image/fbf276a7-4c13-4c5b-a85e-18335637e893-16175743.jpg" alt=" "><br>AS（autonomous system）独立网络&#x2F;自治系统</p>
<p>这个图上的(a)给出的就是一个AS<br><img src="https://api2.mubu.com/v3/document_image/ab361f2a-2394-4bbc-9c6a-50279c14186f-16175743.jpg" alt=" "></p>
<p>这个图中LAN是虚拟的节点，是从周边的三个路由器中抽象出来的。<br>工作方式：<br><img src="https://api2.mubu.com/v3/document_image/e4de1067-f5cb-4e4a-a411-6c3c56e15ce5-16175743.jpg" alt=" "></p>
<p>由于OSPF对于规模比较大的网络效率极低，所以需要对区域进行划分。<br><img src="https://api2.mubu.com/v3/document_image/38e72c93-d6f5-4edf-9894-7b034f6afc09-16175743.jpg" alt=" "></p>
<p>OSPF Routers<br><img src="https://api2.mubu.com/v3/document_image/9ec2ad49-1d73-4364-8386-3ee80fc4ad8e-16175743.jpg" alt=" "></p>
<p>5 Types of OSPF Messages</p>
<p>OSPF是使用IP报文承载传送的，IP是不可靠的，尽力而为的报文，丢了就丢了，所以OSPF需要自己确认。RIP（路由信息协议，好像是那个会计数到无穷的）采用的是UDP数据，是不可靠的。<br><img src="https://api2.mubu.com/v3/document_image/8ab8781b-bc60-4246-9eef-d384fa1cdaf5-16175743.jpg" alt=" "><br><img src="https://api2.mubu.com/v3/document_image/199cdcda-15ba-4c32-835d-ac40e73029fe-16175743.jpg" alt=" "></p>
<h2 id="BGP-Border-Gateway-Protocol"><a href="#BGP-Border-Gateway-Protocol" class="headerlink" title="BGP (Border Gateway Protocol)"></a>BGP (Border Gateway Protocol)</h2><p>边界网关协议，是一种外部网关路由协议，或者说是域间路由算法<br>底层是TCP connection  </p>
<p><img src="https://api2.mubu.com/v3/document_image/64253129-478e-489c-a862-1aa532c7dc04-16175743.jpg" alt=" "><br><img src="https://api2.mubu.com/v3/document_image/3dc13f1c-4fb4-4f21-a230-b38fd817604a-16175743.jpg" alt=" "></p>
<h2 id="word-table"><a href="#word-table" class="headerlink" title="word table"></a>word table</h2><blockquote>
<p>Datagram n.【电脑】数据电报<br> optimality 最优性<br> optimal 最理想的，最佳的<br> adaptive a.适应的，适合的<br> estimate 估计，估价，判断，看法<br> datagram 数据报文<br> anew 重新，再<br> virtual circuits 虚拟电路<br> contradict v.矛盾，抵触<br> metric 公制的，米制的，度量标准<br> artificial adj. 人造的, 人工的, 假的<br> duplicate n. 完全一样的东西, 复制品adj. 完全一样的, 复制的<br> obsolete adj. 老式的；废弃的<br> router down：路由器关闭了，再重启可能造成版本低<br> Refinements n. 精致, 高尚, 精巧<br> <strong>Hierarchical</strong> adj. 分等级的，分层次的<br> Congestion 拥挤，拥塞<br> preventive adj. 预防的,防止的<br> reactive adj. 反应的<br> leaky adj. 漏的；有漏洞的<br> imminent adj. 迫近的；即将来临的<br> throttle 节流n&amp;v<br> utilization n. 利用<br> jitter 抖动<br> Round-robin 循环调度<br> flat 平坦的，平的<br> prefix 前缀<br> circumstances 情况，条件<br> out of order 次序颠倒，无次序的<br> hypothesis 假说，假设<br> hierarchy n. 等级制度<br> clusters 丛，簇<br> vicinity 临近，附近<br> consecutive a.连续的<br> aggregate vt. 总计达…vt. &amp; vi. (使)聚集<br> <mark>NIC</mark> 网卡 Network Interface Card<br> <mark>ISP</mark>一般指网络业务提供商 Internet Service Provider</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>Android应用取消应用上端显示应用名的bar</title>
    <url>/2022/07/22/Android%E5%BA%94%E7%94%A8%E5%8F%96%E6%B6%88%E5%BA%94%E7%94%A8%E4%B8%8A%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%BA%94%E7%94%A8%E5%90%8D%E7%9A%84bar/</url>
    <content><![CDATA[<ol>
<li><p>打开如图所示的styles.xml文件夹<br><img src="https://api2.mubu.com/v3/document_image/14707d26-cc37-4bf9-b545-9cbac3771492-16175743.jpg" alt="styles"></p>
</li>
<li><p>做出如下修改<br>将图示位置改为NoActionBar<br><img src="https://api2.mubu.com/v3/document_image/9fce941f-2bb5-4543-a9fe-d172488d0fe9-16175743.jpg" alt="before"><br><img src="https://api2.mubu.com/v3/document_image/85ce44ca-918d-4473-84fc-6725cee359de-16175743.jpg" alt="after"></p>
</li>
<li><p>结果展示<br>修改前：<br><img src="https://api2.mubu.com/v3/document_image/1658490061380387a.jpg" alt="before"><br>修改后：<br><img src="https://api2.mubu.com/v3/document_image/16584900613788107.jpg" alt="after"></p>
<p><a href="https://blog.csdn.net/minolk/article/details/85053124">参考连接</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记_chapter6</title>
    <url>/2022/06/07/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_chapter6/</url>
    <content><![CDATA[<h1 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h1><h2 id="6-1总线概念-amp-基本结构"><a href="#6-1总线概念-amp-基本结构" class="headerlink" title="6.1总线概念&amp;基本结构"></a>6.1总线概念&amp;基本结构</h2><p>总线定义：</p>
<p>是指在功能部件和功能部件之间或设备与设备之间的一组进行互连和传输信息的信号线，<br>这里信息可以是指令、数据或地址</p>
<p>总线的优点：</p>
<ul>
<li>解决外设多而杂的问题，容易添加新的设备</li>
<li>降低成本</li>
<li>简化设计</li>
</ul>
<p>总线的缺点：</p>
<ul>
<li>总线带宽可能限制整条总线的吞吐量</li>
</ul>
<p>总线的最高速度的影响因素：</p>
<ul>
<li>总线长度</li>
<li>负载的设备树</li>
<li>负载设备的特性：设备的延迟？设备数据传输率？<br>所以我们设计的时候尽量把速度差不多的设备挂在同一条总线上。</li>
</ul>
<p>总线分类</p>
<ul>
<li>内部总线</li>
<li>系统总线<ul>
<li>数据总线DBUS，双向，与机器字长，存储字长有关</li>
<li>地址总线ABUS，单向，与存储地址，IO字长有关</li>
<li>控制总线，一般单向</li>
</ul>
</li>
<li>设备总线</li>
</ul>
<p>总线的层次结构<br><img src="/7" alt="7"></p>
<p>总线的内部结构<br><img src="/9" alt="9"></p>
<p>总线的特性</p>
<p>总线的性能指标</p>
<!-- ppt11 -->
<ul>
<li>总线宽度<ul>
<li>数据线的条数，串，并行性</li>
</ul>
</li>
<li>总线传输率（带宽）</li>
<li>定时协定</li>
<li>信号线数</li>
<li>负载能力</li>
</ul>
<p><mark>记得换算单位！</mark></p>
<p>总线的标准化</p>
<p>目前已经出现了很多总线标准：</p>
<ul>
<li>PCI</li>
<li>ISA</li>
</ul>
<p>总线的连接方式</p>
<p>适配器（又称接口：<!---ppt14---></p>
<p>单机系统中总线结构的三种基本类型：</p>
<ul>
<li>单总线</li>
<li>双总线</li>
<li>三总线</li>
</ul>
<blockquote>
<p>这三种总线基本上是按照不同设备的不同速度进行了不同精度的划分</p>
</blockquote>
<p>单总线结构：<br><img src="/15" alt="15"><br>双总线结构：<br><img src="/16" alt="16"><br>三总线结构：<br><img src="/17" alt="17"></p>
<p>典型总线：<br><img src="/18" alt="ppt18"></p>
<h2 id="6-2总线接口"><a href="#6-2总线接口" class="headerlink" title="6.2总线接口"></a>6.2总线接口</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>信息传送的方式<ul>
<li>串行</li>
<li>并行</li>
</ul>
</li>
<li>出于速度和效率上的考虑，一般用并行</li>
</ul>
<h3 id="串行传送"><a href="#串行传送" class="headerlink" title="串行传送"></a>串行传送</h3><ul>
<li>使用一条传输线，成本低，适合长距离传输，但是速度慢</li>
</ul>
<h3 id="并行传送"><a href="#并行传送" class="headerlink" title="并行传送"></a>并行传送</h3><p>一般采用电位传送，每一数据位需要一条传输线<br>为了节省线的条数，采用分时复用</p>
<h3 id="接口的基本概念"><a href="#接口的基本概念" class="headerlink" title="接口的基本概念"></a>接口的基本概念</h3><ul>
<li>接口是CPU和主存、外设之间通过总线进行连接的逻辑部件</li>
<li>接口的典型功能：控制、缓冲、状态、转换和程序中断<!-- ppt24 --></li>
</ul>
<h2 id="6-3总线的仲裁"><a href="#6-3总线的仲裁" class="headerlink" title="6.3总线的仲裁"></a>6.3总线的仲裁</h2><p>主设备和从设备的交互称为一个总线事务单元，因此总线事务包括两个部分：</p>
<ul>
<li>发起命令</li>
<li>传输数据</li>
</ul>
<p>总线占用期：主设备持续控制总线的时间</p>
<h3 id="集中式仲裁"><a href="#集中式仲裁" class="headerlink" title="集中式仲裁"></a>集中式仲裁</h3><p>有点像交通警察在路口指挥交通</p>
<h4 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h4><p>ppt30<br>总线请求-&gt;转递请求-&gt;总线响应-&gt;总线忙</p>
<p>总线请求(&#x2F;BR)和总线忙(&#x2F;BB)都是低电平有效。</p>
<p>链式查询有隐含的优先级，离仲裁器近的优先级高</p>
<p>优点：</p>
<ul>
<li>实现简单</li>
<li>便于增删</li>
</ul>
<p>缺点：</p>
<ul>
<li>故障敏感，有点像电路，前一个模块出现问题后面的都不能工作</li>
<li>仲裁速度慢</li>
<li>优先级不能改变，优先级低的设备可能会“饿死”</li>
</ul>
<p>电路图：<br><img src="/(https:/api2.mubu.com/v3/document_image/2a959174-a2b1-4d36-bf90-bc432a6f3d63-16175743.jpg)" alt="34"></p>
<h4 id="计数器定时查询"><a href="#计数器定时查询" class="headerlink" title="计数器定时查询"></a>计数器定时查询</h4><p><img src="https://api2.mubu.com/v3/document_image/b518873e-2241-4b53-817a-9429bd635a59-16175743.jpg" alt="jsq"></p>
<h4 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h4><p><img src="https://api2.mubu.com/v3/document_image/2248541b-f7d1-4742-bc69-22614b07b832-16175743.jpg" alt="duli"><br>优点</p>
<ul>
<li>响应时间短</li>
<li>控制相当灵活</li>
<li>故障不敏感</li>
</ul>
<p>缺点</p>
<ul>
<li>线路复杂</li>
<li>不易增加设备（总线仲裁器的引脚数是定的）</li>
</ul>
<h3 id="分布式仲裁"><a href="#分布式仲裁" class="headerlink" title="分布式仲裁"></a>分布式仲裁</h3><p>分布式仲裁不需要集中的总线仲裁器，每个潜在的主方功能模块都有自己的仲裁号和仲裁器。当它们有总线请求时，把它们唯一的<strong>仲裁号</strong>发送到共享的仲裁总线上，每个仲裁器将仲裁总线上得到的号与自己的号进行比较。如果仲裁总线上的号大，则它的总线请求不予响应，并撤销它的仲裁号。最后，获胜者的仲裁号保留在仲裁总线上。显然，分布式仲裁是以优先级仲裁策略为基础。</p>
<p>有点像路口没有警察，所有车辆先停下，确认其他方向没有来车之后再通行</p>
<p>示意图<br><img src="https://api2.mubu.com/v3/document_image/b50c15e8-ead4-48de-b290-aaff1ac0fa23-16175743.jpg" alt="tu"></p>
<h2 id="6-4-总线的定时和数据传送模式"><a href="#6-4-总线的定时和数据传送模式" class="headerlink" title="6.4 总线的定时和数据传送模式"></a>6.4 总线的定时和数据传送模式</h2><h3 id="总线的定时"><a href="#总线的定时" class="headerlink" title="总线的定时"></a>总线的定时</h3><h4 id="同步定时"><a href="#同步定时" class="headerlink" title="同步定时"></a>同步定时</h4><h4 id="异步定时"><a href="#异步定时" class="headerlink" title="异步定时"></a>异步定时</h4><h3 id="总线数据传送模式"><a href="#总线数据传送模式" class="headerlink" title="总线数据传送模式"></a>总线数据传送模式</h3><ul>
<li>读写操作<ul>
<li>读操作是由从方到主方的数据传送</li>
<li>写操作是由主方到从方的数据传送</li>
</ul>
</li>
</ul>
<blockquote>
<p>为了提高总线利用率，减少延时损失，主方完成寻址总线周期后可让出总线控制权，以使其他主方完成更紧迫的操作。然后再重新竞争总线，完成数据传送总线</p>
</blockquote>
<ul>
<li><p>块传送操作</p>
<ul>
<li>只需给出块的起始地址，然后对固定块长度的数据逐一地读出或写入。对于CPU（主方）-存储器（从方）而言的块传送，常称为突发式传送，其块长一般固定为数据线宽度（存储器字长）的<strong>4倍</strong></li>
</ul>
</li>
<li><p>写后读、读-修改-写操作<br>这是两种组合操作。只给出地址一次（表示同一地址），或进行先写后读操作，或进行先读后写操作。前者用于校验目的，后者用于多道程序系统中对共享存储资源的保护。这两种操作和突发式操作一样，主方掌管总线直到整个操作完成</p>
</li>
<li><p>广播、广集操作</p>
<ul>
<li>一般而言，数据传送只在一个主方和一个从方之间进行。</li>
<li>但有的总线允许<strong>一个主方</strong>对<strong>多个从方</strong>进行写操作，这种操作称为广播。</li>
<li>与广播相反的操作称为广集，它将选定的<strong>多个从方数据</strong>在总线上完成AND或OR操作，用以检测多个中断源。</li>
</ul>
</li>
</ul>
<h2 id="6-5HOST总线和PCI总线"><a href="#6-5HOST总线和PCI总线" class="headerlink" title="6.5HOST总线和PCI总线"></a>6.5HOST总线和PCI总线</h2><p><img src="https://api2.mubu.com/v3/document_image/34b2d4d3-23b7-4a78-836e-8817e697b701-16175743.jpg" alt="多总线框图"></p>
<h3 id="PCI总线"><a href="#PCI总线" class="headerlink" title="PCI总线"></a>PCI总线</h3><p>Peripheral Component Interconnect 周边器件的互联</p>
<h4 id="PCI总线信号"><a href="#PCI总线信号" class="headerlink" title="PCI总线信号"></a>PCI总线信号</h4><h4 id="总线周期类型"><a href="#总线周期类型" class="headerlink" title="总线周期类型"></a>总线周期类型</h4>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记_传输层</title>
    <url>/2022/06/06/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h2 id="6-1-传输服务"><a href="#6-1-传输服务" class="headerlink" title="6.1 传输服务"></a>6.1 传输服务</h2><h2 id="6-2-传输协议的要素"><a href="#6-2-传输协议的要素" class="headerlink" title="6.2 传输协议的要素"></a>6.2 传输协议的要素</h2><h2 id="6-3-拥塞控制"><a href="#6-3-拥塞控制" class="headerlink" title="6.3 拥塞控制"></a>6.3 拥塞控制</h2><p>AIMD</p>
<h2 id="6-4-UDP"><a href="#6-4-UDP" class="headerlink" title="6.4 UDP"></a>6.4 UDP</h2><h2 id="6-5-TCP"><a href="#6-5-TCP" class="headerlink" title="6.5 TCP"></a>6.5 TCP</h2><h3 id="1-TCP概述"><a href="#1-TCP概述" class="headerlink" title="1 TCP概述"></a>1 TCP概述</h3><h3 id="2-TCP服务模型"><a href="#2-TCP服务模型" class="headerlink" title="2 TCP服务模型"></a>2 TCP服务模型</h3><h3 id="3-TCP协议"><a href="#3-TCP协议" class="headerlink" title="3 TCP协议"></a>3 TCP协议</h3><h3 id="4-TCP段的头"><a href="#4-TCP段的头" class="headerlink" title="4 TCP段的头"></a>4 TCP段的头</h3><p><img src="https://api2.mubu.com/v3/document_image/b3a64ccc-3fc0-4b76-9bff-39b0c584a906-16175743.jpg" alt="TCP头"><br>序号seq是计数的字节数，因为TCP是咩有边界的，所以只能以字节计数。<br>ACK号是指的下一个期待的字节，而不是已经正确接收了的字节。并且是累计确认。<br>TCP的数据可以为0，就是说TCP报文段里可以不携带任何信息。<br>MSS(maximum sigment size)</p>
<p>根据改变发送窗口的尺寸</p>
<p>分析IP报文，先看协议类型，06是tcp，</p>
<h3 id="5-TCP连接建立"><a href="#5-TCP连接建立" class="headerlink" title="5 TCP连接建立"></a>5 TCP连接建立</h3><h3 id="6-TCP连接释放"><a href="#6-TCP连接释放" class="headerlink" title="6 TCP连接释放"></a>6 TCP连接释放</h3><h3 id="7-TCP连接管理模型"><a href="#7-TCP连接管理模型" class="headerlink" title="7 TCP连接管理模型"></a>7 TCP连接管理模型</h3><h3 id="8-TCP滑动窗口"><a href="#8-TCP滑动窗口" class="headerlink" title="8 TCP滑动窗口"></a>8 TCP滑动窗口</h3><h3 id="9-TCP计时器管理"><a href="#9-TCP计时器管理" class="headerlink" title="9 TCP计时器管理"></a>9 TCP计时器管理</h3><h3 id="10-TCP拥塞控制"><a href="#10-TCP拥塞控制" class="headerlink" title="10 TCP拥塞控制"></a>10 TCP拥塞控制</h3><h3 id="11-TCP未来"><a href="#11-TCP未来" class="headerlink" title="11 TCP未来"></a>11 TCP未来</h3>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>Android内部存储和外部存储</title>
    <url>/2022/08/03/Android%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8&amp;%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h2><ol>
<li>内部存储不是内存<br>内部存储位于系统中很特殊的一个位置，如果你想将文件存储于内部存储中，那么文件默认<strong>只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下。</strong>也就是说应用创建于内部存储的文件，与这个应用是关联起来的。当一个应用卸载之后，内部存储中的这些文件也被删除。</li>
<li>从技术上来讲如果你在创建内部存储文件的时候将文件属性设置成可读，其他app能够访问自己应用的数据，前提是他知道你这个应用的包名，如果一个文件的属性是私有（private），那么即使知道包名其他应用也无法访问。</li>
<li>内部存储空间十分有限，因而显得可贵，另外，它也是系统本身和系统应用程序主要的数据存储所在地，一旦内部存储空间耗尽，手机也就无法使用了。所以对于内部存储空间，我们要尽量避免使用。</li>
<li>Shared Preferences和SQLite数据库都是存储在内部存储空间上的。内部存储一般用Context来获取和操作。</li>
</ol>
<h3 id="访问内部存储"><a href="#访问内部存储" class="headerlink" title="访问内部存储"></a>访问内部存储</h3><p>内部存储位于手机系统下的”&#x2F;data&#x2F;data&#x2F;&lt;包名&gt;&#x2F;files”目录中。<br>使用javaI&#x2F;O流体系可以很方便的对内部存储的数据进行读写。<br>其中，FileOutputStream类的openFileOutput()方法用来打开相应的输出流；<br>FileOutputStream类的openFileInput()方法用来打开相应的输入流。<br>默认情况下仅当前应用程序可见。卸载了一起删。<br><img src="https://api2.mubu.com/v3/document_image/57676964-b07d-4723-85c4-3016e254ccc1-16175743.jpg" alt="示例"></p>
<p><img src="https://api2.mubu.com/v3/document_image/c04123c8-57e6-417b-a9fa-db985f1ea175-16175743.jpg" alt="示例"></p>
<h2 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h2><p>老的Android系统的跟新的Android系统是有差别的，很多人去网上查找资料，看了一下以前的资料，又看了一下现在的资料，但是发现它们说法不一样然后就困惑了。</p>
<p>首先说一个大家普遍的概念“如果在pc机上是区分外部存储和内部存储的话，那么电脑自带的硬盘算是内部存储，U盘或者移动硬盘就是外部存储了。”因此很多人带着这样的理解去看待安卓手机，把内置存储（机身存储）当做内部存储，而把扩展的SD卡当做是外部存储。这么认为确实没错，因为在4.4（API19）以前的手机上确实是这样的，手机自身带的存储卡就是内部存储，而扩展的SD卡就是外部存储。</p>
<p>但是从4.4的系统开始，很多的中高端机器都将自己的机身存储扩展到了8G以上，比如有的人的手机是16G的，有的人的手机是32G的，但是这个16G，32G是内部存储吗，不是的！！！，它们依然是外部存储，也就是说4.4系统及以上的手机将机身存储存储（手机自身带的存储叫做机身存储）在概念上分成了”内部存储internal” 和”外部存储external” 两部分。既然16G，32G是外部存储，那有人又有疑惑了，那4.4系统及以上的手机要是插了SD卡呢，SD卡又是什么呢，如果SD卡也是外部存储的话，那怎么区分机身存储的外部存储跟SD卡的外部存储呢？对，SD卡也是外部存储，那怎么区分呢，在4.4以后的系统中，API提供了这样一个方法来遍历手机的外部存储路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">File files;</span><br><span class="line">	<span class="keyword">if</span>(Build.Version.sdk_int&gt;=Build.VERSION_CODES.KITKAT)</span><br><span class="line">	&#123;</span><br><span class="line">		files = getExternalFilesDirs(Environment.MEDIA_MOUNTED);</span><br><span class="line">		<span class="keyword">for</span>(File file:files)&#123;</span><br><span class="line">			Log.i(<span class="string">&quot;main&quot;</span>,String.valueOf(file));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://api2.mubu.com/v3/document_image/ceda83d6-8d67-4a76-8dfd-f5c83bdce5cb-16175743.jpg" alt="运行结果"></p>
<p>图片看区别：</p>
<p><img src="https://api2.mubu.com/v3/document_image/4084bea6-6c8a-4487-b059-e07e248a35ac-16175743.jpg" alt="两者区别"></p>
<h2 id="内存、内部存储和外部存储"><a href="#内存、内部存储和外部存储" class="headerlink" title="内存、内部存储和外部存储"></a>内存、内部存储和外部存储</h2><ol>
<li>内存：我们在英文中称作memory，内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，所以说它是用于计算机运行时的，它不是用来存储数据的。</li>
<li>内部存储or外部存储：内部存储我们称为InternalStorage，外部我们称为ExternalStorage，这两个概念来自于早期的Android智能机，4.4以前，内置存储就是内部存储，外置SD卡就是外置存储。我们通过getDataDirectory就可以获取内置存储根路径，通过getExternalStorageDirectory就可以获取外置SD卡根路径。4.4以后外部存储就包含两部分了，其中通过getExternalStorageDirectory获取的是机身存储的外部存储，而外置SD卡我们则需要通过getExternalDirs遍历来获取了。</li>
<li>机身存储：机身存储是指手机自身携带的存储空间，出厂时就已经有了，4.4以前机身存储就是内部存储，4.4及以后机身存储包含了内部存储和外部存储。</li>
</ol>
<p><font size=1>参考：<a href="https://blog.csdn.net/weixin_45882303/article/details/121915887">Android文件存储—内部存储&#x2F;外部存储</a></font></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
