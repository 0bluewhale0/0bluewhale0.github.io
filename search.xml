<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android内部存储和外部存储</title>
    <url>/2022/08/03/Android%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8&amp;%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h2><ol>
<li>内部存储不是内存<br>内部存储位于系统中很特殊的一个位置，如果你想将文件存储于内部存储中，那么文件默认<strong>只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下。</strong>也就是说应用创建于内部存储的文件，与这个应用是关联起来的。当一个应用卸载之后，内部存储中的这些文件也被删除。</li>
<li>从技术上来讲如果你在创建内部存储文件的时候将文件属性设置成可读，其他app能够访问自己应用的数据，前提是他知道你这个应用的包名，如果一个文件的属性是私有（private），那么即使知道包名其他应用也无法访问。</li>
<li>内部存储空间十分有限，因而显得可贵，另外，它也是系统本身和系统应用程序主要的数据存储所在地，一旦内部存储空间耗尽，手机也就无法使用了。所以对于内部存储空间，我们要尽量避免使用。</li>
<li>Shared Preferences和SQLite数据库都是存储在内部存储空间上的。内部存储一般用Context来获取和操作。</li>
</ol>
<h3 id="访问内部存储"><a href="#访问内部存储" class="headerlink" title="访问内部存储"></a>访问内部存储</h3><p>内部存储位于手机系统下的”&#x2F;data&#x2F;data&#x2F;&lt;包名&gt;&#x2F;files”目录中。<br>使用javaI&#x2F;O流体系可以很方便的对内部存储的数据进行读写。<br>其中，FileOutputStream类的openFileOutput()方法用来打开相应的输出流；<br>FileOutputStream类的openFileInput()方法用来打开相应的输入流。<br>默认情况下仅当前应用程序可见。卸载了一起删。<br><img src="https://api2.mubu.com/v3/document_image/57676964-b07d-4723-85c4-3016e254ccc1-16175743.jpg" alt="示例"></p>
<p><img src="https://api2.mubu.com/v3/document_image/c04123c8-57e6-417b-a9fa-db985f1ea175-16175743.jpg" alt="示例"></p>
<h2 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h2><p>老的Android系统的跟新的Android系统是有差别的，很多人去网上查找资料，看了一下以前的资料，又看了一下现在的资料，但是发现它们说法不一样然后就困惑了。</p>
<p>首先说一个大家普遍的概念“如果在pc机上是区分外部存储和内部存储的话，那么电脑自带的硬盘算是内部存储，U盘或者移动硬盘就是外部存储了。”因此很多人带着这样的理解去看待安卓手机，把内置存储（机身存储）当做内部存储，而把扩展的SD卡当做是外部存储。这么认为确实没错，因为在4.4（API19）以前的手机上确实是这样的，手机自身带的存储卡就是内部存储，而扩展的SD卡就是外部存储。</p>
<p>但是从4.4的系统开始，很多的中高端机器都将自己的机身存储扩展到了8G以上，比如有的人的手机是16G的，有的人的手机是32G的，但是这个16G，32G是内部存储吗，不是的！！！，它们依然是外部存储，也就是说4.4系统及以上的手机将机身存储存储（手机自身带的存储叫做机身存储）在概念上分成了”内部存储internal” 和”外部存储external” 两部分。既然16G，32G是外部存储，那有人又有疑惑了，那4.4系统及以上的手机要是插了SD卡呢，SD卡又是什么呢，如果SD卡也是外部存储的话，那怎么区分机身存储的外部存储跟SD卡的外部存储呢？对，SD卡也是外部存储，那怎么区分呢，在4.4以后的系统中，API提供了这样一个方法来遍历手机的外部存储路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">File files;</span><br><span class="line">	<span class="keyword">if</span>(Build.Version.sdk_int&gt;=Build.VERSION_CODES.KITKAT)</span><br><span class="line">	&#123;</span><br><span class="line">		files = getExternalFilesDirs(Environment.MEDIA_MOUNTED);</span><br><span class="line">		<span class="keyword">for</span>(File file:files)&#123;</span><br><span class="line">			Log.i(<span class="string">&quot;main&quot;</span>,String.valueOf(file));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>$\delta$</p>
<p>运行结果：</p>
<p><img src="https://api2.mubu.com/v3/document_image/ceda83d6-8d67-4a76-8dfd-f5c83bdce5cb-16175743.jpg" alt="运行结果"></p>
<p>图片看区别：</p>
<p><img src="https://api2.mubu.com/v3/document_image/4084bea6-6c8a-4487-b059-e07e248a35ac-16175743.jpg" alt="两者区别"></p>
<h2 id="内存、内部存储和外部存储"><a href="#内存、内部存储和外部存储" class="headerlink" title="内存、内部存储和外部存储"></a>内存、内部存储和外部存储</h2><ol>
<li>内存：我们在英文中称作memory，内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，所以说它是用于计算机运行时的，它不是用来存储数据的。</li>
<li>内部存储or外部存储：内部存储我们称为InternalStorage，外部我们称为ExternalStorage，这两个概念来自于早期的Android智能机，4.4以前，内置存储就是内部存储，外置SD卡就是外置存储。我们通过getDataDirectory就可以获取内置存储根路径，通过getExternalStorageDirectory就可以获取外置SD卡根路径。4.4以后外部存储就包含两部分了，其中通过getExternalStorageDirectory获取的是机身存储的外部存储，而外置SD卡我们则需要通过getExternalDirs遍历来获取了。</li>
<li>机身存储：机身存储是指手机自身携带的存储空间，出厂时就已经有了，4.4以前机身存储就是内部存储，4.4及以后机身存储包含了内部存储和外部存储。</li>
</ol>
<p><font size=1>参考：<a href="https://blog.csdn.net/weixin_45882303/article/details/121915887">Android文件存储—内部存储&#x2F;外部存储</a></font></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP_命名空间</title>
    <url>/2022/04/22/CPP_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>纯纯速通一下-2，全是截图，留着忘了基础操作的时候看</p>
<p><img src="https://api2.mubu.com/v3/document_image/ede93f00-ada6-41c0-930b-f99eddb7bba8-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/d1c188d6-5b72-4b6f-8073-e5a9c51f6a90-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/e169c701-afc7-4445-b015-3319774c6982-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/a9e0498b-65e6-49b8-be39-149317a08fa1-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/9aceefe5-7399-4b4a-b253-8aebe74febf3-16175743.jpg">    </p>
<p>全局命名空间<br><img src="https://api2.mubu.com/v3/document_image/e88d9228-e936-4813-902d-32db60e057f3-16175743.jpg"></p>
<p>嵌套命名空间<br><img src="https://api2.mubu.com/v3/document_image/3107728d-9a4d-43c3-b85c-2772611f04a4-16175743.jpg"></p>
<p>无名命名空间<br><img src="https://api2.mubu.com/v3/document_image/3983c0d9-1c52-4f4c-bafa-bf7e8f244157-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/e61473b4-efc8-4bb5-976c-95b1052ec63c-16175743.jpg"></p>
<p>命名空间内名字的查找类似于作用域，先小后大</p>
<p><img src="https://api2.mubu.com/v3/document_image/ff8ca296-7ad1-4e12-b2da-0ca7c582d88f-16175743.jpg"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Android应用取消应用上端显示应用名的bar</title>
    <url>/2022/07/22/Android%E5%BA%94%E7%94%A8%E5%8F%96%E6%B6%88%E5%BA%94%E7%94%A8%E4%B8%8A%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%BA%94%E7%94%A8%E5%90%8D%E7%9A%84bar/</url>
    <content><![CDATA[<ol>
<li><p>打开如图所示的styles.xml文件夹<br><img src="https://api2.mubu.com/v3/document_image/14707d26-cc37-4bf9-b545-9cbac3771492-16175743.jpg" alt="styles"></p>
</li>
<li><p>做出如下修改<br>将图示位置改为NoActionBar<br><img src="https://api2.mubu.com/v3/document_image/9fce941f-2bb5-4543-a9fe-d172488d0fe9-16175743.jpg" alt="before"><br><img src="https://api2.mubu.com/v3/document_image/85ce44ca-918d-4473-84fc-6725cee359de-16175743.jpg" alt="after"></p>
</li>
<li><p>结果展示<br>修改前：<br><img src="https://api2.mubu.com/v3/document_image/1658490061380387a.jpg" alt="before"><br>修改后：<br><img src="https://api2.mubu.com/v3/document_image/16584900613788107.jpg" alt="after"></p>
<p><a href="https://blog.csdn.net/minolk/article/details/85053124">参考连接</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP_容器类和模板</title>
    <url>/2022/04/22/CPP_%E5%AE%B9%E5%99%A8%E4%B8%8E%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>纯纯速通一下-3，全是截图，留着忘了基础操作的时候看</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>为什么要有模板？<br>比如比较大小的函数，仅仅是参数类型不同，而操作一样，能不能只写一个函数？</p>
<p>模板定义<br><img src="https://api2.mubu.com/v3/document_image/63229055-16fb-4237-821a-750f793ce906-16175743.jpg"></p>
<p>模板分类<br><img src="https://api2.mubu.com/v3/document_image/8a649085-a9a2-46cd-bd88-83c418baddc2-16175743.jpg"><br>使用例子：<br><img src="https://api2.mubu.com/v3/document_image/fe2eaa0b-d5fb-4a43-97d0-3d071ed9f103-16175743.jpg"><br>例子2：<br><img src="https://api2.mubu.com/v3/document_image/5b47f3d4-9855-45f9-8b66-2b36938ff18f-16175743.jpg"></p>
<h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><p><img src="https://api2.mubu.com/v3/document_image/d5499771-36c0-4c5b-95f8-b371bab6f55a-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/d74c7e2e-0031-478a-98d2-ebc0b013356f-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/715754da-d46e-436c-9279-293b7ccdde99-16175743.jpg"></p>
<p>使用条件：<br><img src="https://api2.mubu.com/v3/document_image/04b709f7-45d7-4f50-8b0d-c0dc3a1dd478-16175743.jpg"></p>
<p>使用格式<br><img src="https://api2.mubu.com/v3/document_image/911599db-e41f-4eab-9ef7-78f7aab5f297-16175743.jpg"></p>
<p>初始化方式：<br><img src="https://api2.mubu.com/v3/document_image/77d9cb0b-d50f-4ca3-82a6-844be0582c1b-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/b6db9fe6-4faf-41aa-a7c2-a52a2aaf9029-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/0fdd07cd-813a-4190-9bee-6c6c8fb03941-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/8d434ba7-9a65-4cfc-a6ea-ae94736a8893-16175743.jpg"></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><img src="https://api2.mubu.com/v3/document_image/9b589e00-7f69-4393-932b-ec079764afa2-16175743.jpg"></p>
<p>迭代器的范围<br><img src="https://api2.mubu.com/v3/document_image/b8073103-2d90-46bb-8443-7a853d92cce8-16175743.jpg"></p>
<p>迭代器失效<br><img src="https://api2.mubu.com/v3/document_image/0d66ce77-28ab-4460-b308-469981a67987-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/7d05d222-5e5e-4873-8dbb-e253bb724e84-16175743.jpg"><br>不同标准的C++的迭代器遍历<br>！<a href="https://api2.mubu.com/v3/document_image/727574aa-ef3b-4dc9-9a47-a7d2d761f12a-16175743.jpg"></a></p>
<h3 id="顺序容器的典型操作"><a href="#顺序容器的典型操作" class="headerlink" title="顺序容器的典型操作"></a>顺序容器的典型操作</h3><p><img src="https://api2.mubu.com/v3/document_image/ac2fc968-1f95-4ed9-a99f-ef026a32d566-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/ae5b3b87-2df3-48eb-9def-aff039ea8746-16175743.jpg"></p>
<ol>
<li>vector<br><img src="https://api2.mubu.com/v3/document_image/4b87d4d4-55c1-4f3c-b1da-ba5f6a3ced25-16175743.jpg"></li>
<li>list<br>list的erase操作的参数与vector类似，这里没截到<br><img src="https://api2.mubu.com/v3/document_image/e86767e6-b274-4100-ace0-1ab0bc2922a1-16175743.jpg"></li>
<li>比较<br><img src="https://api2.mubu.com/v3/document_image/a0cbe200-e687-475f-ba2a-93183c68f2ed-16175743.jpg"></li>
</ol>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p><img src="https://api2.mubu.com/v3/document_image/515e9d9d-2735-4f1a-be29-5ac5823e5a05-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/26ab10b8-d08f-4186-b8d8-661b8b20d372-16175743.jpg"></p>
<p>map:<br><img src="https://api2.mubu.com/v3/document_image/9cfa2a79-901f-47ab-b5c3-8eba59d58bf9-16175743.jpg"></p>
<h3 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h3><p><img src="https://api2.mubu.com/v3/document_image/2cf1a1b7-abbf-457d-9e76-34b384383ad6-16175743.jpg"><br>用法<br><img src="https://api2.mubu.com/v3/document_image/cce292c3-6fa2-4edc-a90d-ed92b3a31fcb-16175743.jpg"></p>
<p>模板是泛型编程的基础</p>
<p><img src="https://api2.mubu.com/v3/document_image/8c1036c4-842f-4972-ada3-d0926aa47927-16175743.jpg"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP_对象指针和数组</title>
    <url>/2022/04/22/CPP_%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>纯纯速通一下，全是截图，留着忘了基础操作的时候看</p>
<p>对象数组<br><img src="https://api2.mubu.com/v3/document_image/31a5c70e-fae8-4056-a1bf-f4793606ceed-16175743.jpg"></p>
<p>指针<br><img src="https://api2.mubu.com/v3/document_image/832744f0-a8e1-4136-8ccd-93a8e5eed05b-16175743.jpg"><br><img src="https://api2.mubu.com/v3/document_image/342bb47d-6079-4e1b-b963-ac04f0ddde60-16175743.jpg"></p>
<p>对象指针<br><img src="https://api2.mubu.com/v3/document_image/11342eea-5baa-4e40-ba8a-e409b148f2c5-16175743.jpg"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python前瞻学习Notes</title>
    <url>/2022/09/04/Python%E9%80%89%E4%BF%AE%E8%AF%BE%E5%89%8D%E7%9E%BB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="常用的值的类型"><a href="#常用的值的类型" class="headerlink" title="常用的值的类型"></a>常用的值的类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Number</td>
<td>- 整数、浮点数、复数、bool</td>
<td>复数：4+3j，j结尾表示复数</td>
</tr>
<tr>
<td>String</td>
<td>描述文本的一种数据类型</td>
<td>任意数量的字符，英文引号</td>
</tr>
<tr>
<td>List</td>
<td>有序的可变序列</td>
<td>Py中使用最频繁的数据类型，可有序记录一堆数据</td>
</tr>
<tr>
<td>Tuple</td>
<td>有序的不可变序列</td>
<td>有序记录一堆不可变的Py数据集合</td>
</tr>
<tr>
<td>Set</td>
<td>无序不重复集合</td>
<td>无序记录一堆不重复的Py数据集合</td>
</tr>
<tr>
<td>Dictionary</td>
<td>无序Key-Value集合</td>
<td>无序记录一堆Key-Value型的Py数据集合</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行：#开头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我是注释</span></span><br><span class="line"><span class="comment"># 通常#和后面的注释之间要空一格空格</span></span><br></pre></td></tr></table></figure>

<p>多行：<br>“””<br>….<br>“””<br>支持换行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    多行注释第一行</span></span><br><span class="line"><span class="string">    多行注释第二行</span></span><br><span class="line"><span class="string">    多行注释第三行</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>type()语句查看数据类型，<br>括号里面可以是变量&#x2F;字面量，返回值是 &lt;class ‘type’&gt;<br>type()方式查看的是数据类型，python中变量没有类型，相当于只是一个盒子。<br>这里存储type的变量也有类型，是“type”类型<br><img src="https://api2.mubu.com/v3/document_image/2d3b970b-3bd0-4404-80bd-bcb873aa1222-16175743.jpg" alt="type"></p>
<h2 id="数据类型相互转换"><a href="#数据类型相互转换" class="headerlink" title="数据类型相互转换"></a>数据类型相互转换</h2><table>
<thead>
<tr>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int(x)</td>
<td>将x转换成一个整数</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换成一个浮点数</td>
</tr>
<tr>
<td>str(x)</td>
<td>将x转换成一个字符串</td>
</tr>
</tbody></table>
<p>特别的，浮点数转换成整数会丢失精度。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>python是允许中文作为标识符的，大小写敏感。</p>
<h2 id="python比较特殊的运算符"><a href="#python比较特殊的运算符" class="headerlink" title="python比较特殊的运算符"></a>python比较特殊的运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+、-、*、&#x2F;</td>
<td>加减乘除</td>
<td>跟普通的加减乘除一样</td>
</tr>
<tr>
<td>&#x2F;&#x2F;</td>
<td>取整除</td>
<td>只要整数部分的除法</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>略</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
<td>2**3&#x3D;8</td>
</tr>
</tbody></table>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p><img src="https://api2.mubu.com/v3/document_image/3384ba9b-330e-43bf-a437-1d76d5a5584a-16175743.jpg" alt="字符串"></p>
<h3 id="关于引号问题"><a href="#关于引号问题" class="headerlink" title="关于引号问题"></a>关于引号问题</h3><ul>
<li>单引号定义法，可以内含双引号</li>
<li>双引号定义法，可以内含单引号</li>
<li>可以用转义字符(\)来转义</li>
</ul>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>可以用 + 来拼接字符串，但是只能拼接字符串，不能和其他的类型完成拼接。</p>
<h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;szh&quot;</span></span><br><span class="line">school = <span class="string">&quot;BUPT&quot;</span></span><br><span class="line">message =  <span class="string">&quot;我的名字是%s,来自%s&quot;</span>%(name,school)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>

<p>其中，整数一般用%d，浮点数一般用%f。</p>
<p>py中还有更加简单的字符串格式化方法，在字符串的前面加上f，后面就可以用大括号的方式往里面填空了，这种方法的特点是不限制数据类型，也不做精度控制。<br>这里的f可以理解为format。<br>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line">job = <span class="string">&quot;大学生&quot;</span></span><br><span class="line">money = <span class="number">18.8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>今年<span class="subst">&#123;age&#125;</span>岁，是<span class="subst">&#123;job&#125;</span>,需要<span class="subst">&#123;money&#125;</span>元灵魂归位。&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="字符串精度控制"><a href="#字符串精度控制" class="headerlink" title="字符串精度控制"></a>字符串精度控制</h2><p>使用%m.n的方式进行精度控制，m是总长度对齐，n是小数精度控制，如果只有一个数就默认是整数部分，即m。</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>定义：具有明确执行结果的代码语句。</p>
<h2 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入姓名&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>input语句不管写入的是什么东西，统统当作str类型来处理。</p>
<h2 id="布尔类型和比较运算符"><a href="#布尔类型和比较运算符" class="headerlink" title="布尔类型和比较运算符"></a>布尔类型和比较运算符</h2>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows ROBOCOPY</title>
    <url>/2023/03/16/ROBOCOPY%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="ROBOCOPY"><a href="#ROBOCOPY" class="headerlink" title="ROBOCOPY"></a>ROBOCOPY</h2><p>是windows系统下面自带的复制文件的命令</p>
<p>比windows文件系统的复制粘贴要快</p>
<p>命令不区分大小写，如果命令行输入找不到的话可能是注册表里面没有注册</p>
<p>可以到这个地方找</p>
<p>进入C盘，Windows&#x2F;WinSXS<br>然后开始搜索<code>Robocopy</code><br>或者直接在Windows文件夹下面开始搜也行<br>这个是笔者找到的<br><img src="https://api2.mubu.com/v3/document_image/bd48c571-074e-49be-90ee-886bab07d439-16175743.jpg" alt="2"></p>
<h2 id="关于常用的一些参数"><a href="#关于常用的一些参数" class="headerlink" title="关于常用的一些参数"></a>关于常用的一些参数</h2><p>&#x2F;S：复制子目录，但不复制空的子目录。<br>&#x2F;E：复制子目录，包括空的子目录。<br>&#x2F;B：在备份模式下复制文件。<br>&#x2F;MOV：移动文件(复制后从源中删除)。<br>&#x2F;MOVE：移动文件和目录(复制后从源中删除)。<br>&#x2F;COPY:复制标记:: 要复制的文件内容(默认为 &#x2F;COPY:DAT)。(复制标记: D&#x3D;数据，A&#x3D;属性，T&#x3D;时间戳)。(S&#x3D;安全&#x3D;NTFS ACL，O&#x3D;所有者信息，U&#x3D;审核信息)。<br>&#x2F;COPYALL：复制所有文件信息(等同于 &#x2F;COPY:DATSOU)。</p>
<h2 id="关于完整手册"><a href="#关于完整手册" class="headerlink" title="关于完整手册"></a>关于完整手册</h2><blockquote>
<p>下列内容可以在命令行提示符中使用 <strong>&#x2F;?</strong> 得到</p>
</blockquote>
<p>用法 :: ROBOCOPY source destination [file [file]…] [options]</p>
<pre><code>源 :: 源目录(驱动器:\路径或\\服务器\共享\路径)。
</code></pre>
<p>目标 :: 目标目录(驱动器:\路径或\服务器\共享\路径)。<br>文件 :: 要复制的文件(名称&#x2F;通配符: 默认为 “<em>.</em>“)。</p>
<h3 id="复制选项"><a href="#复制选项" class="headerlink" title="复制选项"></a>复制选项</h3><p>&#x2F;S :: 复制子目录，但不复制空的子目录。<br>&#x2F;E :: 复制子目录，包括空的子目录。<br>&#x2F;LEV:n :: 仅复制源目录树的前 n 层。<br>&#x2F;Z :: 在可重新启动模式下复制文件。<br>&#x2F;B :: 在备份模式下复制文件。<br>&#x2F;ZB :: 使用可重新启动模式；如果拒绝访问，请使用备份模式。<br>&#x2F;J :: 复制时使用未缓冲的 I&#x2F;O (推荐在复制大文件时使用)。<br>&#x2F;EFSRAW :: 在 EFS RAW 模式下复制所有加密的文件。</p>
<p>&#x2F;COPY:复制标记:: 要复制的文件内容(默认为 &#x2F;COPY:DAT)。<br>（复制标志：D&#x3D;Data、A&#x3D;Attributes、T&#x3D;Timestamps、X&#x3D;Skip alt 数据流（如果 &#x2F;B 或 &#x2F;ZB 则忽略 X）。<br>(S&#x3D;安全&#x3D;NTFS ACL，O&#x3D;所有者信息，U&#x3D;审核信息)。</p>
<p>&#x2F;SEC :: 复制具有安全性的文件(等同于 &#x2F;COPY:DATS)。<br>&#x2F;COPYALL :: 复制所有文件信息(等同于 &#x2F;COPY:DATSOU)。<br>&#x2F;NOCOPY :: 不复制任何文件信息(与 &#x2F;PURGE 一起使用)。<br>&#x2F;SECFIX :: 修复所有文件的文件安全性，即使是跳过的文件。<br>&#x2F;TIMFIX :: 修复所有文件的文件时间，即使是跳过的文件。</p>
<p>&#x2F;PURGE :: 删除源中不再存在的目标文件&#x2F;目录。<br>&#x2F;MIR :: 镜像目录树(等同于 &#x2F;E 加 &#x2F;PURGE)。</p>
<p>&#x2F;MOV :: 移动文件(复制后从源中删除)。<br>&#x2F;MOVE :: 移动文件和目录(复制后从源中删除)。</p>
<p>&#x2F;A+:[RASHCNET] :: 将给定的属性添加到复制的文件。<br>&#x2F;A-:[RASHCNETO]:: 从复制的文件中删除给定的属性。</p>
<p>&#x2F;CREATE :: 仅创建目录树和长度为零的文件。<br>&#x2F;FAT :: 仅使用 8.3 FAT 文件名创建目标文件。<br>&#x2F;256 :: 关闭超长路径(&gt; 256 个字符)支持。</p>
<p>&#x2F;MON:n :: 监视源；发现多于 n 个更改时再次运行。<br>&#x2F;MOT:m :: 监视源；如果更改，在 m 分钟时间后再次运行。</p>
<p>&#x2F;RH:hhmm-hhmm :: 可以启动新的复制时运行的小时数 - 时间。<br>&#x2F;PF :: 基于每个文件(而不是每个步骤)来检查运行小时数。</p>
<p>&#x2F;IPG:n :: 程序包间的间距(ms)，以释放低速线路上的带宽。</p>
<p>&#x2F;SJ:: 将接合复制为接合而非接合目标。<br>&#x2F;SL:: 将符号链接复制为链接而非链接目标。</p>
<p>&#x2F;MT[:n] :: 使用 n 个线程进行多线程复制(默认值为 8)。<br>        n 必须至少为 1，但不得大于 128。<br>        该选项与 &#x2F;IPG 和 &#x2F;EFSRAW 选项不兼容。<br>        使用 &#x2F;LOG 选项重定向输出以便获得最佳性能。</p>
<p>&#x2F;DCOPY:复制标记:: 要复制的目录内容(默认为 &#x2F;DCOPY:DA)。<br>        (copyflag: D&#x3D;数据，A&#x3D;属性，T&#x3D;时间戳，E&#x3D;EA，X&#x3D;跳过替换数据流)。</p>
<p>&#x2F;NODCOPY :: 不复制任何目录信息(默认情况下，执行 &#x2F;DCOPY:DA)。</p>
<p>&#x2F;NOOFFLOAD :: 在不使用 Windows 复制卸载机制的情况下复制文件。</p>
<p>&#x2F;COMPRESS :: 在文件传输期间请求网络压缩(如果适用)。</p>
<p>&#x2F;SPARSE :: 复制期间启用保留稀疏状态</p>
<h3 id="复制文件限制选项"><a href="#复制文件限制选项" class="headerlink" title="复制文件限制选项"></a>复制文件限制选项</h3><p>&#x2F;IoMaxSize:n[KMG] :: 每个{read,write}循环请求的 I&#x2F;O 的最大大小(n [KMG]字节)。</p>
<p>&#x2F;IoRate: n[KMG] :: 请求的 I&#x2F;O 速率 ( n [KMG] 字节&#x2F;秒)。</p>
<p>&#x2F;Threshold:n[KMG] :: 阻止的文件大小阈值，以 n [KMG] 个字节为单位 (请参阅备注)。</p>
<h3 id="文件选择选项"><a href="#文件选择选项" class="headerlink" title="文件选择选项"></a>文件选择选项</h3><p>&#x2F;A :: 仅复制具有存档属性集的文件。<br>&#x2F;M :: 仅复制具有存档属性的文件并重置存档属性。<br>&#x2F;IA:[RASHCNETO] :: 仅包含具有任意给定属性集的文件。<br>&#x2F;XA:[RASHCNETO] :: 排除具有任意给定属性集的文件。</p>
<p>&#x2F;XF 文件[文件]… :: 排除与给定名称&#x2F;路径&#x2F;通配符匹配的文件。<br>&#x2F;XD 目录[目录]… :: 排除与给定名称&#x2F;路径匹配的目录。</p>
<p>&#x2F;XC :: 排除已更改的文件。<br>&#x2F;XN :: 排除较新的文件。<br>&#x2F;XO :: 排除较旧的文件。<br>&#x2F;XX :: 排除多余的文件和目录。<br>&#x2F;XL :: 排除孤立的文件和目录。<br>&#x2F;IS :: 包含相同文件。<br>&#x2F;IT :: 包含已调整的文件。</p>
<p>&#x2F;MAX:n :: 最大的文件大小 - 排除大于 n 字节的文件。<br>&#x2F;MIN:n :: 最小的文件大小 - 排除小于 n 字节的文件。</p>
<p>&#x2F;MAXAGE:n :: 最长的文件存在时间 - 排除早于 n 天&#x2F;日期的文件。<br>&#x2F;MINAGE:n :: 最短的文件存在时间 - 排除晚于 n 天&#x2F;日期的文件。<br>&#x2F;MAXLAD:n :: 最大的最后访问日期 - 排除自 n 以来未使用的文件。<br>&#x2F;MINLAD:n :: 最小的最后访问日期 - 排除自 n 以来使用的文件。<br>    (If n &lt; 1900 then n &#x3D; n days, else n &#x3D; YYYYMMDD date)。</p>
<p>&#x2F;FFT :: 假设 FAT 文件时间(2 秒粒度)。<br>&#x2F;DST :: 弥补 1 小时的 DST 时间差。</p>
<p>&#x2F;XJ:: 排除(文件和目录的)符号链接和接合点。<br>&#x2F;XJD:: 排除目录和接合点的符号链接。<br>&#x2F;XJF :: 排除文件的符号链接。</p>
<p>&#x2F;IM :: 包含已修改的文件(更改时间不同)。</p>
<h3 id="重试选项"><a href="#重试选项" class="headerlink" title="重试选项:"></a>重试选项:</h3><p>&#x2F;R:n :: 失败副本的重试次数: 默认为 1 百万。<br>&#x2F;W:n :: 两次重试间的等待时间: 默认为 30 秒。</p>
<p>&#x2F;REG :: 将注册表中的 &#x2F;R:n 和 &#x2F;W:n 保存为默认设置。</p>
<p>&#x2F;TBD :: 等待定义共享名称(重试错误 67)。</p>
<p>&#x2F;LFSM :: 在低可用空间模式下运行，启用复制暂停和继续(参见“备注”)。</p>
<p>&#x2F;LFSM:n[KMG] :: &#x2F;LFSM，指定下限大小 (n[K:kilo, M:mega, G:giga] 字节)。</p>
<h3 id="日志记录选项"><a href="#日志记录选项" class="headerlink" title="日志记录选项"></a>日志记录选项</h3><p>&#x2F;L :: 仅列出 - 不复制、添加时间戳或删除任何文件。<br>&#x2F;X :: 报告所有多余的文件，而不只是选中的文件。<br>&#x2F;V :: 生成详细输出，同时显示跳过的文件。<br>&#x2F;TS :: 在输出中包含源文件的时间戳。<br>&#x2F;FP :: 在输出中包含文件的完整路径名称。<br>&#x2F;BYTES :: 以字节打印大小。</p>
<p>&#x2F;NS :: 无大小 - 不记录文件大小。<br>&#x2F;NC :: 无类别 - 不记录文件类别。<br>&#x2F;NFL :: 无文件列表 - 不记录文件名。<br>&#x2F;NDL :: 无目录列表 - 不记录目录名称。</p>
<p>&#x2F;NP :: 无进度 - 不显示已复制的百分比。<br>&#x2F;ETA :: 显示复制文件的预期到达时间。</p>
<p>&#x2F;LOG:文件 :: 将状态输出到日志文件(覆盖现有日志)。<br>&#x2F;LOG+:文件 :: 将状态输出到日志文件(附加到现有日志中)。</p>
<p>&#x2F;UNILOG:文件 :: 以 UNICODE 方式将状态输出到日志文件(覆盖现有日志)。<br>&#x2F;UNILOG+:文件 :: 以 UNICODE 方式将状态输出到日志文件(附加到现有日志中)。</p>
<p>&#x2F;TEE :: 输出到控制台窗口和日志文件。</p>
<p>&#x2F;NJH :: 没有作业标头。<br>&#x2F;NJS :: 没有作业摘要。</p>
<p>&#x2F;UNICODE :: 以 UNICODE 方式输出状态。</p>
<h3 id="作业选项"><a href="#作业选项" class="headerlink" title="作业选项"></a>作业选项</h3><p>&#x2F;JOB:作业名称 :: 从命名的作业文件中提取参数。<br>&#x2F;SAVE:作业名称 :: 将参数保存到命名的作业文件<br>&#x2F;QUIT :: 处理命令行后退出(以查看参数)。<br>&#x2F;NOSD :: 未指定源目录。<br>&#x2F;NODD :: 未指定目标目录。<br>&#x2F;IF :: 包含以下文件。</p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>以前在卷的根目录上使用 &#x2F;PURGE 或 &#x2F;MIR 导致<br>robocopy 也对“系统卷信息”目录内的<br>文件应用所请求的操作。现在不再是这种情形；如果<br>指定了任何一项，则 robocopy 将跳过<br>复制会话简要源目录和目标目录中具有该名称的任何文件或目录。</p>
<p>已修改的文件分类仅在源<br>和目标文件系统支持更改时间戳(例如 NTFS)<br>以及源和目标文件具有不同的更改时间(否则相同)<br>时才适用。默认情况下不复制这些文件；指定 &#x2F;IM<br>以包含它们。</p>
<p>&#x2F;DCOPY:E 标志请求扩展属性复制应该<br>针对目录进行尝试。请注意，如果目录的 EA 无法复制，<br>则当前 robocopy 将继续。&#x2F;COPYALL 中也未包括<br>在 &#x2F;COPYALL 中。</p>
<p>如果指定了 &#x2F;IoMaxSize 或 &#x2F;IoRate，则 robocopy 将启用<br>复制文件限制 (目的是减少系统负载)。<br>两者都可以调整为允许值或最佳值；亦即，两者<br>指定所需的复制参数，但系统和 robocopy<br>允许根据需要将其调整为合理的&#x2F;允许的值。<br>如果还使用了&#x2F;Threshold，它将为文件大小指定最小值以<br>参与限制；低于该大小的文件将不会受到限制。<br>所有这三个参数的值后面都能加上可选后缀<br>字符(从集 [KMG](K, M, G)中)。</p>
<p>使用 &#x2F;LFSM 请求 robocopy 在“低可用空间模式”下运行。<br>在该模式下，robocopy 会暂停(每当文件副本导致)<br>目标卷的可用空间低于可以<br>由 LFSM:n[KMG] 形式的标志明确指定的“下限”值时，robocopy 将会暂停。<br>如果指定了 &#x2F;LFSM，但没有显式下限值，则会将下限设置为<br>目标卷大小的百分之十。<br>低可用空间模式与 &#x2F;MT 和 &#x2F;EFSRAW不兼容。</p>
]]></content>
      <categories>
        <category>笔记 - Windows - ROBOCOPY</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>szh的博客</title>
    <url>/2024/04/11/SZH%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><em>为天地立心，为生民立命，为往圣继绝学，为万世开太平</em></p>
]]></content>
  </entry>
  <entry>
    <title>markdown与希腊字母</title>
    <url>/2022/04/11/markdown%E6%8F%92%E5%85%A5%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<p>经常把希腊字母读音搞混，还不会打不会写<br>码一篇，回头需要直接查</p>
<h2 id="希腊字母读音及大小写"><a href="#希腊字母读音及大小写" class="headerlink" title="希腊字母读音及大小写"></a>希腊字母读音及大小写</h2><p><img src="https://api2.mubu.com/v3/document_image/25324d82-a291-4e66-814f-7cf896f6be81-16175743.jpg" alt="读音及大小写"><br><img src="https://api2.mubu.com/v3/document_image/74a75b17-ddaf-4e7e-bd54-497ab10803c3-16175743.jpg" alt="读音及大小写"></p>
<h2 id="希腊字母手写体"><a href="#希腊字母手写体" class="headerlink" title="希腊字母手写体"></a>希腊字母手写体</h2><p><img src="https://api2.mubu.com/v3/document_image/7c96109c-d01c-499d-aefd-8667815a2242-16175743.jpg" alt="手写体"></p>
<h2 id="markdown对照table"><a href="#markdown对照table" class="headerlink" title="markdown对照table"></a>markdown对照table</h2><p><img src="https://api2.mubu.com/v3/document_image/af6f2305-e91f-4541-a8e4-b4628b6fa968-16175743.jpg" alt="对照table"><br><img src="https://api2.mubu.com/v3/document_image/8b438b32-e596-4ab1-9841-6d33fcd2de58-16175743.jpg" alt="对照table"></p>
<hr>
<center>over</center>
]]></content>
      <categories>
        <category>else</category>
      </categories>
      <tags>
        <tag>else</tag>
      </tags>
  </entry>
  <entry>
    <title>二十岁的胡言乱语</title>
    <url>/2022/04/13/%E4%BA%8C%E5%8D%81%E5%B2%81%E7%9A%84%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/</url>
    <content><![CDATA[<p>不知道怎么开头，就从最近发生的事情写起吧。<br>前两天二十岁了，但是那个下午忙于写课设，一片焦头烂额，没有留下什么记录。<br>也或许是知道人不是随着时间长大的，跨过某个时间节点并不代表成长，所以有些漫不经心。<br>出乎意料的是还是收到了一些祝福，L姓傻儿给我发她家的猫猫，某个老年人提前好久就张罗着买鼠标，凌晨收到了一份“人类一败涂地”，经常一起玩的家伙们偶然得知之后会祝快乐，平日里联系不多但曾经很铁的朋友也会有人记得。<br>这些，就很珍贵了。<br>总会有一些瞬间觉得废物如我不配有这样的朋友，但转而又自私而小心眼地希望这样的友谊能够继续下去。</p>
<p>今天晚上没什么想做的事情（实际上该做的事情一大堆但是懒怠），看了好久美人，打开Groove放着bgm又看了会儿闲书，感觉里面讲的一些话很有意思，忍不住想记下来（这里不禁感叹Zdalao推荐的闲书确确实实是本好书啊），这也是有这篇博客的另一个原因。</p>
<p>往后的不知道什么时间翻自己的博客看到这些或许可以一笑呢：</p>
<p>关于计划：</p>
<ul>
<li>计划永远赶不上变化。平凡甚至平庸如我，必不可能像《肖申克的救赎》里安迪那样拥有一个计划然后几十年如一日的执行下去。但是尽管如此，计划仍然是必要的，我们需要考虑的是多久的计划能够让自己依靠自己并不出众的天分顺利实施呢？</li>
<li>理想固然应该是有的，但是，理想这东西往往太过遥远，乃至于我们总是看不清楚。不过还好，所谓千里之行始于足下，我们要做的事情是把每一步都走好，踩得足够踏实。至于千里之外的终点，既然看都看不到，就不用花时间去想了，想了也没用。</li>
<li>用各种方法保持乐观就好————乐观是靠努力和挣扎才可以获得的经验。</li>
<li>如果你对你的将来充满迷惑，相信我你并不孤独。然而，充满迷惑本身，并不意味着你要不知所措。</li>
<li>行动是改变自己的众多方法中最有效、最直接的方法。</li>
<li>其间也有不愿意去的时候，但是，我知道那只不过是我的大脑的想法，而不应该是我的想法——只要意识到这个，就不存在什么挣扎</li>
</ul>
<p>关于试错：</p>
<ul>
<li>很多的时候，没必要做计划的原因有两个：除了前面提到过的“大多数计划其实非常简单”之外，另外一个是“初始状态下，我们往往实际上并没有能力去制定合理有效的计划”</li>
<li>我们一生做的事，大多都是一个试错（Trial and Error）的过程，对于人生，没有人能像解释数学那样给出普适的公式。</li>
<li>第一个吃螃蟹的人”是令人敬佩的，不是勇士谁敢去吃它呢？不过鲁迅先生也说，第一个吃过螃蟹的人肯定也吃过蜘蛛，因为两者外形极为相似；只是他觉得螃蟹的味道可口而蜘蛛的味道不可口。</li>
</ul>
<p>关于立场和经验局限：</p>
<ul>
<li>即便我个人是个所谓的“没有信仰的人”，我也不会反对“信仰自由”，同时不应该、也做不到去强迫任何人放弃信仰</li>
<li>观察一下就知道，日常生活中几乎所有主要的“沟通障碍”本质上都是因为沟通双方无法让对方理解与他们的经验相悖的知识或者信息造成的。这种知识和信息的传递，不是仅仅通过“站在对方立场上考虑问题”就可以轻松而彻底解决的。尽管“站在对方立场上考虑问题”确实已经是很有用也很难以掌握的技巧，可是，当我们面对（或者说“背对”可能更准确些）“双方立场都无法考虑到的问题”的时候呢？尽管这样的时候我们甚至可能不知道问题究竟是什么，但有一点是几乎确定无疑的，这种问题不仅确实存在，还往往至关重要。</li>
</ul>
<p>关于阅读：</p>
<ul>
<li>我常常暗骂现在的本科教育，可是我知道骂了也没用，所以，骂的时候只是偶尔才愤怒。不夸张地讲，今天的本科教育很大程度上干脆就是忘了本。本科教育的根本在于培养学生的自学能力。理论上讲，本科毕业之后，学生应该有能力自学自己需要的任何科目。</li>
<li>很多人高中毕业之后就不再读任何书籍；偶尔看看报纸杂志上的短文（或者是互联网上的帖子）却也常常断章取义——他们不是故意断章取义的，他们是无法做到认真仔细地把每个字都看清楚，更不用提揣摩字里行间的逻辑关系了。</li>
<li>我们的教育，把语文和文学过分紧密联系起来，乃至于忘了文字本身最重要的意义是什么。</li>
</ul>
<p>关于时间和进展的函数关系：</p>
<p><img src="https://api2.mubu.com/v3/document_image/726b6a32-bd41-45be-995e-6d9b2c5de282-16175743.jpg" alt="111"></p>
<p>就这样。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>少年听雨</tag>
      </tags>
  </entry>
  <entry>
    <title>交换原理笔记</title>
    <url>/2023/02/22/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86notes/</url>
    <content><![CDATA[<p>开个坑，期末复习用。<br>ICT:Information Communication Technology,是IT和CT的融合</p>
<h2 id="chapter0-交换通识概论"><a href="#chapter0-交换通识概论" class="headerlink" title="chapter0-交换通识概论"></a>chapter0-交换通识概论</h2><p>停电了电话还能打：电话通过双绞线连到供电局，是由供电局来供电的。</p>
<p>通信网的三要素：</p>
<ul>
<li>交换设备</li>
<li>传输设备<ul>
<li>用户与交换机之间的线叫用户线</li>
<li>交换机与交换机之间的线叫中继线（Trunk）</li>
</ul>
</li>
<li>用户终端设备<br>无线通信：<br>手机和基站是无线的，基站和基站之间还是有线的。<br>PSTN:public switching telephone network</li>
</ul>
<p>通信网的分层：（从上到下）</p>
<ul>
<li>应用层</li>
<li>业务层：里面有很多业务网，比如PSTN,ISDN,OSODN,IN,IP,移动通信网（3G,4G等）</li>
<li>传送层<ul>
<li>接入网：接入的是用户网CPE、CPN，相当于高速匝道，2000年左右“打通最后一公里”</li>
<li>骨干传送网：光纤啦啥的，物理层的，相当于高速车道</li>
</ul>
</li>
<li>还有一个支撑网，不属于任何一层，包括信令网，电信管理网，数字同步网，有点像CPU里面的控制部件。</li>
</ul>
<p><img src="/" alt="通信网的分层"></p>
<p>接入网 的ways：<br>ADSL：亚洲用的多，A是非对称的，下行的速率大，一个小盒子，叫ADSL猫，装完之后就可以同时走电话（300~3400hz）和网络（4k以上，分为上行和下行）。现在换成光纤了，叫光猫。<br>HDSL:high speed DSL,北美用的多，可以达到1.5M，但不能同时传话音和数据<br>LAN：局域网，共享的，会分流量。<br>HTTH：光纤到用户，日本是这么干的，因为日本在2000年的时候有钱&amp;国土小。</p>
<p>无线接入技术：<br><img src="https://api2.mubu.com/v3/document_image/1677035084713429c.jpg" alt="1"><br>WWAN是广域网，已经不属于接入网了，3G,4G都属于这个范畴。</p>
<p>业务网：</p>
<ul>
<li>电话通信网 PSTN</li>
<li>分组交换网 X.25 ，分组交换，支持两种方式，数据报和虚电路，ITU-T国际电信联盟推出的，是全球化的标准。</li>
<li>综合业务数字网 N-ISDN 窄带的</li>
<li>帧中继网 FRN</li>
<li>数字数据网 DDN</li>
<li>IN 智能网</li>
<li>综合业务数字网 B-ISDN，宽带的</li>
<li>下一代网络 NGN</li>
<li>移动互联网</li>
<li>物联网 IOT Internet of things，信息传感器</li>
</ul>
<p><img src="/" alt="业务网"></p>
<p>Q:电路交换跟分组交换和帧交换的区别？<br>Q:数据报和虚电路的区别？<br>Q:电信网和计算机网？<br>另：业务网ppt的交换方式列 电路交换&amp;分组交换应下移一行</p>
<p>通信的基本问题：</p>
<ol>
<li>用什么信息格式传递给对方？编码</li>
<li>如何找到对方？寻址</li>
<li>信息传递的额外要求：网络结构、带宽、复用、连接方式、security、QoS（巴普特的是连到西直门电话局）</li>
</ol>
<p>&#x3D;&#x3D;通信的三对基本概念&#x3D;&#x3D;：</p>
<ul>
<li>信息传送的方式<ul>
<li>面向连接:连接建立——信息传送——连接释放  公交车&#x2F;专线</li>
<li>无连接：边寻址边传递讯息  自行车春游</li>
</ul>
</li>
<li>时分复用（另一种复用是频分复用）<ul>
<li>同步时分复用<ul>
<li>固定带宽分配</li>
<li>位置化信道：依据信号在时间轴上的位置来区分每一路信号（逻辑信道），无信息传送时也占用信道。</li>
<li>每帧定长、子信道信息流速率恒定。</li>
</ul>
</li>
<li>异步时分复用（统计时分复用）<ul>
<li>按需分配，提高了利用率</li>
<li>（动态带宽分配）</li>
<li><strong>标志化信道</strong>：标志码表示哪路信息。</li>
<li>分组长度可变或不可变，分组头用于定界。</li>
<li>统计复用提高信道利用率。</li>
</ul>
</li>
</ul>
</li>
<li>带宽分配<br>类比：交通车道<ul>
<li>固定带宽分配，2G，信道是固定的</li>
<li>动态带宽分配，4G，按需分配信道</li>
</ul>
</li>
</ul>
<h3 id="Word"><a href="#Word" class="headerlink" title="Word"></a>Word</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">time slot TS 时隙</span><br><span class="line">PTM</span><br><span class="line">ATM</span><br><span class="line">CTM</span><br></pre></td></tr></table></figure>

<h2 id="chapter1-交换概率"><a href="#chapter1-交换概率" class="headerlink" title="chapter1-交换概率"></a>chapter1-交换概率</h2><h3 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h3><p><img src="https://api2.mubu.com/v3/document_image/863568db-f74a-4d4f-9bb1-becb15df791e-16175743.jpg" alt="1"></p>
<h3 id="CTM-PTM-的比较"><a href="#CTM-PTM-的比较" class="headerlink" title="CTM PTM 的比较"></a>CTM PTM 的比较</h3><ul>
<li>对信息的损伤方面<ul>
<li>电路交换——时间透明性好，延迟小</li>
<li>分组交换——语义透明性好，错误少</li>
</ul>
</li>
<li>支持多种业务方面<ul>
<li>分组交换有更大的灵活性，可实现多速率交换，并允许多种业务共享网络资源</li>
</ul>
</li>
<li>交换速率<ul>
<li>电路交换可达到高速率的交换（硬件）</li>
<li>分组交换的交换速率受到了限制（软件要看包头）</li>
</ul>
</li>
<li>设备的复杂性<ul>
<li>分组交换需要复杂的队列管理机制</li>
<li>电路交换需要复杂的路由选择算法</li>
</ul>
</li>
</ul>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>电话通信中信息的传送方式：<strong>公共交换电话网（Public Switched Telephone Network，PSTN）</strong>，每一路能提供 64k 速率。（恒定速率）</p>
<ul>
<li>特点<ul>
<li>信息传送的最小单位是<strong>时隙</strong>：每个时隙采样 8bit，采样率 8kHz，每路通信速率 64kbps。</li>
<li>面向连接的工作方式（物理连接）</li>
<li>同步时分复用（固定带宽分配）<img src="https://api2.mubu.com/v3/document_image/b37d8e73-8df4-441b-9cd8-4e9674ef2d02-16175743.jpg" alt="1"></li>
<li>无差错控制机制</li>
<li>对通信信息不做处理（透明传输）</li>
<li>流量控制基于呼叫损失制</li>
</ul>
</li>
</ul>
<p>适合 实时的、恒定速率的话音业务</p>
<h3 id="多速率电路交换"><a href="#多速率电路交换" class="headerlink" title="多速率电路交换"></a>多速率电路交换</h3><p>讲几个基本信道速率捆绑起来，构成一个速率更高的信道，即确定基本信道速率，按需形成其他速率，且其他速率是基本速率的<u>整数倍</u></p>
<p>关键问题：</p>
<ol>
<li>确定基本速率</li>
<li>保证时隙顺序完整性（TSSI）</li>
</ol>
<p>特点：软件实现，控制软件复杂</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>思想来源于报文交换，本质都是<strong>存储——转发</strong><br>所不同的是分组交换的最小信息单位是分组,而报文交换则是一个个报文。由于<strong>以较小的分组为单位进行传输和交换</strong>,所以分组交换比报文交换快。报文交换主要应用于公用电报网中。<br><img src="https://api2.mubu.com/v3/document_image/6c02d35b-2f43-486d-8160-b67ce8d0f736-16175743.jpg" alt="2"></p>
<p>分组交换的特点</p>
<ul>
<li>信息传送的最小单位是分组：由分组头、用户信息构成，分组头含有选路和控制信息。</li>
<li>面向连接（虚电路）方式和无连接（数据报）方式。</li>
<li>统计时分复用，动态分配带宽。</li>
<li>有<strong>差错控制</strong>机制：CRC 校验、重发等（设于第二层和第三层协议中）。</li>
<li>信息传送不具有透明性：对通信信息作处理，如拆分、重组等。</li>
<li>流量控制基于呼叫延迟制。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>虚电路</th>
<th>数据报</th>
</tr>
</thead>
<tbody><tr>
<td>分组头</td>
<td>简单（逻辑信道号）</td>
<td>复杂（详细的选路信息）</td>
</tr>
<tr>
<td>选路</td>
<td>虚连接表</td>
<td>每个分组独立选路</td>
</tr>
<tr>
<td>分组顺序</td>
<td>有序</td>
<td>可能失序</td>
</tr>
<tr>
<td>故障敏感性</td>
<td>敏感</td>
<td>可靠性高</td>
</tr>
<tr>
<td>应用</td>
<td>连续数据流</td>
<td>询问&#x2F;响应</td>
</tr>
</tbody></table>
<p>分组交换的两种方式</p>
<ul>
<li>虚电路VC<ul>
<li>面向连接的OC，先建立（逻辑）连接，再传输</li>
<li>虚连接也称为虚电路,即<strong>逻辑连接</strong>,它不同于电路交换中实际的物理连接,而是通过通信连接上的所有交换节点保存选路结果和路由连接关系来实现连接,因此是逻辑的连接。</li>
<li>不会失序，适用于连续的数据流</li>
<li>一旦建立的连接出现故障,信息传送就要中断,必须重新建立连接,因此对<strong>故障敏感</strong>。</li>
</ul>
</li>
<li>数据报DG<ul>
<li>无连接CL，一边传送一边选路</li>
<li>典型应用是IP网络</li>
<li>统计时分复用（动态带宽分配）</li>
</ul>
</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/2edf2029-3eb0-40e0-a8c0-ae1d09dae490-16175743.jpg" alt="3"></p>
<p>适用于可靠性要求高、突发（burst）、可变速率的数据业务。</p>
<h3 id="帧中继"><a href="#帧中继" class="headerlink" title="帧中继"></a>帧中继</h3><p><img src="https://api2.mubu.com/v3/document_image/ec192c57-9db5-44a3-96c7-fb5ac04b1c91-16175743.jpg" alt="3"></p>
<h3 id="ATM交换"><a href="#ATM交换" class="headerlink" title="ATM交换"></a>ATM交换</h3><p>特点</p>
<ul>
<li>传输的最小单位是cell（信元），固定长度是53byte，前5byte是信头（简化的），其余48byte是payload</li>
<li>采用了异步时分复用方式（动态分配带宽）</li>
<li>面向连接的工作方式，逻辑连接，用VPI,VCI来表示信道</li>
</ul>
<h3 id="交换系统"><a href="#交换系统" class="headerlink" title="交换系统"></a>交换系统</h3><p>交换系统的基本结构<br>交换网络是第二章的核心，又叫交换矩阵。<br><img src="https://api2.mubu.com/v3/document_image/30e7d70c-e397-409b-84a6-7c425d92b45b-16175743.jpg" alt="4"></p>
<ul>
<li>信息传送子系统：<ul>
<li>交换网络：完成交换，实现任意出线与入线的互联。</li>
<li>各种接口：分为用户接口和中继接口，用途是进行信号转换。</li>
</ul>
</li>
<li>控制子系统：由处理机系统构成，是交换系统的“指挥中心”。</li>
</ul>
<h2 id="chapter2-交换网络"><a href="#chapter2-交换网络" class="headerlink" title="chapter2-交换网络"></a>chapter2-交换网络</h2><p>这一章是考试的重点，期末大概占40%。</p>
<h3 id="交换网络的构成"><a href="#交换网络的构成" class="headerlink" title="交换网络的构成"></a>交换网络的构成</h3><p>交换网络是由若干个交换单元按照一定的拓扑结构和控制方式构成的网络。交换网络的三个基本要素是：<strong>交换单元、不同交换单元间的拓扑结构和控制方式</strong>。<br>&#x3D;&#x3D;交换单元是构成交换网络的最基本的部件。&#x3D;&#x3D;</p>
<h3 id="交换单元"><a href="#交换单元" class="headerlink" title="交换单元"></a>交换单元</h3><p>SE :switch element<br>&#x3D;&#x3D;交换单元是构成交换网络的最基本的部件。&#x3D;&#x3D;</p>
<p><img src="https://api2.mubu.com/v3/document_image/8f4e6c27-5974-4165-bfd9-d49918c69a96-16175743.jpg" alt="5"><br>$M \times N$:容量，M条入线，N条出线</p>
<h4 id="交换单元的分类"><a href="#交换单元的分类" class="headerlink" title="交换单元的分类"></a>交换单元的分类</h4><ul>
<li>入线和出线信息传送方向 <img src="https://api2.mubu.com/v3/document_image/f8f40cac-9aa7-4a5a-8407-d007be57a709-16175743.jpg" alt="2"><br><mark>关于K$\times $L ：</mark>从K个进入，只能从L个出来；而从L进入，只能从K个出来；并不是全联通的，要与N$\times $N区分开来。</li>
<li>入线和出线的数量关系 <img src="https://api2.mubu.com/v3/document_image/5dd6e0be-7af0-4fab-a4be-aabf980f6244-16175743.jpg" alt="3"></li>
<li>时分与空分(按照入线和出线之间是否共享单一通路) <img src="https://api2.mubu.com/v3/document_image/450d9921-ecbe-4b6b-ae9a-41379be92035-16175743.jpg" alt="4"></li>
<li>按照交换单元所接收的信号<ul>
<li>模拟交换单元（现在已经不用了）</li>
<li>数字交换单元</li>
</ul>
</li>
<li>全联通与部分联通交换单元</li>
</ul>
<h4 id="交换单元的基本特性"><a href="#交换单元的基本特性" class="headerlink" title="交换单元的基本特性"></a>交换单元的基本特性</h4><h5 id="交换单元的连接特性"><a href="#交换单元的连接特性" class="headerlink" title="交换单元的连接特性"></a>交换单元的连接特性</h5><ul>
<li>交换单元连接特性的描述方式：<ul>
<li>集合描述方式</li>
<li>函数描述方式（排列、图形、二进制函数）</li>
</ul>
</li>
<li>常见的连接方式：<ul>
<li>直接连接</li>
<li>交叉连接</li>
<li>蝶式连接</li>
<li>均匀洗牌连接</li>
<li>间隔交叉连接</li>
</ul>
</li>
</ul>
<h5 id="交换单元的性能"><a href="#交换单元的性能" class="headerlink" title="交换单元的性能"></a>交换单元的性能</h5><ul>
<li>容量：<br>交换单元所有入线可以同时送入的总的信息量</li>
<li>接口：<br>交换单元需要规定自己的信号接口标准，即信号形式、速率及信息流方向</li>
<li>功能：<br>点到点、点到多点</li>
<li>质量：<br>完成交换动作的速度、任何情况下是否能完成指定连接、信息经过交换单元是否有损伤(时间、语义)</li>
</ul>
<h5 id="连接、连接方式"><a href="#连接、连接方式" class="headerlink" title="连接、连接方式"></a>连接、连接方式</h5><p>连接</p>
<ul>
<li>集合描述法</li>
<li>函数描述法</li>
</ul>
<p>连接方式</p>
<blockquote>
<p>直线连接<br>交叉连接（交换置换）<br>蝶式连接<br>均匀洗牌置换<br>间隔交叉连接（方体置换）</p>
</blockquote>
<h4 id="开关阵列"><a href="#开关阵列" class="headerlink" title="开关阵列"></a>开关阵列</h4><p>在每条入线和每条出线直接都各自接上一个开关，构成开关阵列。</p>
<ul>
<li>开关的位置：入、出线交叉点</li>
<li>开关的表示：$K_{ij}$（i 为入线，j 为出线）</li>
<li>开关的状态：通、断</li>
<li>开关的种类：单向、双向</li>
</ul>
<p>实现：全连通交换单元、部分连通交换单元、多路选择器……</p>
<blockquote>
<p>开关阵列的特性：<br>可以很容易的实现点到多点的传输，也就是说容易实现广播功能<br>开关阵列的时延，从（每路）入线到出线延迟时间均等<br>控制信加暗淡<br>交换单元性能依赖于所使用的开关（电子的快，机械的慢）<br>适用于构成较小的交换单元（开关num反应实现复杂度和成本高低）</p>
</blockquote>
<p>实际使用的开关阵列</p>
<ol>
<li>继电器</li>
<li>模拟电子开关</li>
<li>数字电子开关</li>
</ol>
<h4 id="空间（空分）交换单元"><a href="#空间（空分）交换单元" class="headerlink" title="空间（空分）交换单元"></a>空间（空分）交换单元</h4><p>也叫<strong>空间接线器（Space Switch）</strong>，简称 <strong>S 单元</strong>或 <strong>S 接线器</strong> 。 用来完成多个输入服用先与多个输出复用线之间的空间交换，而不改变其时隙位置。</p>
<blockquote>
<p>每条线都是PCM，开关阵列不一定是PCM，但是S接线器是一定是PCM，也就是每一路上面有很多个时隙（老师举例子是32<br>路PCM）。专为话音通信设计的。<br>特别的，S接线器，入线和出线的数目都是相等的，而且每条线的（whatever 入还是出）传输速率都是一样样的。</p>
</blockquote>
<ul>
<li>构成：<ul>
<li>交叉点矩阵（开关阵列）</li>
<li>控制存储器（CM，Control Memory）</li>
</ul>
</li>
<li>功能：输入输出线之间的空间交换</li>
<li>S 接线器所含 CM 数量等于入（出）线数</li>
<li>每个 CM 含有的存储单元个数等于入（出）线上的复用时隙数</li>
<li>每个存储单元为 m 位 bit，且满足$N \le 2^m$，其中 N 为接线器的入（出）线数</li>
<li>CM 具有输入控制方式与输出控制方式。<ul>
<li>输入控制方式<br>关于CM里面记得是什么：<br>左侧的0~n-1是时隙的编号，如果按照老师说的是32路PCM，那么这里的n&#x3D;32<br>横着的是0-N-1，表示一共是N条入线（出线）<br>因为是输入控制方式，格子里面填写的是出线的序号<br>比如[30,3]&#x3D;8,意思就是第三条入线的第30个时隙应该输出到第八条出线上，至于输出到第八条出线的哪个时隙上，因为S接线器不改变时隙，只改变空间，笔者认为应该是输出到第八条线的第30个时隙。<br>&#x3D;&#x3D;这里还需要注意是是，CM中一共有N个<strong>控制存储器</strong>，而对于每个控制存储器，它的存储单元数目&#x3D;n，而bit数&#x3D;$\lceil log_2N \rceil$&#x3D;&#x3D;<br><img src="https://api2.mubu.com/v3/document_image/c9abf0e6-4c2e-4b89-b229-d60f578513a3-16175743.jpg" alt="2"></li>
<li>输出控制方式 &#x3D;&#x3D;容易实现多播！&#x3D;&#x3D;<br><img src="https://api2.mubu.com/v3/document_image/da1af8d1-5eab-4711-aa0a-66a8f8fb1039-16175743.jpg" alt="3"></li>
</ul>
</li>
<li>空间交换单元的基本特点：<ul>
<li>只完成空间交换，不进行时隙交换</li>
<li>空间接线器按时分方式工作</li>
<li>输<u>出</u>控制方式易于实现多播</li>
</ul>
</li>
</ul>
<blockquote>
<p>每秒钟抽样8000帧(???&#x2F;&#x2F;这个哪来的？？？)，每一帧中有32个时隙，所以改变的周期是3.9$\mu s$<br><img src="https://api2.mubu.com/v3/document_image/397e2c45-52e4-49d0-b806-b83d572918e2-16175743.jpg" alt="image.png"></p>
</blockquote>
<h4 id="时间（时分）交换单元"><a href="#时间（时分）交换单元" class="headerlink" title="时间（时分）交换单元"></a>时间（时分）交换单元</h4><p>这个玩意儿，其实只有一条线的输入和输出。<br>大家说的N路输入输出都是指的PCM，也就是说，本来就一个输入的口和输出的口，只是时隙不同。这一点非常重要，记住这个才可能理解后面的共享存储器和共享总线的工作机制。</p>
<h5 id="时分交换单元的一般构成"><a href="#时分交换单元的一般构成" class="headerlink" title="时分交换单元的一般构成"></a>时分交换单元的一般构成</h5><p>分为：共享存储器型交换单元、共享总线型交换单元。</p>
<p>共享存储器型：共 2N 个出入线缓存。</p>
<ul>
<li>入线缓存控制读出</li>
<li>出线缓存控制写入</li>
</ul>
<p>共享总线型：总线按照时隙轮流分配给入线控制部件和出线控制部件使用</p>
<p>$kNV&#x3D;B&#x2F;T$（N 为入线数、V 为入线速率、B 为每时隙传送比特数、T 为时隙长度，k 为时隙分配因子）</p>
<h5 id="时间接线器的构成"><a href="#时间接线器的构成" class="headerlink" title="时间接线器的构成"></a>时间接线器的构成</h5><ul>
<li>T 接线器：共享存储器型SE<ul>
<li>话音存储器（SM，Speech Memory）：暂存话音的数字编码信息<ul>
<li>存储单元个数等于 PCM 线路每帧时隙数；每单元至少 8bit（一路话音）</li>
</ul>
</li>
<li>控制存储器（CM，Control Memory）<ul>
<li>存储单元个数等于 SM；每单元至少$log_2n（n 为时隙数）$比特</li>
</ul>
</li>
<li>这俩其实是形成了一个映射，假设是输出控制，那么顺序写入的数据被顺序存储到SM话音存储器中去，数组下标与到来顺序存在一一对应，而CM相当于存储了一个对应关系，把构造的一个新的帧的每个时隙都对应了一个输入时隙的下标，这样根据CM里面的信息就可以按照原来的帧构造一个仅时隙顺序不同的新帧然后发送。</li>
<li>如果是输入控制，那么输出的顺序就是SM里面的信息，一毛一样的，相当于输入来的时候就在一边接收一边构造输出的新帧了，它是存的时候看着CM里面的信息存，这种CM刚好是上面那个输出控制的CM横纵坐标反过来。</li>
</ul>
</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/bddbe224-219d-48f5-b1c6-f3809af42395-16175743.jpg" alt="2"></p>
<ul>
<li>输出控制：顺序写入、控制读出<ul>
<li>前半周期写入，后半周期读出（SM）</li>
<li>前半周期写入，后半周期读出（CM）<br><img src="https://api2.mubu.com/v3/document_image/2816def7-c845-4750-ab81-1219b03c1af8-16175743.jpg" alt="2"></li>
</ul>
</li>
</ul>
<p>缺点：复用级别越高，对控制电路要求越高，无法达成很大规模；<strong>时隙转换延迟不定</strong>。</p>
<ul>
<li>输入控制：<ul>
<li>前半周期读出，后半周期写入（SM）</li>
<li>前半周期写入，后半周期读出（CM）<br><img src="https://api2.mubu.com/v3/document_image/59e893f8-d3c4-422a-8fa3-4a40bec1e83b-16175743.jpg" alt="2"></li>
</ul>
</li>
</ul>
<h3 id="交换网络"><a href="#交换网络" class="headerlink" title="交换网络"></a>交换网络</h3><p>Def:交换网络是由（若干个）交换单元按照一定的拓扑结构拓展而成的。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="单级交换网络"><a href="#单级交换网络" class="headerlink" title="单级交换网络"></a>单级交换网络</h5><p>由一个或多个位于同一级交换单元构成的交换网络，信息从交换网络<strong>入线到出线只经过一个交换单元</strong>，并且<strong>同一级多个交换单元入线和出线之间可建立连接（交换单元需要发挥交换作用而非直连,别管单极还是多级，这玩意儿得是个网络嗷）</strong>。</p>
<h5 id="多级（k-级）交换网络"><a href="#多级（k-级）交换网络" class="headerlink" title="多级（k 级）交换网络"></a>多级（k 级）交换网络</h5><p>如果一个交换网络中的交换单元可以分为K级，顺序明明为第1，2，…k级</p>
<ul>
<li>所有入线都只与第 1 级连接。</li>
<li>所有第 1 级交换单元都只与入线和第 2 级连接。</li>
<li>所有第 2 级交换单元都只与第 1 级和第 3 级连接。</li>
<li>所有第 k 级交换单元都只与第 k-1 级和出线连接。</li>
</ul>
<h5 id="有阻塞网络、无阻塞网络"><a href="#有阻塞网络、无阻塞网络" class="headerlink" title="有阻塞网络、无阻塞网络"></a>有阻塞网络、无阻塞网络</h5><p>交换网络的阻塞是指从交换网络不同输入端来的信息在交换网络中交换时发生了<strong>对同一公共资源争抢</strong>的情况﹐这时在竞争资源中失败的信息就会被阻塞,直到这个公共资源被释放。</p>
<ul>
<li>内部竞争：同时要交换的两路信息同抢交换单元内部的通路资源。</li>
<li>出线竞争：不同入端来的信息同时争抢交换网络同一个输出端口而发生的竞争。</li>
</ul>
<h6 id="无阻塞网络"><a href="#无阻塞网络" class="headerlink" title="无阻塞网络"></a>无阻塞网络</h6><ul>
<li><strong>严格无阻塞交换网络</strong>：任何时刻都可以在交换网络中建立一个连接（只要该连接起点、终点是空闲的）而不影响已建立的连接。（只要需要交换的入线与出线空闲，就可以通过交换网络建立一个连接。）</li>
<li><strong>可重排无阻塞网络</strong>：只要需要交换的入线与出线空闲，就可以通过交换网络直接地或对已有连接进行重排之后建立一个连接。</li>
<li><strong>广义无阻塞网络</strong>：存在一种精巧的选路方法，使得只要需要交换的入线与出线空闲，<strong>不必重排</strong>，就可以通过交换网络建立连接。</li>
</ul>
<h5 id="单通道网络、多通道网络"><a href="#单通道网络、多通道网络" class="headerlink" title="单通道网络、多通道网络"></a>单通道网络、多通道网络</h5><p>任一条入线和出线之间只存在唯一的一条通路，则为单通道网络。</p>
<blockquote>
<p>对于2x2的交换网络，可以是两级的，也可以是三级的，三级交换网络的好处是：可以有多条通路，所以多接一级不是无意义的浪费。</p>
</blockquote>
<h3 id="CLOS网络"><a href="#CLOS网络" class="headerlink" title="CLOS网络"></a>CLOS网络</h3><p>假设CLOS网络有M条入线和N条出线,如果M&#x3D;N,称该CLOS网络为对称的CLOS网络,否则为非对称的CLOS网络。对称的CLOS网络使用广泛，<strong>下文介绍的CLOS网络除特别说明一般指对称的CLOS网络</strong>。</p>
<p><img src="https://api2.mubu.com/v3/document_image/82fc201f-61fb-4d52-a654-36d6e70f6cd1-16175743.jpg" alt="2"></p>
<blockquote>
<p>CLOS网络可以是3级的，5级的，7级的。</p>
</blockquote>
<p>严格无阻、可重排无阻公式和构造</p>
<p>3 级 CLOS 严格无阻：$m \geq 2n-1$<br>why？<br><img src="https://api2.mubu.com/v3/document_image/a528db77-0051-4200-8526-a4539ee81740-16175743.jpg" alt="2"></p>
<p>3 级 CLOS 可重排无阻：$m \geq n$<br>（？？没太懂，凭什么这样就可重排了）</p>
<h3 id="TST网络"><a href="#TST网络" class="headerlink" title="TST网络"></a>TST网络</h3><p><img src="https://api2.mubu.com/v3/document_image/5b1b5818-f3cd-427a-b103-e2f52527c3f7-16175743.jpg" alt="2"></p>
<p>T接线器只交换时隙，入线和出线都是同一条PCM； S接线器只交换物理线路，不改变时隙<br><img src="https://api2.mubu.com/v3/document_image/72cec5ea-6501-4d67-b639-152fdcec1d3b-16175743.jpg" alt="2"></p>
<p>阻塞特性<br>完全无阻塞的条件：m（内部时隙数）&#x3D;2n（输入时隙数）</p>
<h3 id="BANYAN-网络"><a href="#BANYAN-网络" class="headerlink" title="BANYAN 网络"></a>BANYAN 网络</h3><p>特性：单通路、有阻塞（内部竞争）、基于树形结构所以能自选路由。</p>
<p>我们要讨论的是L级的，规则的，（2x2）的矩形的banyan网络<br><img src="https://api2.mubu.com/v3/document_image/de027d12-676c-4987-a6ee-017f947ee1b5-16175743.jpg" alt="2"><br>banyan网络的级数跟几乘几是有关系的：<br>按照规律进行banyan网络的递归构造<br>构造 $N \times N$ 的 BANYAN 网络，需要 $\log_2N$ 级，每级 $N&#x2F;2$ 个 $2\times2$ 交换单元，共 $(N&#x2F;2)\times \log_2N$ 个。拿两个 $n \times n$ 网络，将 $n$ 个 $2\times 2$ 交换单元作为一级通过混洗连接到前部、或者通过反转混洗连接到尾部</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>树形结构的特性<ul>
<li>从banyan的任意</li>
</ul>
</li>
<li>自选路由特性<br><img src="https://api2.mubu.com/v3/document_image/751ec8d2-954f-4980-b2a1-ba939cf9866d-16175743.jpg" alt="2"></li>
<li>单通路特性<ul>
<li>从任意入段到任一出端，有且只有一条通道</li>
</ul>
</li>
<li>内部阻塞特性<ul>
<li>banyan网络的任意一条人线到任意一条出线之间都具有惟一的一条通路,但各入线与出线之间的单通路并非是完全分离的,会有公共的内部链路,因此内部竞争是不可避免的。如图所示,在某一时刻,信息要从人线0交换到出线3,同时还有信息要从入线﹖交换到出线2,所以在这一时刻会在第2级与第3级的公共链路上产生竞争,发生阻塞。banyan是有阻塞的网络。<br><img src="https://api2.mubu.com/v3/document_image/765a6644-48ef-46f6-b5df-0e46d8271d69-16175743.jpg" alt="2"></li>
</ul>
</li>
<li>内部阻塞的解决<ul>
<li>增加网络级数（如 BENES 网络），每增加一级，通路数翻倍。但同时失去唯一路径和自选路特性。<br><img src="https://api2.mubu.com/v3/document_image/23566d0b-ba7c-439e-96a5-e2c17392f577-16175743.jpg" alt="2"></li>
<li>使用扩展型或膨胀型 BANYAN 网络。<br><img src="https://api2.mubu.com/v3/document_image/dc87d4c7-04f3-44c7-bd1e-dce6249939b1-16175743.jpg" alt="2"></li>
<li>BATCHER-BANYAN（排序-BANYAN）网络：严格无阻塞、结构规整、自动选路。<ul>
<li>banyan 网络存在着内部竞争,研究表明,如果将banyan网络输入的全部信息按交换的出线地址(也就是选路标签)进行单调递增(或递减)排列,那么就可以解决banyan网络的内部阻塞。为了满足banyan网络的无阻塞条件,可以在banyan 网络前加人排序网络—batcher网络,构成batcher-banyan网络(B-B网络)。</li>
<li><img src="https://api2.mubu.com/v3/document_image/23566d0b-ba7c-439e-96a5-e2c17392f577-16175743.jpg" alt="2"></li>
</ul>
</li>
<li>减少入线的信息量，加大入线缓存。</li>
<li>增加平面数，构造多通道交换网络。（几平面就是几倍的交换单元）<blockquote>
<p>多平面banyan 的每个输人端的信息可以随机地选择某个平面,也可以按负荷均分原则分配到各个平面,还可以广播到所有的平面。显然,平面数越多,内部冲突的机会越少。在一定的入线数目(或出线数目)N值下,平面数增加到–定值后可以得到无阻塞网络。多平面ban-yan 网络可显著提高网络的吞吐量,不仅如此,还可提高网络的可靠性,其中一个交换平面出&#96;错后,并不会影响到整个交换网络的连接,其缺点是硬件结构复杂。</p>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/3bf2e24f-ce5a-428a-9e1b-05471745c626-16175743.jpg" alt="2"></p>
</li>
</ul>
</li>
</ul>
<h3 id="BENES网络"><a href="#BENES网络" class="headerlink" title="BENES网络"></a>BENES网络</h3><p> benes网络实际上相当于两个banyan类网络背对背相连接,然后将中间两级合并为1级。由于每个banyan类网络有Ib*N级,因此, benes网络共有21bN一1级。</p>
<p><img src="https://api2.mubu.com/v3/document_image/6b9b0ad2-ed67-4d25-86b3-dde0f2ab8cf3-16175743.jpg" alt="2"></p>
<h2 id="chapter3-电路交换"><a href="#chapter3-电路交换" class="headerlink" title="chapter3-电路交换"></a>chapter3-电路交换</h2><h2 id="chapter4-分组交换"><a href="#chapter4-分组交换" class="headerlink" title="chapter4-分组交换"></a>chapter4-分组交换</h2><h2 id="chapter5-信令与协议"><a href="#chapter5-信令与协议" class="headerlink" title="chapter5-信令与协议"></a>chapter5-信令与协议</h2><p>信令概念、NO7.信令系统&amp;信令网</p>
<h2 id="chapter6-移动交换"><a href="#chapter6-移动交换" class="headerlink" title="chapter6-移动交换"></a>chapter6-移动交换</h2><p>GSM GFRS 3G 4G 5G</p>
<h2 id="chapter7-新一代融合网络交换（控制）技术"><a href="#chapter7-新一代融合网络交换（控制）技术" class="headerlink" title="chapter7-新一代融合网络交换（控制）技术"></a>chapter7-新一代融合网络交换（控制）技术</h2>]]></content>
      <categories>
        <category>笔记 - 交换原理</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>交换原理</tag>
      </tags>
  </entry>
  <entry>
    <title>凌晨2点，👴未眠</title>
    <url>/2022/04/08/%E5%87%8C%E6%99%A82%E7%82%B9%EF%BC%8C%E7%88%B7%E6%9C%AA%E7%9C%A0/</url>
    <content><![CDATA[<p>先说说没睡的原因。<br>👴从下午开始睡大觉，十点多睡醒了，以至于到现在还是睡不着。另外的一个现在仍旧非常精神的原因是睡醒之后胃不舒服不想喝纯白开，随便搞了点咖啡让自己好受点。<br>睡醒之后看了会儿美人。<br>跟<a href="https://mushroom323.github.io/">🍄神</a>讨论了点儿计网，由于躺着脑子根本不动所以爬起来了。<br>之后听了听歌，发现<a href="https://www.axsl.site/">老板</a>亦未寝。</p>
<p>老板给👴发了关于“大和抚子”的废话。<br>👴发表了非常<del>喜爱</del>欣赏明艳大气美女子的言论。</p>
<p>👴开始看闲书（某z姓大佬推荐的好书）。</p>
<blockquote>
<p>👴：<br><img src="https://s3.bmp.ovh/imgs/2022/04/08/e949dd6f6bd556cd.png" alt="闲书"><br>老板：你可以把自己🧠，拿出来。</p>
</blockquote>
<p>👴们讨论了大脑的跳跃性思维导致我们无法控制自己的大脑去做什么这件事。<br>接着就讨论起到底有没有“真正喜欢的事情”这个话题。（相关性并不强的俩话题，或许佐证了大脑自己愿意想什么是不怎么受👴们控制的）<br>👴本来以为自己没有什么喜欢做的事情。<br>然后发现满足“因为喜欢所以可以一直做下去不产生任何反感情绪和不耐烦的事情”条件的<br>👴还是有的<br>至少在看美人这件事上👴完全满足这个条件（</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://s3.bmp.ovh/imgs/2022/04/08/887278b873c108fc.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">美人论</div>
</center>

<p>最后来点闲书的摘抄</p>
<ul>
<li><p>记得过去老师讲解《论语》中曾子说的“吾日三省吾身”，有两种解释，第一种是我每一天都自我反省三（多）次；第二种是我每一天都以下列三件事来自我反省；管他每天到底是“反省三次”，还是“列出三件事来反省”，都并不重要。<br>  <strong>重要的是，他每天都在“反省”</strong>。<br>  作为一个真正意义上的人，好像没有什么比这个更重要了。</p>
</li>
<li><p>长期来看，我们都是要死的。————约翰·梅纳德·凯恩斯</p>
</li>
<li><p>即使是在极端恶劣的环境里，人们也会拥有一种最后的自由，那就是选择自己的态度的自由。————维克托·弗兰克</p>
</li>
<li><p>最常见的误解就是，当我们觉得自己痛苦时，总是不自觉的把自己想象成全世界最痛苦的人。这是非常自然的，因为我们自己的痛苦我们亲身感受，而别人的痛苦我们又很难真正做到感同身受。</p>
</li>
<li><p>所以说，怀旧是一种错觉。甚至它更可能只不过是幻觉。有人用过这么一个比喻：如果说记忆本身是葡萄，那么回忆的过程就是发酵。</p>
</li>
<li><p>因为人生苦短，如果成功太慢那么幸福必然减半。</p>
</li>
<li><p>我个人觉得，在工作和学习上控制这种天性是最重要的。为了能在这方面控制住自己的天性，有的时候，在其他方面稍微放纵一下是非常有必要的。相信我，偶尔大醉一场没什么不好。偶尔连续打上两天两夜的牌不仅有助于身心健康，也是一种很好的社交活动。<br>  但是，在工作和学习上，坚决不要放纵。工作和学习都是艰苦的，路程都是漫长的，都不可能一蹴而就。经验告诉我们，在工作和学习的过程中当然需要技巧，但是，当场见效的技巧少之又少，而且，就算找到了，也只不过是两种情况之一：a.寻找这个技巧已经花费了太多的时间；b.这个技巧可能有后遗症，只不过是现在还不知道而已。</p>
</li>
<li><p>一个人不应该过分苛求自己————尽管同时也不应该过分放纵自己</p>
</li>
</ul>
<p>现在就快凌晨四点了。<br>川端康成在凌晨四点看海棠花未眠，<br>👴在凌晨看了看<a href="https://baike.baidu.com/item/%E6%B5%B7%E6%A3%A0%E8%8A%B1/969869">海棠花的百度百科</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>少年听雨</tag>
      </tags>
  </entry>
  <entry>
    <title>形式语言与自动机_3(part)</title>
    <url>/2022/04/17/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA_chapter3/</url>
    <content><![CDATA[<h2 id="3-9-右线性语言的性质"><a href="#3-9-右线性语言的性质" class="headerlink" title="3.9 右线性语言的性质"></a>3.9 右线性语言的性质</h2><ol>
<li><p>等价和可区分的概念<br> 设DFA  M &#x3D; (Q，T，δ，q0，F)<br> 对不同的状态q１， q２∈Q 和<mark>每个</mark>ω∈T*，<br> 如果有</p>
 <!---$(q_１,\omega)┣* (q，ε)$ 和 $(q２,\omega)┣* (q，ε)$ 且 $q\in F$ ，
 则称q１与q２状态等价. 记为 $q_１\equiv q_２$  
 否则，称 $q_１$， $q_２$ 可区分。--->
<p> <img src="https://api2.mubu.com/v3/document_image/3811e33a-5ed3-496b-a7d1-6236a065d13e-16175743.jpg"></p>
</li>
<li><p>不可达状态<br>如果不存在任何$\omega \in T^*$，使$(q_０,\omega)┣* (q,\varepsilon)$，<br>则称状态q∈Q为不可达状态。</p>
</li>
<li><p>最小化<br>若DFA Ｍ不存在互为等价状态及不可达状态，则称DFA Ｍ是最小化的。</p>
</li>
</ol>
<h2 id="最小化算法"><a href="#最小化算法" class="headerlink" title="最小化算法"></a>最小化算法</h2><p>一个DFA Ｍ的最小化，是把Ｍ的状态集Ｑ构成一个划分。即: 任何两个子集的状态都是可区分的；同一子集中的任何两个状态都是等价的。之后，每个子集用一个状态代表，并取一个状态名。<br>构成划分的步骤:<br>  构成基本划分 $\Pi$&#x3D;{$\Pi^{‘}$, $\Pi^{‘’}$}， ($\Pi^{‘}$为终态集， $\Pi^{‘’}$为非终态集)<br>  细分 $\Pi$ &#x3D;{$\Pi^1$，$\Pi^2$,….., $\Pi^n$}，　　 $\forall \Pi^i$  ∈ $\Pi$<br> 　　　 $\Pi^i &#x3D;{ q_１， q_２，…， q_ｍ}$<br>    当输入任意字符a时，若$\Pi^i$中的状态经标a的边可到达的状态集的元素分属于两个不同的子集中，则将$\Pi^i$细分为两个子集.<br>重复步骤(2)，直至不可再细分，得到Ｍ1.<br>若Ｍ1中有不可达状态，将其删除，Ｍ1便是最小化的.</p>
<p>优化步骤：<br><img src="https://api2.mubu.com/v3/document_image/bbf4f270-d234-4327-a011-da023cfb52bd-16175743.jpg"></p>
<p>一个例子：</p>
<p><img src="https://api2.mubu.com/v3/document_image/6815aa4e-3004-48c2-bc91-7665a8a27768-16175743.jpg"></p>
<p>填表法的例子：</p>
<p><img src="https://api2.mubu.com/v3/document_image/7220baf0-ae6a-4d6e-a687-5675b31cdcc5-16175743.jpg"></p>
<!---解释见[视频]()(还没上传)--->

<h2 id="针对正则语言的-Pumping-引理"><a href="#针对正则语言的-Pumping-引理" class="headerlink" title="针对正则语言的 Pumping 引理"></a>针对正则语言的 Pumping 引理</h2><p>中文是 泵浦</p>
<p>泵浦引理的性质和地位：</p>
<ul>
<li>正则语言应满足的一个<strong>必要条件</strong></li>
<li>用于<strong>判定</strong>给定的语言<strong>不是正则集</strong>。</li>
</ul>
<p>物理意义：当给定一个正则集和该集合上一个足够长的字符串时，在该字符串中能找到一个非空的子串，并使子串重复，从而组成新的字符串。该新串必在同一个正则集内。</p>
<p>定理：<br>设L是正则集，存在常数k，对字符串$ω\in Ｌ$ 且$｜ω｜≥ｋ$，<br>则ω可写成$ω_1ω_0ω_２$，其中$｜ω_1ω_0｜≤ｋ$，$｜ω_0｜＞０$，<br>对所有的ｉ≥0有$ω_1ω_0^iω_２$∈Ｌ。</p>
<p>证明：<br>运用了鸽巢原理<br>pumping特性：<br>任一长度不小于状态数目的字符串所标记的路径上，必然出现重复的状态.</p>
<p><img src="https://api2.mubu.com/v3/document_image/6bb5920c-c175-4d29-89e6-c4e8f5261102-16175743.jpg"></p>
<p>泵浦引理的应用</p>
<p><img src="https://api2.mubu.com/v3/document_image/13461ce8-7fa2-4175-ba03-0965e5837558-16175743.jpg"></p>
<p>注意：ω的取法有技巧， 一定要能推出矛盾才可以。<br>如：<br><img src="https://api2.mubu.com/v3/document_image/51cb931e-caac-4349-b905-3ce69bc8ce2c-16175743.jpg"></p>
<p>右线性语言的封闭性 (已经忘光光了草哦)</p>
<blockquote>
<p>自动机到了终态但是串没读完不算到了终态<br> 当从带空的NFA到不带空的NFA转换时，如果状态q0不能接受b，还不能下定论，应该看q0的空闭包能不能接受b</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>形式语言与自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>形式语言与自动机_4</title>
    <url>/2022/05/12/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA_chapter4/</url>
    <content><![CDATA[<h1 id="第四章-上下文无关文法与下推自动机"><a href="#第四章-上下文无关文法与下推自动机" class="headerlink" title="第四章  上下文无关文法与下推自动机"></a>第四章  上下文无关文法与下推自动机</h1><p>上下文无关文法：CFG(contex free grammar)<br>2型文法，产生式形如A-&gt;a，A$\in$N</p>
<p><a href="https://api2.mubu.com/v3/document_image/1647178722462b691.jpg">几种文法的特点整理</a></p>
<p>对应的识别器：下推自动机<br>PDA（push down Automata）<br>PDA由输入带，有限控制器和下推栈组成<br><img src="https://api2.mubu.com/v3/document_image/24b4fce5-8f87-4dca-84a9-9352955a2392-16175743.jpg" alt="1"></p>
<h2 id="归约和推导"><a href="#归约和推导" class="headerlink" title="归约和推导"></a>归约和推导</h2><p>推理字符串是否属于文法所定义的语言</p>
<ul>
<li>一种是自下而上的方法，称为递归推理(recursive inference），递归推理的过程习称为归约；</li>
<li>一种是自上而下的方法，称为推导（derivation）.</li>
<li>归约过程   将产生式的右部（body）替换为产生式的左部（ head ）.</li>
<li>推导过程   将产生式的左部（ head ）替换为产生式的右部（ body ）</li>
</ul>
<p>例子：<br><img src="https://api2.mubu.com/v3/document_image/9bd456a1-7f21-40cb-aec1-055eeccc42b8-16175743.jpg" alt="归约"><br><img src="https://api2.mubu.com/v3/document_image/57a9fc01-11d8-4b9b-a469-09a31d167672-16175743.jpg" alt="推导"></p>
<ul>
<li>最左推导(leftmost derivations)<br>若推导过程的每一步总是替换出现在最左边的非终结符。<br><img src="https://api2.mubu.com/v3/document_image/9fb0447a-54b0-4f72-b822-d55cec7336c9-16175743.jpg" alt="l"></li>
<li>最右推导(rightmost derivations)<br>若推导过程的每一步总是替换出现在最右边的非终结符。<br><img src="https://api2.mubu.com/v3/document_image/bf95a2f6-8124-49c1-bd4c-7a68e69df74f-16175743.jpg" alt="r"></li>
</ul>
<h2 id="推导树和文法的二义性"><a href="#推导树和文法的二义性" class="headerlink" title="推导树和文法的二义性"></a>推导树和文法的二义性</h2><h3 id="推导树"><a href="#推导树" class="headerlink" title="推导树"></a>推导树</h3><p>用图的方法表示一个句型的推导，这种图称为推导树（也称语法树或语法分析树）<br>文法的起始符为根，树的枝结点标记是非终结符，叶结点标记为终结符或$\sigma$。<br>若枝结点有直接子孙x1, x2,…, xk，则文法中有生成式A→x1x2…xk<br><img src="https://api2.mubu.com/v3/document_image/378f4ab9-9951-475b-996c-9cc934efc070-16175743.jpg" alt="li"><br><img src="https://api2.mubu.com/v3/document_image/378f4ab9-9951-475b-996c-9cc934efc070-16175743.jpg" alt="tu"><br>推导树是对文法G中一个<u>特定句子形式</u>的派生过程所做的一种自然描述。</p>
<ul>
<li>边缘<br>叶子从左向右组成的字符串称为推导树的边缘。</li>
</ul>
<h3 id="归约、推导与分析树之间关系"><a href="#归约、推导与分析树之间关系" class="headerlink" title="归约、推导与分析树之间关系"></a>归约、推导与分析树之间关系</h3><p>归约<br><img src="https://api2.mubu.com/v3/document_image/034d00dd-d424-4ef1-a4ed-bf831eb1516f-16175743.jpg" alt="归约"><br>推导<br><img src="https://api2.mubu.com/v3/document_image/bfa38244-02b0-4e7b-97f5-16c4befc3faf-16175743.jpg" alt="推导"><br>关系<br><img src="https://api2.mubu.com/v3/document_image/e9d33c57-17f4-4416-b8a8-63bad4e38309-16175743.jpg" alt="关系"><br>证明2-&gt;5:<br>设2型文法G&#x3D;（N，T，P，S），如果存在S<img src="https://api2.mubu.com/v3/document_image/03811fd1-79b9-46ae-9187-fee25974c922-16175743.jpg" alt="推导出">ω，当且仅当文法G中有一棵边缘为ω的推导树。</p>
<ul>
<li>子树：<br>一棵派生树的子树，是树中的某个顶点连同它的全部后裔，以及连接这些后裔的边。<br><a href="https://api2.mubu.com/v3/document_image/09c3c42d-5fd5-415e-983d-4ac2fcbf359e-16175743.jpg">证明</a><br><a href="https://api2.mubu.com/v3/document_image/87352b24-c498-4dae-b762-b8d55e66ec0a-16175743.jpg">证明步骤1</a><br><a href="https://api2.mubu.com/v3/document_image/4650faf7-c73d-46df-aa3d-2f6c57288b96-16175743.jpg">证明步骤2</a></li>
</ul>
<h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><p>2型文法是二义的,当且仅当对于句子ω∈L(G),存在两棵不同的具有边缘为ω的推导树。<br>(即：如果文法是二义的, 那么它所产生的某个句子必然能从不同的最左(右)推导推出)。</p>
<ul>
<li>可有二个文法,一个有二义,一个无二义,但产生相同的语言.</li>
<li>可否通过变换消除二义性? —— 无一般的算法!</li>
</ul>
<h2 id="上下文无关文法的变换"><a href="#上下文无关文法的变换" class="headerlink" title="上下文无关文法的变换"></a>上下文无关文法的变换</h2><ol>
<li>CFG 的简化<ul>
<li>消无用符号</li>
<li>消$\varepsilon$产生式</li>
<li>消单产生式</li>
</ul>
</li>
<li>对生成式形式进行标准化</li>
</ol>
<p>生成式的标准形式:</p>
<ol>
<li>Chomsky范式 ：<br>  CNF - Chomsky Normal Form<br>  <img src="https://api2.mubu.com/v3/document_image/0b972e9e-9103-4285-9f11-7f404d2b45d5-16175743.jpg" alt="CNF"></li>
<li>Greibach范式：(GNF)<br>  <img src="https://api2.mubu.com/v3/document_image/8d0a5097-0bbf-4510-9abb-af14a4c8335e-16175743.jpg" alt="GNF"></li>
</ol>
<h3 id="消去无用符号"><a href="#消去无用符号" class="headerlink" title="消去无用符号"></a>消去无用符号</h3><h4 id="有用符号X"><a href="#有用符号X" class="headerlink" title="有用符号X"></a>有用符号X</h4><p><img src="https://api2.mubu.com/v3/document_image/5c46692f-3ba3-4bd6-9dba-7ee1a79a2591-16175743.jpg" alt="X"></p>
<ul>
<li>生成符号 generating symbol<br><img src="https://api2.mubu.com/v3/document_image/de1c8e4b-b028-48bf-933f-cd2937e22558-16175743.jpg" alt="生成符号"></li>
<li>可达符号 reachable symbol<br><img src="https://api2.mubu.com/v3/document_image/5c6aef7e-f00b-4260-9193-b75193bee158-16175743.jpg" alt="可达符号"></li>
</ul>
<h4 id="无用符号"><a href="#无用符号" class="headerlink" title="无用符号"></a>无用符号</h4><ul>
<li>非生成符号</li>
<li>不可达符号</li>
</ul>
<h4 id="消去无用符号的步骤"><a href="#消去无用符号的步骤" class="headerlink" title="消去无用符号的步骤"></a>消去无用符号的步骤</h4><ul>
<li>计算生成符号集</li>
<li>计算可达符号集</li>
<li>消去非生成符号、不可达符号</li>
<li>消去相关产生式</li>
</ul>
<h4 id="计算生成符号"><a href="#计算生成符号" class="headerlink" title="计算生成符号"></a>计算生成符号</h4><p>思路<br><img src="https://api2.mubu.com/v3/document_image/2872eb33-ddb9-4db1-8834-e79814953a22-16175743.jpg" alt="思路"><br>算法1:找出有用非终结符<br><img src="https://api2.mubu.com/v3/document_image/85a050c1-fc53-4c32-8bb9-ad81abfcd396-16175743.jpg" alt="算法1"><br>算法1图示:<br><img src="https://api2.mubu.com/v3/document_image/e8eeb259-84f4-4948-bced-32389df931f8-16175743.jpg" alt="图示"><br>一层层向外扩展，直至最外两层相等为止。所得集合即是算法1的有用符号。</p>
<h4 id="计算可达符号集"><a href="#计算可达符号集" class="headerlink" title="计算可达符号集"></a>计算可达符号集</h4><p>思路<br><img src="https://api2.mubu.com/v3/document_image/3af1f690-10fa-4b64-b311-f854d46d985c-16175743.jpg" alt="计算可达符号集"><br>算法2：找出有用符号（从S出发可达的符号）<br><img src="https://api2.mubu.com/v3/document_image/e8094e10-e4bf-4ad9-86b2-f034d639b972-16175743.jpg" alt="算法2"><br>图示<br><img src="https://api2.mubu.com/v3/document_image/0f604071-1898-407d-8229-5b6f406f9481-16175743.jpg" alt="图示"></p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p><img src="https://api2.mubu.com/v3/document_image/c9e673b9-0573-4f99-80d6-bdc67adbdef8-16175743.jpg" alt="lizi"><br>注意：在删除一个无用符号时，要把与它相关的式子也删掉。<br>并且，<mark>一定要先执行算法1，保证每个符号是生成符号，再执行算法2，保证每个符号是可达符号。否则可能会导致一些无用符号无法消除。</mark>（这个例子就是不这么干的反例）</p>
<p>一个定理：<br>任何非空的上下文无关语言,可由不存在无用符号的上下文无关语言产生(证明略)</p>
<h3 id="消去-varepsilon-产生式"><a href="#消去-varepsilon-产生式" class="headerlink" title="消去$\varepsilon$产生式"></a>消去$\varepsilon$产生式</h3><p>目的：方便文法的设计, 利于文法规范化.<br>影响：消去$\varepsilon$产生式, 除了文法不能产生字符串$\varepsilon$外，不会影响到原文法相应的语言中其它字符串的产生.</p>
<h4 id="可致空符号"><a href="#可致空符号" class="headerlink" title="可致空符号"></a>可致空符号</h4><p>nullable symbol<br><img src="https://api2.mubu.com/v3/document_image/daace5c0-2d0f-41d8-a022-f245a90d2803-16175743.jpg" alt="可致空符号"></p>
<h4 id="算法3-生成无-varepsilon-文法"><a href="#算法3-生成无-varepsilon-文法" class="headerlink" title="算法3: 生成无$\varepsilon$文法"></a>算法3: 生成无$\varepsilon$文法</h4><p>定义：若G的生成式中无任何$\varepsilon$产生式，或只有一个生成式S→$\varepsilon$且S不出现在任何生成式的右边，则称G为无$\varepsilon$文法。</p>
<p>思路：</p>
<p><img src="https://api2.mubu.com/v3/document_image/1d6d41c1-729e-4ac4-bf47-4e296f3ec652-16175743.jpg" alt="思路"></p>
<p><mark>算法步骤</mark></p>
<p><img src="https://api2.mubu.com/v3/document_image/c2829b36-1400-4476-8955-a96feefca3b5-16175743.jpg" alt="算法步骤"></p>
<p><img src="https://api2.mubu.com/v3/document_image/c9ff1e87-ea57-4e2f-967d-1afa35baf359-16175743.jpg" alt="2"><br>例子：<br><img src="https://api2.mubu.com/v3/document_image/c9c8141b-bc88-45af-8679-df1b572eaaff-16175743.jpg" alt="lizi"></p>
<h3 id="消去单产生式"><a href="#消去单产生式" class="headerlink" title="消去单产生式"></a>消去单产生式</h3><p>什么是单产生式<br>单产生式  形如 A-&gt;B 的产生式，其中A、B 为非终结符.<br>目的：<br>可简化某些证明，减少推导步数, 利于文法规范化.</p>
<h4 id="单元偶对-unit-pairs"><a href="#单元偶对-unit-pairs" class="headerlink" title="单元偶对 unit pairs"></a>单元偶对 unit pairs</h4><p><img src="https://api2.mubu.com/v3/document_image/7f563d59-edfa-4ab2-8303-90203d06e32d-16175743.jpg" alt="unit pairs"></p>
<h4 id="消去单产生式的算法"><a href="#消去单产生式的算法" class="headerlink" title="消去单产生式的算法"></a>消去单产生式的算法</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p><img src="https://api2.mubu.com/v3/document_image/ad2f4c73-516d-47c8-b469-9e1d07a124ce-16175743.jpg" alt="思路"></p>
<h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><p><img src="https://api2.mubu.com/v3/document_image/a2717996-4489-4e8c-8a3c-cc250d9a5e94-16175743.jpg" alt="算法步骤"><br>$N_A$可以理解成所有和A是单元偶对的非终结符的集合<br><img src="https://api2.mubu.com/v3/document_image/859f5d77-0587-4525-94b5-da4095c29ca6-16175743.jpg" alt="算法步骤2"></p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p><img src="https://api2.mubu.com/v3/document_image/c7867368-350a-44d0-89e7-3ef3810d6721-16175743.jpg" alt="例子"><br><img src="https://api2.mubu.com/v3/document_image/aeeffb80-9874-4111-a53c-905b59a41550-16175743.jpg" alt="例子2"><br><img src="https://api2.mubu.com/v3/document_image/ca9cfaa9-3519-4113-a5fa-a990f0f8c1cd-16175743.jpg" alt="例子3"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://api2.mubu.com/v3/document_image/0d85c3d2-3151-4d32-8e7b-1e30e8a4adf2-16175743.jpg" alt="小结"><br>注意 以上简化步骤的次序.<br>设 CFG  G 的语言至少包含一个非  的字符串，通过上述步骤从 G 构造 G1 ，则有 L(G1)&#x3D; L(G) - {$\varepsilon$}.<br>必须按照顺序的原因：<br>消去空生成式的时候，可能会引入一些单生成式，而消除单生成式的时候又可能引入一些无用符号。</p>
<h3 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h3><p>递归定义：<br><img src="https://api2.mubu.com/v3/document_image/7e94dd29-a89f-4f69-bd0b-42af73b3f5be-16175743.jpg" alt="dingyi"></p>
<h4 id="生成式的代换"><a href="#生成式的代换" class="headerlink" title="生成式的代换"></a>生成式的代换</h4><p>引理1：<br><img src="https://api2.mubu.com/v3/document_image/e8952fc6-9135-4689-929b-a8cd7e9763d6-16175743.jpg" alt="引理1"><br>一个小例子：<br><img src="https://api2.mubu.com/v3/document_image/2a7b7faa-e60d-4c0b-a749-5a977b7a2e72-16175743.jpg" alt="一个小例子："></p>
<h4 id="消除直接左递归"><a href="#消除直接左递归" class="headerlink" title="消除直接左递归"></a>消除直接左递归</h4><p>引理2<br><img src="https://api2.mubu.com/v3/document_image/7a19e78c-c34c-4c0b-8306-e92a46b1cf7f-16175743.jpg" alt="引理2"><br>例子：<br><img src="https://api2.mubu.com/v3/document_image/4e5120d2-63e7-476f-b65e-93b2faccee87-16175743.jpg" alt="例子："></p>
<h5 id="为什么要消除左递归？"><a href="#为什么要消除左递归？" class="headerlink" title="为什么要消除左递归？"></a>为什么要消除左递归？</h5><ol>
<li>以后的句法分析算法不适用于左递归,会引起死循环。</li>
<li>对于给定的2型文法, 该文法不存在无用符号, 无循环且是无ε生成式的文法, 为了消除G中可能存在的左递归, 构成一个等效的无左递归的文法G1, 可用算法5。</li>
<li>算法5在原理上与求解正规表达式方程组的算法类似.</li>
</ol>
<h5 id="算法5"><a href="#算法5" class="headerlink" title="算法5"></a>算法5</h5><p><img src="https://api2.mubu.com/v3/document_image/8b1fcac4-46ff-44bc-add8-e1bbb49e997b-16175743.jpg" alt="算法5"></p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p><img src="https://api2.mubu.com/v3/document_image/7d33cbe8-dd03-4731-a2fc-6cc3662ffef8-16175743.jpg" alt="示例"><br><img src="https://api2.mubu.com/v3/document_image/b7130afb-b6ba-4374-9bc4-b69a79cad139-16175743.jpg" alt="示例2"></p>
<h2 id="下推自动机"><a href="#下推自动机" class="headerlink" title="下推自动机"></a>下推自动机</h2><h2 id="上下文无关语言的性质"><a href="#上下文无关语言的性质" class="headerlink" title="上下文无关语言的性质"></a>上下文无关语言的性质</h2><h1 id="Chomsky范式和Greibach范式"><a href="#Chomsky范式和Greibach范式" class="headerlink" title="Chomsky范式和Greibach范式"></a>Chomsky范式和Greibach范式</h1><h2 id="Chomsky-范式"><a href="#Chomsky-范式" class="headerlink" title="Chomsky 范式"></a>Chomsky 范式</h2><p>2型文法G＝（N，T，P，S）<br>生成式形如：<br>A→BC和A→a<br>称为Chomsky Normal Format<br>特别的，若ε∈L（G），则S→ε是P的一个生成式，但<strong>S不能在任何其它生成式的右边</strong></p>
<p>构成步骤：</p>
<ol>
<li>消除ε生成式、无用符号、单生成式</li>
<li>引入新的非终结符，凑</li>
</ol>
<p><img src="https://api2.mubu.com/v3/document_image/2c0e2f24-d00e-4b33-9077-aa2c92baa578-16175743.jpg" alt="CNF"></p>
<h2 id="Greibach范式"><a href="#Greibach范式" class="headerlink" title="Greibach范式"></a>Greibach范式</h2><p>2型文法G＝（N，T，P，S）<br>若生成式的形式都是A→aβ，A∈N，a∈T，β∈N*<br>且G不含ε生成式，则称G为Greibach范式，记为GNF</p>
<p>构成步骤：</p>
<ol>
<li>2型文法变换为CNF。（A→a，A→BC形式）</li>
<li>对非终结符排序</li>
<li>假如按下标递增，不能出现$A1-&gt;A2\beta$（A2高于A1）<ol>
<li>把A2的生成式带入，直至满足上述条件</li>
</ol>
</li>
<li>消除左递归（只对最高的Ai进行消除左递归，消除完了之后Ai就会满足GNF形式，即终结符a开头，但会引入新的非终结符Ai’,这些新的非终结符优先级是最低的）</li>
<li>回代<ol>
<li>依次回代Ai到Ai-1，Ai-1到Ai-2….一直到右部首字符都为终结符</li>
</ol>
</li>
<li>将消除左递归时候引入的带’的右部进行代换，换成右部首字符都为终结符。</li>
</ol>
<p>GNF1：<br><img src="https://api2.mubu.com/v3/document_image/1f5f4619-f44c-4f1d-9120-7cd807e9874c-16175743.jpg" alt="GNF1"><br>GNF2：<br><img src="https://api2.mubu.com/v3/document_image/88f16a4c-5497-4016-b210-fde1e1179f3c-16175743.jpg" alt="GNF2"><br>GNF3：<br><img src="https://api2.mubu.com/v3/document_image/10a971db-617a-4b4f-8153-7db24755a189-16175743.jpg" alt="GNF3"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>形式语言与自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>【share】毛概教材2021</title>
    <url>/2022/03/01/%E6%AF%9B%E6%A6%82%E6%95%99%E6%9D%90/</url>
    <content><![CDATA[<p><a href="https://pan.baidu.com/s/1CsdIdIfRZiUktfCOGZgixg">2021新版毛概教材带跳转目录</a><br>提取码：hhhh</p>
<p>若分享链接失效请留言，会及时更新。</p>
]]></content>
      <categories>
        <category>source</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>source share</tag>
      </tags>
  </entry>
  <entry>
    <title>睡了一整天，头疼</title>
    <url>/2022/03/12/%E7%9D%A1%E4%BA%86%E4%B8%80%E6%95%B4%E5%A4%A9%EF%BC%8C%E5%A4%B4%E7%96%BC/</url>
    <content><![CDATA[<p>又睡了一整天<br>脑壳疼<br>醒着的时间都在无所事事<br>中午喝粥把粥打翻了<br>十九岁了还没学会吃饭，简直比小时候还没用<br>明明知道规律的作息才能让人快乐<br>还是沉溺于一时的安逸，招致更大的痛苦<br>瘫着睡觉的时间出去逛街也好，给影姐姐攒石头也罢<br>总比神志不清的浪费要强<br>以此记录，下不为例。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>少年听雨</tag>
        <tag>废物言论</tag>
      </tags>
  </entry>
  <entry>
    <title>碎碎念</title>
    <url>/2022/02/25/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<p> 在szh坚持不懈的摸鱼之下博客勉勉强强搭起来了，一些后续功能就‘明天’(咳咳)再说。</p>
<p> 这个寒假全程阴间作息，导致对即将到来的网课丝毫没有能好好听课的信心。真是颓废混蛋并且一事无成啊。</p>
<p> 对人际关系也变得十分懒怠，有时候会无缘无故的消失一整天，自己躲起来干一些浪费时间的事情，看一些无聊的小说或者剧，就好像缩在一个安全的壳里一样。等到开学被迫见到许多人的时候这种情况应该会改善很多，到时候会怎么样大概完全取决于我朋友们的肚量(bushi)。</p>
<p> 哦对，寒假学会了擀饺子皮儿，这样看也不算一事无成。</p>
<p> 第二大的遗憾就要数今年冬天没见到雪吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>少年听雨</tag>
      </tags>
  </entry>
  <entry>
    <title>系统结构笔记四、五章</title>
    <url>/2023/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%20%E5%9B%9B%E3%80%81%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="第四章-向量处理机"><a href="#第四章-向量处理机" class="headerlink" title="第四章 向量处理机"></a>第四章 向量处理机</h2><blockquote>
<p>重点<br>向量处理方法：横向处理、纵向处理、纵横处理<br>向量流水处理机结构：<br>    1. 存储器-存储器结构：纵向处理<br>    2. 寄存器-寄存器结构：纵横处理<br>提高向量处理机性能的方法：<br>    - 多功能部件的并行操作<br>    - 链接技术 WD 相关<br>    - 分段开采<br>    - 多处理机系统结构<br>向量处理机性能的主要参数：<br>    - 一条向量指令的处理时间<br>    - 一组向量指令的处理时间<br>    - 向量处理机的性能评估（MFLOPS 或一个浮点运算的时间）<br>第四章，重点是链接技术，一般出大题，pin</p>
</blockquote>
<h3 id="向量基本概念和处理方法"><a href="#向量基本概念和处理方法" class="headerlink" title="向量基本概念和处理方法"></a>向量基本概念和处理方法</h3><p>向量处理机：设置了向量数据表示和向量指令的流水线处理机。</p>
<p>向量处理机方式：</p>
<ul>
<li>横向处理方式：向量按 column 的方式从左到右横向进行。适用于一般处理机，<strong>不适用于向量处理机的并行处理</strong>。<ul>
<li>以 $D&#x3D;A \times (B+C)$为例</li>
<li>每个向量的处理产生N次数据相关，2N次功能转移（向量长度特别长）</li>
</ul>
</li>
<li><strong>纵向处理方式</strong>：向量按 row 的方式从上到下纵向进行。将整个向量按相同运算处理完之后，再进行别的运算。不产生数据相关，对向量长度 N 没有限制。</li>
<li><strong>纵横处理方式</strong>：把向量分成若干组，组内按纵向方式处理，依次处理各组。对向量长度 N 没有限制，但以每 n 个元素分一组处理，n 的值固定。</li>
</ul>
<h3 id="向量处理机结构"><a href="#向量处理机结构" class="headerlink" title="向量处理机结构"></a>向量处理机结构</h3><h4 id="存储器-存储器结构"><a href="#存储器-存储器结构" class="headerlink" title="存储器-存储器结构"></a>存储器-存储器结构</h4><p><mark>适合纵向处理方式。</mark></p>
<ul>
<li><strong>源向量</strong>和<strong>目的向量</strong>都存放在存储器中，运算的中间结果需要送回存储器。</li>
<li>对应的向量分量能并发访问，计算结果能并行地保存。</li>
<li>普通存储器的 3 倍带宽：3 条独立数据通路，一个时钟周期读出两个操作数并写回一个结果。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/2362ff86-2352-49f6-b62e-fa1337ccdc60-16175743.jpg" alt="2"></p>
<p>为了满足运算器带宽要求，存储器采用多个存储器模块组成的结构方式，运算器与主存间有三条相互独立的数据通路，三条路之间可以并行工作，但每个模块同一时间只服务于一个《？？》</p>
<h4 id="寄存器-寄存器结构"><a href="#寄存器-寄存器结构" class="headerlink" title="寄存器-寄存器结构"></a>寄存器-寄存器结构</h4><p><mark>适合纵横处理方式。</amrk></p>
<ul>
<li>若干级中间存储器形成有层次结构的存储系统，相当于寄存器。</li>
<li>访问中间存储器速度更快(比直接访问存储器)。</li>
<li>通过中间存储器形成新的数据结构，高效。</li>
<li>中间存储器高带宽、多种寻址方式、支持流水线链接技术。</li>
</ul>
<p>CRAY-1向量处理机</p>
<ul>
<li>上课讲了，but没怎么听懂（草）。</li>
</ul>
<p>向量流水线并行条件：</p>
<ul>
<li>功能部件不冲突</li>
<li>源寄存器不冲突</li>
<li>结果寄存器不冲突</li>
<li>数据不相关</li>
</ul>
]]></content>
      <categories>
        <category>笔记 - 计算机系统结构</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记_chapter1</title>
    <url>/2022/03/02/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_chapter1/</url>
    <content><![CDATA[<p>szh大废物的计组笔记。</p>
<h2 id="第1章-计算机概述"><a href="#第1章-计算机概述" class="headerlink" title="第1章  计算机概述"></a>第1章  计算机概述</h2><h3 id="计算机的分类和应用"><a href="#计算机的分类和应用" class="headerlink" title="计算机的分类和应用"></a>计算机的分类和应用</h3><p>通用计算机分类<br><img src="https://api2.mubu.com/v3/document_image/bb50f260-a398-4bd2-9a97-d6af00a88dff-16175743.jpg" alt="通用计算机分类"></p>
<p>面向应用的分类</p>
<ol>
<li>通用计算机</li>
<li>专用计算机&#x2F;嵌入式计算机(Embedded)</li>
</ol>
<p>计算机的应用<br>略</p>
<h3 id="计算机发展简史"><a href="#计算机发展简史" class="headerlink" title="计算机发展简史"></a>计算机发展简史</h3><h4 id="计算机的演进"><a href="#计算机的演进" class="headerlink" title="计算机的演进"></a>计算机的演进</h4><ol>
<li>第0代 机械时代（BC-1940</li>
<li>第1代 电子管时代（1943-1959）</li>
<li>第2代 晶体管时代（1960-1968）</li>
<li>第4代 超大规模集成电路时代（1978－现在）</li>
<li>第5代 量子计算机、光计算机、生物计算机？</li>
</ol>
<p>世界上第一台计算机：ENIAC</p>
<p>摩尔定律：集成电路芯片中晶体<br>管数量大体上每2年翻一番</p>
<h4 id="计算机的性能指标-易考"><a href="#计算机的性能指标-易考" class="headerlink" title="计算机的性能指标(易考)"></a><mark>计算机的性能指标</mark>(易考)</h4><p><img src="https://api2.mubu.com/v3/document_image/7ec2da4e-3831-44cd-b68a-6509f0314ac3-16175743.jpg"></p>
<p><img src="https://api2.mubu.com/v3/document_image/099dd094-3f03-436f-afde-e0e84afb42d6-16175743.jpg"></p>
<ol>
<li>响应时间</li>
<li>利用率</li>
<li>处理机字长</li>
<li>总线宽度</li>
<li>吞吐量：通常用KB、MB、GB(gigabit吉比特)和TB表示。B表示Byte(字节)，b表示bit。 $K\equiv2^{10},M\equiv2^{20},G\equiv2^{30}$</li>
<li>存储器带宽：一般用字节数&#x2F;秒表示</li>
<li>主频&#x2F;时钟周期:CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率f称为CPU的主频。<mark>度量单位是MHz（$10^6$）、GHz($10^9$)。</mark>可以理解为每秒有几个CPU时钟周期。<br>主频的倒数称为CPU时钟周期T，T&#x3D;1&#x2F;f，度量单位是微秒，纳秒。</li>
<li>CPU执行时间:表示CPU执行一段程序所占用的CPU时间，也可以用指令数目x每条指令的平均执行时间。而每条指令的平均执行时间可以用每条指令所需的平均时钟周期数目x时钟周期时间。<br> <mark>$\tiny CPU执行时间&#x3D;程序的指令数\times CPI\times CPU时钟周期时间$</mark></li>
<li><strong>CPI（Clock Cycles Per Instruction）</strong>:表示每条指令执行所需要的时钟周期数，或执行一条指令所需的平均时钟周期数。<br><mark>$\tiny CPI&#x3D;程序执行所需的CPU时钟周期总数÷程序的指令总数$</mark></li>
<li>MIPS：每秒百万指令数。<u>M:百万million ($\tiny\underline{10^6}$) ，I:instruction指令，PS:per second每秒</u><br><mark>$\tiny MIPS&#x3D;（指令总数 \div 程序执行时间）\times 10^{-6}$</mark></li>
<li>MFLOPS：每秒百万次浮点操作次数。<u>FLO：浮点操作</u><br>   <mark>$\tiny MFLOPS&#x3D;（程序中的浮点运算次数\div程序执行时间)\times 10^{-6}$</mark></li>
<li>TFLOPS：每秒万亿浮点操作次数。T:trillion兆，也就是万亿，$10^{12}$<br><mark>$\tiny TFLOPS&#x3D;（程序中的浮点运算次数\div程序执行时间)\times 10^{-12}$</mark></li>
<li>例题<br><img src="https://api2.mubu.com/v3/document_image/5e55985c-21a8-465c-bb80-b572227826a7-16175743.jpg" alt="例题"><br>题解<img src="https://api2.mubu.com/v3/document_image/1646144690025ebba.jpg" alt="tijie"><br><img src="https://api2.mubu.com/v3/document_image/304a5e77-8917-4021-8b27-adb2d0e25941-16175743.jpg"></li>
</ol>
<h3 id="计算机的硬件"><a href="#计算机的硬件" class="headerlink" title="计算机的硬件"></a>计算机的硬件</h3><h4 id="计算机的组成-五大部分"><a href="#计算机的组成-五大部分" class="headerlink" title="计算机的组成(五大部分)"></a>计算机的组成(五大部分)</h4><ol>
<li>存储器</li>
<li>运算器</li>
<li>控制器</li>
<li>输入输出设备</li>
</ol>
<ul>
<li>计算机内部，指令和数据均以二进制的形式存储，其中，指令包括操作码和地址码（对谁进行该操作）</li>
<li>关于rax,eax,ax,al:AL是低八位，AX是本名，16位，EAX是extended即扩展的意思，32bits，而RAX则是re-extended，再拓展，64位</li>
</ul>
<h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h3><p><img src="https://api2.mubu.com/v3/document_image/a3c75fab-9dd4-41bb-9fa5-53a7d99b2edf-16175743.jpg" alt="层次结构2"></p>
<p><img src="https://api2.mubu.com/v3/document_image/714d08ad-abe7-4606-8270-1b2566e12ba7-16175743.jpg" alt="层次结构3"></p>
<p>软件与硬件的逻辑等价性,理论上讲，任何软件算法都可以用硬件实现，反之亦然。<br><img src="https://api2.mubu.com/v3/document_image/9bbf4121-a5d0-441c-af82-a56e3781eb3a-16175743.jpg" alt="软件与硬件的逻辑等价性"></p>
<h2 id="第2章-运算方法和运算器I"><a href="#第2章-运算方法和运算器I" class="headerlink" title="第2章 运算方法和运算器I"></a>第2章 运算方法和运算器I</h2><h3 id="数据与文字的表示方法"><a href="#数据与文字的表示方法" class="headerlink" title="数据与文字的表示方法"></a>数据与文字的表示方法</h3><h4 id="常用的数据表示格式"><a href="#常用的数据表示格式" class="headerlink" title="常用的数据表示格式"></a>常用的数据表示格式</h4><ol>
<li>定点表示：小数点的位置是固定的，可以表示纯小数或者纯整数</li>
<li>浮点表示：见CSAPP</li>
<li>十进制数格式：</li>
</ol>
<p>带有符号表示的二进制数：<mark>真值</mark><br>机器中把符号“数字化”的数：<mark>机器数</mark>或者<mark>机器码</mark></p>
<p>常用的机器码包括：(一般针对有符号数)</p>
<ul>
<li>原码：真值的符号位变成0&#x2F;1，0为+。</li>
<li>反码:反码就是二进制数<mark>除符号位以外</mark>的的各位数码</mark>0变为1，1变为0</mark></li>
<li>补码</li>
<li>移码</li>
</ul>
<p>补码整数表示略，记住按位取反再加一就可以<br>补码的定点小数表示如下：<br><img src="https://api2.mubu.com/v3/document_image/535cd946-0888-4aa0-98f7-2b4c95267e57-16175743.jpg" alt="定点小数表示"><br>这里注意，two’s complement是补码的英文，直译为2的补足部分，这里的模的意思和时钟的模为12相同，意为正数负数的补码表示相加就是模值。</p>
<p>反码和补码的关系：定点小数也满足整数的“按位取反再加一”的规则。<br><img src="https://api2.mubu.com/v3/document_image/82299582-3a0e-4d14-92cf-7d23426ff4ad-16175743.jpg" alt="关系"><br>特别的，+0的反码为：00000000(8位)<br>-0的反码为：11111111(8位)</p>
<p>关于移位运算，这是C语言中的<br><a href="https://blog.csdn.net/heiniaoyuyouling/article/details/4696586">C语言中的位移位运算</a></p>
<h2 id="补充：课程概要"><a href="#补充：课程概要" class="headerlink" title="补充：课程概要"></a>补充：课程概要</h2><p><img src="https://api2.mubu.com/v3/document_image/5b9257b0-af72-46f3-9bf1-c75e55e111da-16175743.jpg" alt="课程要求嘿嘿嘿"></p>
<p>课程内容，左边是期中前学的，右边是期中后学的。</p>
<p><img src="https://api2.mubu.com/v3/document_image/d40960c4-d339-42d5-9d88-6b1c4d2cd975-16175743.jpg" alt="课程内容哈哈哈"></p>
<p>实验内容<br><img src="https://api2.mubu.com/v3/document_image/02f22f78-2b45-4c0e-8823-06862639af5d-16175743.jpg" alt="实验内容"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记_chapter2</title>
    <url>/2022/03/23/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_chapter2/</url>
    <content><![CDATA[<h2 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h2><p>规格化表示：<br><img src="https://api2.mubu.com/v3/document_image/edff1550-2019-44d5-94b3-a8bca0ca4809-16175743.jpg" alt="规格化"></p>
<p>特殊的浮点数<br><img src="https://api2.mubu.com/v3/document_image/42891536-e62d-4cd9-b358-64b73d22d52e-16175743.jpg" alt="特殊的浮点数"></p>
<p>浮点数表示的范围<br><img src="https://api2.mubu.com/v3/document_image/1bca8a53-b91b-4811-b0f9-799f3261da15-16175743.jpg" alt="浮点数表示的范围"></p>
<p>小结：<br>对32位浮点数N：<br>◼ 若0 &lt; E &lt; 255，则<br>N ＝ (-1)s ×1.M ×2<br>E-127 ，规格化数表示<br>◼ 若E &#x3D; 0且M ＝ 0，则<br>N ＝ (-1)s 0，机器+0、-0表示<br>◼ 若E &#x3D; 0且M ≠ 0，则<br>N ＝ (-1)s × 0.M× 2<br>1-127 ，非规格化数表示<br>◼ 若E&#x3D; 255且M ＝ 0，则<br>N＝(-1)s∞（正无穷大，负无穷大）<br>◼ 若E &#x3D; 255且M ≠ 0，则<br>N ＝ NaN，非数NaN(Not a Number)</p>
<blockquote>
<p>十进制小数转二进制：<br>十进制的小数转换为二进制，主要是小数部分乘以2，取整数部分依次从左往右放在小数点后，直至小数点后为0。</p>
</blockquote>
<h2 id="ACSII码"><a href="#ACSII码" class="headerlink" title="ACSII码"></a>ACSII码</h2><p>数字：48（0011 0000）~ 57（0011 1001）   +10-1<br>大写字母：65（0100 0001）～90（0101 1010）   +26-1<br>小写字母：97（0110 0001）～122（0111 1010）   +26-1</p>
<h2 id="存储器中的字节序"><a href="#存储器中的字节序" class="headerlink" title="存储器中的字节序"></a>存储器中的字节序</h2><p>每个字节内部的顺序都是固定的，仅需考虑多个字节的字节间关系</p>
<ul>
<li>小端方式Little Endian<ul>
<li>低字节存放在小地址处，即低字节在前高字节后<br>x86处理器</li>
</ul>
</li>
<li>大端方式Big Endian<ul>
<li>低字节存放在大地址处，即高字节在前低字节后<br>SPARC处理器，IBM Power处理器</li>
</ul>
</li>
</ul>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p><img src="https://api2.mubu.com/v3/document_image/16483863477285a79.jpg" alt="证明补码减法"></p>
<h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>正溢：运算结果为正，且超出机器所能表示的范围<br>负溢：运算结果为负，且超出机器所能表示的范围<br><img src="https://api2.mubu.com/v3/document_image/32378a93-fd0e-418c-932b-209ba715160d-16175743.jpg" alt="整数溢出"></p>
<h3 id="小数溢出"><a href="#小数溢出" class="headerlink" title="小数溢出"></a>小数溢出</h3><p>上溢：结果的绝对值大于机器所能表示的最大绝对值（+∞，－∞）<br>（overflow）<br>下溢：结果的绝对值小于机器所能表示的最小绝对值 （ 机器零 ）<br>（underflow）<br><img src="https://api2.mubu.com/v3/document_image/f3691e63-d615-4caa-9043-dbb945ed07bc-16175743.jpg" alt="小数溢出"></p>
<h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><ol>
<li><p><strong>双符号位</strong>法，又称<strong>变形补码</strong>，或者模四补码<br> 双符号位的补码也遵循加法法则。<br> 在计算中：<br> 两个符号位均参加运算<br> 最高符号位上产生的进位要丢掉</p>
<p> 溢出检测规则：<br> ◆两数相加后，结果的符号位出现“01”或“10”两种情况时，表示发生溢出（也就是<strong>最高的两位异或</strong>）<br> ◆最高符号位永远表示结果的正确符号</p>
</li>
<li><p><strong>单符号位</strong>法<br> 溢出的逻辑表达式为<br> $V&#x3D;C_f⊕C_0$<br> $C_f$为符号位产生的进位，$C_0$为最高有效位产生的进位</p>
</li>
</ol>
<h2 id="定点乘法运算算法"><a href="#定点乘法运算算法" class="headerlink" title="定点乘法运算算法"></a>定点乘法运算算法</h2><h3 id="原码一位乘法运算"><a href="#原码一位乘法运算" class="headerlink" title="原码一位乘法运算"></a>原码一位乘法运算</h3><h3 id="无符号的阵列乘法"><a href="#无符号的阵列乘法" class="headerlink" title="无符号的阵列乘法"></a>无符号的阵列乘法</h3><h3 id="有符号的阵列乘法"><a href="#有符号的阵列乘法" class="headerlink" title="有符号的阵列乘法"></a>有符号的阵列乘法</h3><p>补码一位乘法运算（不要求）<br>原码两位乘法运算（不要求）<br>直接补码并行乘法（不要求）</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记_chapter3</title>
    <url>/2022/04/27/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_chapter3/</url>
    <content><![CDATA[<h2 id="3-1-存储器概述"><a href="#3-1-存储器概述" class="headerlink" title="3.1 存储器概述"></a>3.1 存储器概述</h2><ul>
<li><strong>易失性</strong>半导体存储器统称为RAM<ul>
<li>静态RAM（SRAM）</li>
<li>动态RAM（DRAM）</li>
</ul>
</li>
<li><strong>非易失性</strong>的半导体存储器统称为ROM<ul>
<li>掩膜ROM（MASK ROM）:出厂的时候就写好了，不能改了捏</li>
<li>可编程ROM（PROM）<ul>
<li>一次性可编程ROM（OTP ROM）</li>
<li>可擦除PROM（EPROM）<ul>
<li>紫外线擦除EPROM（UV EPROM）</li>
<li>电擦除EPROM（EEPROM，E2PROM）</li>
<li>闪速存储器（FLASH ROM)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>存储器的目标<ul>
<li>大容量</li>
<li>高速度</li>
<li>低价格</li>
</ul>
</li>
<li>现代计算机的层次存储器系统<ul>
<li>Register</li>
<li>On-Chip Cache</li>
<li>Second Level Cache(SRAM)</li>
<li>Main Memory(DRAM)</li>
<li>Secondary Storage(Disk)</li>
<li>Tertiary Stroage(Disk)</li>
</ul>
</li>
</ul>
<blockquote>
<p>其中，内存&#x3D;Cache+主存</p>
</blockquote>
<p>内存的主要技术指标</p>
<ul>
<li>访问时间TA：<br>从存储器接收到读写命令道信息被读出或写入完成所需的时间，取决于存储介质的物理特性和寻址部件的结构</li>
<li>存取周期TM：<br>在存储器连续读写过程中一次完整的存取操作所需的时间（CPU连续两次访问存储器的最小时间间隔）</li>
<li>功耗</li>
<li>可靠性</li>
</ul>
<p>主存储器的读写过程</p>
<ul>
<li>读过程:<ul>
<li>给出地址</li>
<li>给出片选与读命令</li>
<li>保存读出内容</li>
</ul>
</li>
<li>写过程:<ul>
<li>给出地址</li>
<li>给出片选与数据</li>
<li>给出写命令</li>
</ul>
</li>
</ul>
<h2 id="3-2-随机读写存储器"><a href="#3-2-随机读写存储器" class="headerlink" title="3.2 随机读写存储器"></a>3.2 随机读写存储器</h2><p>存储器芯片的基本结构</p>
<ul>
<li>地址线</li>
<li>数据线（双向）</li>
<li>片选信号</li>
<li>读写控制线</li>
</ul>
<p>n位存储器芯片的结构<br><img src="https://api2.mubu.com/v3/document_image/32de5b46-4a1e-44a0-9f79-07893d6352e0-16175743.jpg" alt="n位存储器芯片的结构"></p>
<h3 id="SRAM基本电路"><a href="#SRAM基本电路" class="headerlink" title="SRAM基本电路"></a>SRAM基本电路</h3><blockquote>
<p>关于MOS管：<br> <img src="https://api2.mubu.com/v3/document_image/9af0e8b2-247c-40d4-8668-44e85d9cc555-16175743.jpg" alt="MOS管"><br> 当G极电压大于导通电压时，DS导通，G极仅有电压而无电流。</p>
</blockquote>
<h4 id="SRAM读操作"><a href="#SRAM读操作" class="headerlink" title="SRAM读操作"></a>SRAM读操作</h4><p><img src="https://api2.mubu.com/v3/document_image/ca7d354f-54ce-4fbc-a7ff-68b180d76484-16175743.jpg" alt="读操作"></p>
<h4 id="SRAM写操作"><a href="#SRAM写操作" class="headerlink" title="SRAM写操作"></a>SRAM写操作</h4><p><img src="https://api2.mubu.com/v3/document_image/4f97314f-340d-414a-ad41-88b706d3ec3a-16175743.jpg" alt="写操作"></p>
<h4 id="SRAM存储器的结构"><a href="#SRAM存储器的结构" class="headerlink" title="SRAM存储器的结构"></a>SRAM存储器的结构</h4><p><img src="https://api2.mubu.com/v3/document_image/704b1a9d-4bdd-40b6-94e2-2bba8b20768a-16175743.jpg" alt="SRAM存储器的结构"></p>
<h4 id="SRAM实例"><a href="#SRAM实例" class="headerlink" title="SRAM实例"></a>SRAM实例</h4><p><img src="https://api2.mubu.com/v3/document_image/b63aa862-bd86-4a2d-bfb0-030536d5ccbd-16175743.jpg" alt="实例"></p>
<h4 id="字扩展-amp-位扩展"><a href="#字扩展-amp-位扩展" class="headerlink" title="字扩展&amp;位扩展"></a>字扩展&amp;位扩展</h4><p><a href="https://blog.csdn.net/qq1350975694/article/details/107290348">这位老哥</a>讲的不错，能看懂，就是容易记不住。</p>
<h3 id="动态存储器DRAM"><a href="#动态存储器DRAM" class="headerlink" title="动态存储器DRAM"></a>动态存储器DRAM</h3><p>可以减少晶体管的数目，但是存储的电荷会泄露，所以需要动态刷新电路。</p>
<h4 id="四管动态存储单元"><a href="#四管动态存储单元" class="headerlink" title="四管动态存储单元"></a>四管动态存储单元</h4><p>DRAM刷新是对一行进行刷新的。</p>
<h4 id="单管动态存储单元"><a href="#单管动态存储单元" class="headerlink" title="单管动态存储单元"></a>单管动态存储单元</h4><p><img src="https://api2.mubu.com/v3/document_image/392de6a0-3436-4afc-a57f-fcb955c5e5e7-16175743.jpg" alt="单管动态存储单元"><br>word line是字线，bit line是数据线</p>
<h4 id="DRAM写操作"><a href="#DRAM写操作" class="headerlink" title="DRAM写操作"></a>DRAM写操作</h4><ul>
<li>字线高电平，T导通<ul>
<li>写1: 数据线为高电平，通过T对C充电</li>
<li>写0: 数据线为低电平，C通过T放电<br><img src="https://api2.mubu.com/v3/document_image/3658afcf-ccf6-49fe-87a9-7dcf1007bd7c-16175743.jpg" alt="写操作"></li>
</ul>
</li>
</ul>
<h4 id="DRAM读操作-amp-刷新操作"><a href="#DRAM读操作-amp-刷新操作" class="headerlink" title="DRAM读操作&amp;刷新操作"></a>DRAM读操作&amp;刷新操作</h4><ul>
<li>数据线预充电至VDD&#x2F;2</li>
<li>当字线为高电平，T导通，若原来C充有电荷，则C放电使数据线电位小幅上升，经放大后读出为1；若原来C上无电荷，则C充电使数据线电位小幅下降，经放大器后读出为0。</li>
<li>单管DRAM单元的读出是破坏性的，在读出信息后要立即对单元进行“回写”，以恢复原信息。<br><img src="https://api2.mubu.com/v3/document_image/2c510ee9-446e-4aaf-adc4-a55cedbd7002-16175743.jpg" alt="读操作&amp;刷新操作"></li>
</ul>
<h3 id="DRAM和SRAM的比较"><a href="#DRAM和SRAM的比较" class="headerlink" title="DRAM和SRAM的比较"></a>DRAM和SRAM的比较</h3><ul>
<li>DRAM<ul>
<li>主存</li>
<li>电容+1晶体管</li>
<li>需要刷新（2~8ms）</li>
<li>读操作是破坏性的</li>
<li>密度高</li>
<li><font color=red>地址线分时复用</font>:管脚是稀缺资源，通常是行地址和列地址进行分时复用</li>
</ul>
</li>
<li>SRAM<ul>
<li>Cache</li>
<li>速度比DRAM快</li>
</ul>
</li>
</ul>
<h3 id="DRAM读时序"><a href="#DRAM读时序" class="headerlink" title="DRAM读时序"></a>DRAM读时序</h3><p><img src="https://api2.mubu.com/v3/document_image/4de50a3c-bb58-4609-ab18-1d9e66e6fdcc-16175743.jpg" alt="DRAM读时序"><br>OE_L是输出使能信号，WE_L是写使能信号，RAS_L是row 行地址有效，CAS_L是column 列地址有效。_L代表低电平有效。<br>OE_L可以在CAS之前或者之后有效，区别是是否读出一些垃圾数据。<br>了解即可<br><img src="https://api2.mubu.com/v3/document_image/9eeef8a0-7f7c-4e4e-8d6c-0b23c3b37721-16175743.jpg" alt="了解即可"></p>
<h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h3><p>刷新周期一般是几毫秒</p>
<h4 id="集中式刷新"><a href="#集中式刷新" class="headerlink" title="集中式刷新"></a>集中式刷新</h4><p>在整个刷新间隔里，前大半部分可以读写，后小半部分刷新。<br>在后小半部分里，CPU无法访问存储器，也就是不能执行指令，响应系统紧急事件。</p>
<h4 id="分散式刷新"><a href="#分散式刷新" class="headerlink" title="分散式刷新"></a>分散式刷新</h4><p>例如：某DRAM有1024行，若刷新周期为8ms，则必须在8ms内把所有1024行刷新一遍。<br>8000µs÷1024≈7.8µs，即每隔7.8µs刷新<strong>一行</strong>。<br>有点像时分复用。<br>需要一些相应的辅助电路，比如记录刷新到第几行了，以及一个额外的计时器etc.</p>
<p>两种常用的传递刷新信号的方式</p>
<ol>
<li>只用RAS刷新操作</li>
<li>CAS在RAS之前的刷新操作</li>
</ol>
<h3 id="DRAM控制器"><a href="#DRAM控制器" class="headerlink" title="DRAM控制器"></a>DRAM控制器</h3><!-- 长[这样]()，感觉不重要。 -->

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://api2.mubu.com/v3/document_image/7ac2c0db-93d3-4115-9163-c1426997f1b6-16175743.jpg" alt="例子"><br>4Mx8位指的是：<br>一片里面有4M，有8片。<br>所以8位是数据位。<br>1M是2的20次方。<br>4M是2的22次方。<br>也就是行列线一共有22条。<br>因为DRAM是行列地址分时复用，所以地址线仅11条。<br>这里的行地址线和列地址线不一定是一样多的，但是没说的情况下默认平分。</p>
<h3 id="其他的一些补充"><a href="#其他的一些补充" class="headerlink" title="其他的一些补充"></a>其他的一些补充</h3><ul>
<li><p>增强型的DRAM：EDRAM（Enhanced）<br>由于CPU的数据经常需要访问某个地址相邻地址的数据，加一个SRAM临时存储读出的这一行，可以加快读取速度。<br>在行地址不变的情况下，连续的变换列地址，称为Brust Mode，这种情况下的增强型DRAM读取速度尤其快。</p>
</li>
<li><p>SDRAM：同步DRAM<br>S：synchronous a.同步的<br>添加了一个时钟信号，让CPU和读写存储变成了一个同步的操作。<br>只在时钟的上升沿进行数据的读取<br>为了提升速率：<br>DDR：在上升下降沿都进行读取。<br>DDR2：外部时钟的频率提高一倍，也是在上升下降沿都进行读取。</p>
</li>
<li><p>CAS Latency 参数<br>列地址有效时候还要多久才能读取到数据，越小越好。</p>
</li>
<li><p>DRAM主存读&#x2F;写的正确性校验<br>为了提高DRAM存储器读写操作的正确性与可靠性，在写入m位数据的同时还需写入k位附加位，即写入的数据是经过纠错码编码的数据。</p>
</li>
</ul>
<h2 id="3-4-只读存储器和闪速存储器"><a href="#3-4-只读存储器和闪速存储器" class="headerlink" title="3.4 只读存储器和闪速存储器"></a>3.4 只读存储器和闪速存储器</h2><h3 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h3><p>Read Only Memory<br>没有易失性</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>掩膜ROM（MASK ROM）:出厂的时候就写好了，不能改了捏<br>可靠性高，便宜</li>
<li>可编程ROM（PROM）<ul>
<li>一次性可编程ROM（OTP ROM）<br>（双极型PROM，熔断型，PN结击穿型）</li>
<li>可擦除PROM（EPROM）<ul>
<li>紫外线擦除EPROM（UV EPROM）</li>
<li>电擦除EPROM（EEPROM，E2PROM）</li>
<li>闪速存储器（FLASH ROM）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="EPROM"><a href="#EPROM" class="headerlink" title="EPROM"></a>EPROM</h4><p>原理略<br>举例：<br><img src="https://api2.mubu.com/v3/document_image/7730146f-b3b1-401b-8db7-880d9e220254-16175743.jpg" alt="1"><br><img src="https://api2.mubu.com/v3/document_image/f545b500-4648-4e43-a869-349c29d89aca-16175743.jpg" alt="2"><br><img src="https://api2.mubu.com/v3/document_image/34f620ab-acab-433c-bc7e-ff7ef604db18-16175743.jpg" alt="3"></p>
<h4 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h4><p>与EPROM相比，集成度低（两个晶体管存一个单位），寿命长。</p>
<h3 id="闪速存储器"><a href="#闪速存储器" class="headerlink" title="闪速存储器"></a>闪速存储器</h3><p>闪速存储器FLASH是目前唯一的具有大容量、非易失性、低价格、可在线改写和较高速度几个特性共存的存储器。<br>之所以称为FLASH，是因为<strong>擦除速度快</strong>，擦除整个存储矩阵所花时间，与EEPROM擦除一个存储单元的时间相同。<br>FLASH具有<strong>非易失性</strong>，比SRAM成本低<br>但是擦写次数和速度都比DRAM差不少，故不能取代DRAM</p>
<p>闪存分为两类：</p>
<ol>
<li>NOR闪存</li>
<li>NAND闪存</li>
</ol>
<h4 id="NOR闪存"><a href="#NOR闪存" class="headerlink" title="NOR闪存"></a>NOR闪存</h4><ul>
<li>擦除写入时间比较长</li>
<li>有完整的地址&#x2F;数据接口，能<strong>随机存取</strong></li>
<li>存储容量比NAND小很多</li>
</ul>
<h4 id="NAND闪存"><a href="#NAND闪存" class="headerlink" title="NAND闪存"></a>NAND闪存</h4><ul>
<li>擦除写入时间比较快</li>
<li>与NOR闪存比较具有较高的密度和较低的位成本，10倍的擦除次数。</li>
<li>没有完整的地址&#x2F;数据接口，I&#x2F;O接口只允许<strong>顺序存取</strong>数据</li>
</ul>
<p>闪存特点：<br>可在线写入数据，具有ROM的非易失性<br>可以取代全部的UV EPROM和大部分的E$^2$PRO</p>
<p>闪存的主要用途：<br>存储监控程序、引导程序等基本不变或不经常改变的程序：可使用NOR闪存<br>保存掉电时需要保持的系统配置等不常改变的数据：可使用NOR闪存<br>固态盘：采用NAND闪存</p>
<h2 id="3-5-并行存储器"><a href="#3-5-并行存储器" class="headerlink" title="3.5 并行存储器"></a>3.5 并行存储器</h2><h3 id="双端口存储器"><a href="#双端口存储器" class="headerlink" title="双端口存储器"></a>双端口存储器</h3><p>DRRAM:dual port RAM<br>同一个存储器具有两组独立的控制线，地址线和数据线。<br>比其他的线多了一个忙线（busy line），作用是解决读写冲突。<br>实例：<br>IDT7133<br>容量为2K×16位SRAM<br><a href="https://api2.mubu.com/v3/document_image/df269406-2bbc-4477-af34-1a6e7c0a846a-16175743.jpg">功能方框图</a><br>当两个端口同时存取存储器同一存储单元时，便发生读写<br>冲突,为了解决读写冲突，设置了<span style="text-decoration:overline">BUSY</span>标志线</p>
<ul>
<li>由判断逻辑部件来决定对哪个端口优先进行读写操作，另<br>一个端口的BUSY标志有效，读写操作延迟执行。</li>
<li>判断逻辑部件的判断方式：<ol>
<li>CE判断：如果地址匹配且在CE之前有效，片上的控制逻辑在CEL和CER之间进行判断来选择端口</li>
<li>地址有效判断：如果CE在地址匹配之前变低，片上的控制逻辑在左、右地址间进行判断来选择端口</li>
</ol>
</li>
</ul>
<h3 id="多模块交叉存储器"><a href="#多模块交叉存储器" class="headerlink" title="多模块交叉存储器"></a>多模块交叉存储器</h3><p>各模块地址安排有2种方式</p>
<ul>
<li>顺序方式<br><img src="https://api2.mubu.com/v3/document_image/ff771aed-21ae-4267-8573-0ed40c1edfc5-16175743.jpg" alt="顺序方式"></li>
<li>交叉方式(Interleaving)也称为多通道方式<br><img src="https://api2.mubu.com/v3/document_image/62967547-6e6e-4d9a-afac-bc1503b863e8-16175743.jpg" alt="交叉模式"></li>
</ul>
<p>主存被分成4个独立、容量相同的模块M0&#x2F;M1&#x2F; M2&#x2F;M3<br><img src="https://api2.mubu.com/v3/document_image/b4df61d4-a217-4b4b-9adf-1f7509019ffe-16175743.jpg" alt="基本结构"></p>
<ol>
<li>每个模块均有自己的读写控制电路、地址寄存器和数据寄存器，<br>以相同的方式与CPU传送信息</li>
<li>CPU同时访问四个模块，由存储器控制部件控制它们分时使用<br>数据总线进行信息的传递（读取T相对于数据传递$\tau$要慢很多</li>
</ol>
<p><img src="https://api2.mubu.com/v3/document_image/6e562469-71e6-40fc-8571-0328990c5864-16175743.jpg" alt="读取模式"><br>假设模块字长等于数据总线宽度，且模块存取一个字的存储周期为T，总线传送周期为τ，存储器的交叉模块数为m<br>那么，m＝T&#x2F;τ被为交叉存取度，连续读取m个字所需的时间为t1&#x3D;T+(m-1)τ<br>对于顺序方式存储器，连续读取m个字所需的时间为t2&#x3D;mT</p>
<p>例子：<br><img src="https://api2.mubu.com/v3/document_image/e252126f-ed53-41c0-a0c2-bca3f9cf6bf1-16175743.jpg" alt="例子："><br>解答：<br><img src="https://api2.mubu.com/v3/document_image/16519072863582123.jpg" alt="解答："></p>
<p>零等待存取<br><img src="https://api2.mubu.com/v3/document_image/8bef93b1-f2ba-4efc-b643-78b5bc768899-16175743.jpg" alt="零等待存取"></p>
<h2 id="3-6-Cache存储器"><a href="#3-6-Cache存储器" class="headerlink" title="3.6 Cache存储器"></a>3.6 Cache存储器</h2><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>principle of locality，讨论的就是双重for循环取二维数组那个，执行速度的问题。</p>
<ul>
<li>时间局部性 temporal locality<br>在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用</li>
<li>空间局部性 spatial locality<br>在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在近期引用附近的一个内存位置</li>
</ul>
<h3 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h3><p><img src="https://api2.mubu.com/v3/document_image/ef2fd587-0459-41e2-be5c-8a2ba15b4eeb-16175743.jpg" alt="结构"></p>
<h3 id="高速缓存Cache-x2F-kaeʃ-x2F"><a href="#高速缓存Cache-x2F-kaeʃ-x2F" class="headerlink" title="高速缓存Cache&#x2F;kæʃ&#x2F;"></a>高速缓存Cache&#x2F;kæʃ&#x2F;</h3><p>Cache是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓存区域</p>
<ol>
<li>Cache通常采用高速SRAM来实现</li>
<li>利用局部性原理，在Cache中完成大多数访问，从而缩短平均访问时间</li>
<li>CPU和主存之间的速度差很大通常采用两级或多级Cache系统</li>
<li>全由硬件调度，对用户透明</li>
</ol>
<p>不同层次之间Cache<br><img src="https://api2.mubu.com/v3/document_image/f1187756-8075-42a9-b96a-ff42adf70110-16175743.jpg" alt="基本原理1"></p>
<p>Cache 命中与缺失<br><img src="https://api2.mubu.com/v3/document_image/abf3fed0-9cde-40f8-8dec-04015df1ae48-16175743.jpg" alt="命中与缺失"></p>
<blockquote>
<p>LRU :Least Recently Used最近最少使用</p>
</blockquote>
<p>Cache缺失类型</p>
<ol>
<li>冷启缺失&#x2F;义务缺失（Cold miss or Compulsory miss）<ul>
<li>当cache为空时就产生冷启缺失，比如刚开机</li>
</ul>
</li>
<li>冲突缺失（Conflict miss）<ul>
<li>层k+1的数据块通常只能映射到层k的有限位置上。尽管层k中cache足够大，但层k+1有多个数据块全都映射到层k的同一位置上，则产生冲突缺失</li>
</ul>
</li>
<li>容量缺失（Capacity miss）<ul>
<li>当活动的cache块的数量超过cache的容量就产生容量缺失</li>
</ul>
</li>
</ol>
<h3 id="内容可寻址CAM"><a href="#内容可寻址CAM" class="headerlink" title="内容可寻址CAM"></a>内容可寻址CAM</h3><p>（Content Addressable Memory）是一种用内容进行寻址的存储器。将一个输入数据项与存储的所有数据项同时进行比较，若存在匹配，输出该数据项对应的匹配信息（或地<br>址）。同时也能按地址进行读和写。</p>
<h3 id="主存和Cache的分块"><a href="#主存和Cache的分块" class="headerlink" title="主存和Cache的分块"></a>主存和Cache的分块</h3><p>主存和cache间以数据块为单位进行复制，为便于管理，将主存和cache都划分为大小相等的数据块（也称行）</p>
<p><img src="https://api2.mubu.com/v3/document_image/27912974-d4e5-482f-a56a-3210c8c23b3e-16175743.jpg" alt="主存&amp;cache容量"><br><img src="https://api2.mubu.com/v3/document_image/2c0711cb-fc8a-4b2a-92f4-3311f88ef522-16175743.jpg" alt="映射方法"><br>总的映射过程<br><img src="https://api2.mubu.com/v3/document_image/0c35d8b0-967a-47b2-82aa-776ab2d01ab9-16175743.jpg" alt="过程"></p>
<h3 id="主存与Cache的地址映射"><a href="#主存与Cache的地址映射" class="headerlink" title="主存与Cache的地址映射"></a><mark>主存与Cache的地址映射</mark></h3><ol>
<li>全相联映射（ Fully Associative Mapping）</li>
<li>直接映射（Direct Mapping）</li>
<li>组相联映射（Set Associative Mapping）</li>
</ol>
<h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><p><img src="https://api2.mubu.com/v3/document_image/2e922423-4875-4c5f-ab9f-08e313b59c6c-16175743.jpg" alt="1"><br><img src="https://api2.mubu.com/v3/document_image/93b3ef69-428b-4a6f-8942-587a10e2ec58-16175743.jpg" alt="2"></p>
<p>就是弄个表，其实就是前面那个<a href="#%E5%86%85%E5%AE%B9%E5%8F%AF%E5%AF%BB%E5%9D%80cam">内容可寻址CAM</a><br><img src="https://api2.mubu.com/v3/document_image/a56ec8fa-f145-4baa-9eda-82156e49e5b8-16175743.jpg" alt="示例"><br>例子：<br><img src="https://api2.mubu.com/v3/document_image/5d635f1b-e733-45ff-b34b-98a3fb66bda5-16175743.jpg" alt="例子："></p>
<h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p><img src="https://api2.mubu.com/v3/document_image/4737d462-58d4-4288-a61f-fd0484e904ef-16175743.jpg" alt="直接映射"><br>这也是能产生冲突缺失的情况</p>
<p>直接映射的Cache标签和行号<br><img src="https://api2.mubu.com/v3/document_image/e4592538-4dd4-48a3-8fef-294e7d40c57f-16175743.jpg" alt="直接映射的Cache标签和行号"><br>直接映射Cache的检索过程<br><img src="https://api2.mubu.com/v3/document_image/2c75c351-38df-41c4-a5b1-c032864a55e1-16175743.jpg" alt="检索过程"><br>示例<br><img src="https://api2.mubu.com/v3/document_image/cab14266-1809-4e39-aa54-937d06549bad-16175743.jpg" alt="示例"></p>
<h3 id="v路（v-way）组相联映射"><a href="#v路（v-way）组相联映射" class="headerlink" title="v路（v-way）组相联映射"></a>v路（v-way）组相联映射</h3><p><img src="https://api2.mubu.com/v3/document_image/f0e63664-1cde-42b8-b783-f5a3a0f306e6-16175743.jpg" alt="v路（v-way）组相联映射"><br><strong>主存块存放到哪个组是固定的，放在组内的哪一行是任意的</strong><br>检索过程<br><img src="https://api2.mubu.com/v3/document_image/6bd4d8f2-75ee-4e35-a527-c126b8b555cf-16175743.jpg" alt="jsgc"><br>2路组相联映射示例1<br><img src="https://api2.mubu.com/v3/document_image/7af08504-1981-4f84-88d6-2feee4d4cbaa-16175743.jpg" alt="shili"><br>2路组相联映射示例2<br><img src="https://api2.mubu.com/v3/document_image/c7af876a-6747-4241-b5f6-c398545c9385-16175743.jpg" alt="shili"></p>
<h2 id="wordtable"><a href="#wordtable" class="headerlink" title="wordtable"></a>wordtable</h2><blockquote>
<p>Interleaving 交叉模式<br> Compulsory a.必修做的强制的<br> CAM 内容可寻址存储器</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记_chapter4</title>
    <url>/2022/05/07/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_chapter4/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>指令系统<strong>ISA</strong>（Instruction Set Architecture）<br>指令分类：</p>
<ul>
<li>微指令：微程序级的命令，它属于<strong>硬件</strong></li>
<li>宏指令：由若干条机器指令组成的软件指令，它属于软件</li>
<li>机器指令：介于微指令与宏指令之间，每条指令可完成一个独立的算术运算或逻辑运算</li>
</ul>
<p>复杂指令系统计算机 （<strong>CISC</strong>）： Complex Instruction Set Computer<br>精简指令系统计算机（<strong>RISC</strong>）：Reduced Instruction Set Computer</p>
<h2 id="4-2指令格式"><a href="#4-2指令格式" class="headerlink" title="4.2指令格式"></a>4.2指令格式</h2><p>指令字（简称指令）即表示一条指令的机器字<br>指令格式则是指令字用二进制代码表示的结构形式<br>指令的构成</p>
<ul>
<li>操作码字段：表示指令的操作特性与功能，即指令应进行什么样的操作</li>
<li>操作数地址字段：指定参与操作的操作数的地址</li>
</ul>
<h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>操作码字段的位数一般取决于计算机指令系统的规模。例如：<br>如果指令系统只有8条指令，则用3位操作码就可表示<br>如果有32条指令，那么就需要5位操作码<br>定长操作码指令格式<br><img src="https://api2.mubu.com/v3/document_image/ebe16a31-c998-4a1f-b0ec-d3eb36d2945e-16175743.jpg" alt="定长"><br>扩展操作码指令格式:<br><img src="https://api2.mubu.com/v3/document_image/f46b1ac4-19a4-42b3-8c85-ff482d434dc3-16175743.jpg" alt="扩展"></p>
<h3 id="地址码"><a href="#地址码" class="headerlink" title="地址码"></a>地址码</h3><p>按照一条指令中有几个操作数地址，可将该指令称为几操作数指令或几地址指令</p>
<ul>
<li>三地址指令格式</li>
<li>二地址指令格式</li>
<li>一地址指令格式</li>
<li>零地址指令格式</li>
</ul>
<p>不同地址数目指令的形式：<br><a href="https://api2.mubu.com/v3/document_image/6a57c343-2819-4f24-a246-7266f895a1fc-16175743.jpg">零地址码和一地址码</a><br><a href="https://api2.mubu.com/v3/document_image/50587f8f-388f-4803-8523-6f8a9fa8fdad-16175743.jpg">二地址码和三地址码</a>  </p>
<p>根据各个操作数的物理位置不同，地址码可分为3类</p>
<ul>
<li>存储器-存储器（SS）型指令</li>
<li>寄存器-寄存器（RR）型指令</li>
<li>寄存器-存储器（RS）型指令</li>
</ul>
<p>指令字长度：一个指令字中包含二进制代码的位数<br>机器字长：计算机能直接处理的二进制数据的位数，它决定了计算机的运算精度<br><strong>机器字长度通常与寄存器的位数一致</strong><br>指令分类<br>单字长指令：指令字长度等于机器字长度<br>半字长指令：指令字长度等于半个机器字长度<br>双字长指令：指令字长度等于两个机器字<br>使用多字长指令，目的在于ᨀ供更大的地址空间。主要缺点是必须两次或多次访问内存以取出一整条指令，降低了Cpu的运算速度。<br>等长指令字结构：各种指令字长度是相等的。这种指令字结构简单，且指令字长度是不变的。<br>变长指令字结构：各种指令字长度随指令功能而异。结构灵活，代码密度高，能充分利用指令长度，但指令的控制比较复杂。<br>指令助记符：每条指令通常用3个或4个英文缩写字母来表示<br><img src="https://api2.mubu.com/v3/document_image/5a5fe9b9-8f1d-4f8e-81e8-bf254a362157-16175743.jpg" alt="典型助记符"></p>
<h2 id="4-3指令和数据的寻址方式"><a href="#4-3指令和数据的寻址方式" class="headerlink" title="4.3指令和数据的寻址方式"></a>4.3指令和数据的寻址方式</h2><p>在存储器中，写入或读出操作数&#x2F;指令字的方式有：</p>
<ul>
<li><font color=iceblue>地址指定方式</font></li>
<li>相联存储方式（按内容寻址方式）</li>
<li>堆栈存取方式</li>
</ul>
<p>采用<font color=iceblue>地址指定方式</font>时，形成操作数或指令地址的方式，称为寻址方式。<br>寻址方式分为两类</p>
<ul>
<li>指令寻址方式（简单）<ul>
<li>顺序寻址方式</li>
<li>跳跃寻址方式</li>
</ul>
</li>
<li>数据寻址方式（复杂）</li>
</ul>
<h3 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a>指令寻址方式</h3><h4 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h4><p>必须使用程序计数器（又称指令指针寄存器）PC来计数指令的顺序号，该顺序号就是指令在内存中的地址。PC++是指跳过当前指令，到达下一条指令。（PC加几取决于指令长度）<br><img src="https://api2.mubu.com/v3/document_image/9b8210c5-48fb-4e5d-8210-7faef68427a8-16175743.jpg" alt="顺序寻址"></p>
<h4 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h4><p>本条指令给出下一条指令的地址码。<br>一般是条件转移，无条件转移，子程序调用会用到。<br><img src="https://api2.mubu.com/v3/document_image/5cd2947f-fc3b-4023-b9f6-933a2cfb64ac-16175743.jpg" alt="跳跃寻址"></p>
<h3 id="操作数寻址方式"><a href="#操作数寻址方式" class="headerlink" title="操作数寻址方式"></a><mark>操作数寻址方式</mark></h3><p>形成<strong>操作数的****有效地址</strong>的方法，称为操作数的寻址方式<br>一种单地址指令的结构如下所示，其中用X，I，A各字段组成该指令的操作数地址<br><img src="https://api2.mubu.com/v3/document_image/220a471b-f43a-47ce-b34f-e6ce929dbd98-16175743.jpg" alt="单地址指令结构"><br>指令中操作数字段的地址码是由<strong>形式地址A（也称偏移量）</strong>和<strong>寻址方式特征位</strong>等组合形成。</p>
<blockquote>
<p>寻址过程就是把操作数的<strong>形式地址</strong>，变换为操作数的<strong>有效地址</strong>的过程</p>
</blockquote>
<h4 id="1-隐含寻址"><a href="#1-隐含寻址" class="headerlink" title="1.隐含寻址"></a>1.隐含寻址</h4><p>在指令中不是显式而是隐含（默认）给出操作数的地址<br><img src="https://api2.mubu.com/v3/document_image/e44225a1-bd09-47db-ac05-81928d4133ef-16175743.jpg" alt="乘法指令"></p>
<h4 id="2-立即寻址"><a href="#2-立即寻址" class="headerlink" title="2.立即寻址"></a>2.立即寻址</h4><p>指令的地址字段给出的不算操作数的地址，而是操作数本身<br>这种方式的特点是指令执行速度较快，取指令的同时就取到了操作数，<strong>不需要访问内存取操作数</strong>（<font color=iceblue>立即数</font>啦）</p>
<h4 id="3-直接寻址"><a href="#3-直接寻址" class="headerlink" title="3.直接寻址"></a>3.直接寻址</h4><p>在指令的地址字段中直接给出的是操作数在内存的地址。<br>要按照这个地址去读取内存。<br>用直接寻址方式时，指令字中的形式地址A就是操作数的有效地址EA。因此通常把形式地址A又称为直接地址<br><img src="https://api2.mubu.com/v3/document_image/907b5157-8cd1-4074-9365-771bc842e8f9-16175743.jpg" alt="直接寻址"><br>途中的括号表示取地址。</p>
<h4 id="4-间接寻址"><a href="#4-间接寻址" class="headerlink" title="4.间接寻址"></a>4.间接寻址</h4><p>在指令的地址字段中直接给出的不是操作数的直接地址，而是操作数地址的地址。</p>
<blockquote>
<p>间接寻址方式是早期计算机中经常采用的方式，但由于两次访存，执行速度慢，现在已不太使用<br><img src="https://api2.mubu.com/v3/document_image/7688c0fe-f51f-4296-8214-de2e1e793dcd-16175743.jpg" alt="间接寻址"></p>
</blockquote>
<blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/7d846bd8-a82a-430a-aec3-7b1eb3854fc5-16175743.jpg" alt="结合起来的指令格式"></p>
</blockquote>
<h4 id="5-寄存器寻址"><a href="#5-寄存器寻址" class="headerlink" title="5.寄存器寻址"></a>5.寄存器寻址</h4><p>在指令的地址字段中直接给出的操作数地址不是内存的地址，而是<strong>寄存器的编号</strong>。<br><img src="https://api2.mubu.com/v3/document_image/71230b43-fbbd-4de0-acb2-3852c90693d0-16175743.jpg" alt="寄存器寻址"></p>
<h4 id="6-寄存器间接寻址"><a href="#6-寄存器间接寻址" class="headerlink" title="6.寄存器间接寻址"></a>6.寄存器间接寻址</h4><p>类似于上面的间接寻址。<br>在指令的地址字段中直接给出的寄存器不是含有操作数的寄存器编号，而是操作数地址的地址。<br><img src="https://api2.mubu.com/v3/document_image/b9367f6d-0e6e-4803-b961-dd74d7455281-16175743.jpg" alt="jcq间接寻址"></p>
<h4 id="7-偏移寻址"><a href="#7-偏移寻址" class="headerlink" title="7.偏移寻址"></a>7.偏移寻址</h4><p>是直接寻址和寄存器间接寻址方式的结合。EA是有效地址，A是形式地址,也就是偏移量。R代表寄存器。A（偏移量）是一个有符号数。</p>
<p><img src="https://api2.mubu.com/v3/document_image/56c81aa7-de35-43b7-b3cf-6aef2fb60d38-16175743.jpg" alt="偏移寻址"></p>
<ul>
<li>相对寻址 PC，程序计数器</li>
<li>基址寻址 基址寄存器</li>
<li>变址寻址 变址寄存器<br>上面这三者的的不同主要是<strong>寄存器种类不同</strong></li>
</ul>
<h5 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h5><ul>
<li>把<strong>程序计数器PC的内容</strong>加上指令格式中的<strong>偏移量A（有符号数）</strong>而形成<strong>操作数的有效地址</strong>  </li>
<li><strong>程序计数器的内容就是当前指令的地址</strong>，“相对”寻址，就是<strong>相对于当前的指令地址</strong>而言  </li>
<li>好处是<u>程序员无须用指令的绝对地址编程，所编程序可以放在内存任何地方</u></li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/19bf348a-f6ee-4c9a-8d77-6f8c68900b07-16175743.jpg" alt="相对寻址"></p>
<h5 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h5><p>将CPU中<strong>基址寄存器的内容</strong>加上指令格式中的<strong>偏移量A</strong>得到的<strong>操作数有效地址</strong><br>可以<strong>扩大寻址能力</strong>。基址寄存器的位数可以设置得很长，从而可以在较大的存储空间中寻址。<br><img src="https://api2.mubu.com/v3/document_image/70b600ef-a40a-47b6-9a62-4f9312142deb-16175743.jpg" alt="基址寻址"><br>B：基址寄存器</p>
<h5 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h5><p>将CPU中变址寄存器的内容加上指令格式中的偏移量A得到的操作数有效地址。与基址寻址方式类似。但变址寄存器的内容自动递增或递减。<br><img src="https://api2.mubu.com/v3/document_image/106ecb2b-f3cc-4caf-ac7e-a3a6e6670109-16175743.jpg" alt="自动加/减"><br>使用变址寻址方式的目的不在于扩大寻址空间，而在于实现程序块的规律性变化（自动加1减1、或加2减2）</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>例1<br>机器字长16位，<strong>主存按字节编址</strong>，转移指令采用相对寻址，由两个字节组成，第一字节为操作码字段，第二字节为相对位移量字段。假定取指令时，每取一个字节PC自动加1。若Ḁ转移指令所在主存地址为2000H，相对位移量字段的内容为06H，则该转移指令成功转以后的目标地址是<br>A.2006H<br>B.2007H<br>C.2008H<br>D.2009H  </p>
<p>Ans:C<br><mark>PC中存储的是即将执行的下一条指令的地址，也就是PC自动++之后的结果，PC自动加几是看的指令的字节长度,(与机器字长无关)，本题中的指令长度为2字节，所以PC自加加的是2。也就是此时PC中存放的地址是当前指令地址+2，为2002H，然后再加上06H</mark></p>
<p>例2<br>计算机有16个通用寄存器，采用32位定长指令字，操作码字段（含寻址方式位）为8位，Store指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式，若基址寄存器可使用任一通用寄存器，且偏移量用补码表示，则Store指令中偏移量的取值范围是<br>A -32768<del>+32767<br>B -32767</del>+32768<br>C -65536<del>+65535<br>D -65535</del>+65536  </p>
<p>Ans:A<br><mark>32位定长指令，-8位操作码，还剩24位，16&#x3D;2^4个通用寄存器（基址寄存器），由于<u>源操作数采用寄存器直接寻址</u>，所以一共需要4位，<u>目的操作数采用基址寻址</u>，且基址寄存器&#x3D;&#x3D;通用寄存器，所以也需要4位。此时一共用去了16位。偏移量采用补码表示，即计算16位补码能表示上下限，估算2的15次方，注意下限的绝对值比上限大1即可.</mark></p>
<h4 id="8-段寻址"><a href="#8-段寻址" class="headerlink" title="8.段寻址"></a>8.段寻址</h4><p>段寻址看这个图就行<br><img src="https://api2.mubu.com/v3/document_image/865d8ac6-738d-43f5-96a0-4b91e788c716-16175743.jpg" alt="段寻址"></p>
<h4 id="9-堆栈寻址"><a href="#9-堆栈寻址" class="headerlink" title="9.堆栈寻址"></a>9.堆栈寻址</h4><p>所有的操作都是针对栈顶，<strong>后进先出</strong></p>
<h5 id="寄存器堆栈"><a href="#寄存器堆栈" class="headerlink" title="寄存器堆栈"></a>寄存器堆栈</h5><p>存储区域用若干个寄存器组成<br>CPU中有一组专门的寄存器，有16个或者更多，它们称为串联堆栈。数据的进出是通过栈顶实现的<br>CPU通过“进栈”指令把数据送入堆栈，而通过“出栈”指令把数据从堆栈中取出</p>
<p>特点：</p>
<ul>
<li>入栈和出栈时，栈顶不变，数据移动</li>
<li>访问速度快</li>
</ul>
<p>缺点：</p>
<ul>
<li>寄存器的数目有限，所以堆栈大小受限</li>
<li><font color=red>数据的读出是破坏性的</font></li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/5f0003bc-a718-436c-8856-7d60754ee5c8-16175743.jpg" alt="寄存器堆栈"></p>
<h5 id="存储器堆栈"><a href="#存储器堆栈" class="headerlink" title="存储器堆栈"></a>存储器堆栈</h5><p>存储区域是主存的一部分</p>
<ul>
<li>需要一个<strong>堆栈指示器</strong>来指示堆栈中栈顶的位置，它通常是CPU中一个专用的寄存器（<strong>SP：Stack Point</strong>）</li>
<li>比串联堆栈灵活</li>
<li><strong>栈顶变化，由SP指示</strong>，而数据不动</li>
</ul>
<p>优点：</p>
<ul>
<li>堆栈可以根据需要，任何长度</li>
<li>堆栈个数可以根据需要而定</li>
<li>可以用对存储器寻址的任何一条指令来对堆栈进行寻址</li>
</ul>
<!-- 看到4-25-3 20：00-->
<p><img src="https://api2.mubu.com/v3/document_image/bd67a51b-0c26-4107-b371-1dada4bfddb2-16175743.jpg" alt="进栈"></p>
<blockquote>
<p>震惊！8进制300-1居然&#x3D;277！</p>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/e254dee8-829a-4bc6-a08e-472bb0c6f743-16175743.jpg" alt="出栈"></p>
<p>在设计处理器的堆栈操作时，有2种选择：</p>
<ol>
<li>堆栈指示器 SP始终指向空单元<ul>
<li>进栈时，先存入数据，后修改堆栈指示器SP</li>
<li>出栈时，先修改堆栈指示器SP，然后取出数据</li>
<li>这里修改SP可以是加操作，也可以是减操作</li>
</ul>
</li>
<li>堆栈指示器 SP始终指向满单元<ul>
<li>进栈时，先修改堆栈指示器SP，后存入数据</li>
<li>出栈时，先取出数据，然后修改堆栈指示器SP</li>
</ul>
</li>
</ol>
<h4 id="Pentium寻址方式"><a href="#Pentium寻址方式" class="headerlink" title="Pentium寻址方式"></a>Pentium寻址方式</h4><p>没大仔细听，有9种寻址方式<br><img src="https://api2.mubu.com/v3/document_image/a947242f-88bd-4ec0-933c-2ac7e76b71ec-16175743.jpg" alt="9种"></p>
<h5 id="PDP-x2F-11系列机寻址方式"><a href="#PDP-x2F-11系列机寻址方式" class="headerlink" title="PDP&#x2F;11系列机寻址方式"></a>PDP&#x2F;11系列机寻址方式</h5><p>↑写个标题证明老师讲了(</p>
<h5 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h5><p><img src="https://api2.mubu.com/v3/document_image/31d72579-6aba-45e1-8612-f3e2b79dd4da-16175743.jpg" alt="例3"></p>
<p><img src="https://api2.mubu.com/v3/document_image/27c67e1e-2631-435e-a903-fc3040002636-16175743.jpg" alt="答案"></p>
<h5 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h5><p><img src="https://api2.mubu.com/v3/document_image/4e292206-4fb5-47e8-b3dd-2c4a35678aae-16175743.jpg" alt="例4"><br><img src="https://api2.mubu.com/v3/document_image/3e524eeb-6f13-4a26-ba22-a92520bc9a10-16175743.jpg" alt="例4.2"><br><img src="https://api2.mubu.com/v3/document_image/e69aeaed-6df4-4b73-ad34-e93f897f8faa-16175743.jpg" alt="答案"></p>
<h5 id="动手做"><a href="#动手做" class="headerlink" title="动手做"></a>动手做</h5><p><img src="https://api2.mubu.com/v3/document_image/2e5e39ff-8da3-483b-8a35-1bb51b40e76e-16175743.jpg" alt="动手"></p>
<blockquote>
<p>基本上所有的CPU都是按字节编址的，因为是冯诺依曼体系结构，所以指令也被丢在主存里面，按字节编址指的就是对存储器按字节编址，就是说指令的长度得是<mark>8的倍数位</mark><br><a href="https://www.zhihu.com/question/25689240">编址寻址的概念</a></p>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/a1d5abc5-b28f-4841-a4e6-660a501ba001-16175743.jpg" alt="dongshou2"></p>
<h2 id="4-5-典型指令"><a href="#4-5-典型指令" class="headerlink" title="4.5 典型指令"></a>4.5 典型指令</h2><ul>
<li>数据传送指令</li>
<li>算术运算指令</li>
<li>逻辑运算指令</li>
<li>程序控制指令</li>
<li>输入输出指令</li>
<li>串处理指令</li>
<li>特权指令</li>
<li>其他指令</li>
</ul>
<h2 id="CISC-RISC计算机"><a href="#CISC-RISC计算机" class="headerlink" title="CISC RISC计算机"></a><mark>CISC RISC计算机</mark></h2><p>CISC:复杂指令计算机的指令系统一般多达二三百条<br>2-8定律：20%的指令在80%的情况下被使用</p>
<p>复杂指令系统的<strong>特点</strong>:<br><img src="https://api2.mubu.com/v3/document_image/c88812bb-aba7-4617-aa34-6661002d4f45-16175743.jpg" alt="复杂指令系统的特点"></p>
<p>RISC:RISC计算机</p>
<p>精简指令系统的<strong>特点</strong><br><img src="https://api2.mubu.com/v3/document_image/61c9c78d-0c5e-40c6-986e-536dd33fe302-16175743.jpg" alt="精简指令系统的特点"></p>
<p>MIPS指令集被认为是RISC体系中最优雅的一种，DEC的Alpha和惠普的Precision都深受其影响。<br>MIPS指令格式：略</p>
<blockquote>
<p>word table<br> complement 补充，互为补充的东西</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记_chapter5</title>
    <url>/2022/05/09/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_chapter5/</url>
    <content><![CDATA[<p>处理器的功能</p>
<ol>
<li>指令控制</li>
<li>操作控制</li>
<li>时间控制</li>
<li>数据加工</li>
<li>中断处理</li>
</ol>
<p><strong>CPU&#x3D;控制器+运算器+一堆寄存器</strong></p>
<p>控制器<br><img src="https://api2.mubu.com/v3/document_image/55128aff-1bc5-46c0-8f39-c21df4b6815f-16175743.jpg" alt="组成"><br>主要功能</p>
<ul>
<li>从指令cache中<strong>取</strong>出一条<strong>指令</strong>，并<strong>指出下一条指令</strong>在指令cache中的<strong>位置</strong></li>
<li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作</li>
<li>指挥并控制CPU、内存和输入&#x2F;输出设备之间数据流动的方向</li>
</ul>
<p>运算器<br>组成：ALU,累加寄存器，数据缓冲寄存器DR，状态条件寄存器PSW<br>主要功能：</p>
<ul>
<li>执行所有的算数和逻辑运算</li>
<li>并进行逻辑测试，如零值测试或两个值的比较</li>
</ul>
<p>CPU中的主要寄存器（6种）</p>
<ul>
<li>数据缓冲寄存器<strong>DR</strong><br>用来暂时存放：<ol>
<li>向数据cache写入一个数据时，用DR<strong>暂存</strong></li>
<li>ALU计算结果<br> 作用</li>
<li>作为ALU运算结果和通用寄存器之间信息传送中时间上的<strong>缓冲</strong></li>
<li>补偿CPU和内存、外设之间在操作速度上的差别</li>
</ol>
</li>
<li>指令寄存器<strong>IR</strong>(控制器内部)<br>用来<strong>保存当前正在执行的一条指令</strong><br>指令寄存器中操作码字段的输出就是指令译码器的输入<br>操作码经过译码器译码之后，。。。</li>
<li>程序计数器<strong>PC</strong>(控制器内部)<br>也称指令计数器，来确定<strong>下一条</strong>指令的地址<br>在程序开始执行之前，将程序的第一条指令所在的内存单元送入PC<br>执行完之后会自加</li>
<li>地址寄存器<strong>AR</strong><br>用来保存当前处理器所访问的数据cache</li>
<li>通用寄存器<strong>R0~R3</strong>(一般举例子说是4个)<br>在ALU执行运算时，为其提供一个暂存数据的工作区<br><strong>累加寄存器</strong>暂时存放ALU计算结果</li>
<li>状态条件寄存器<strong>PSW</strong>（ALU内部）<br>保存进位标志C，溢出标志O，是否为0Z，结果为负N等等<br>就是存汇编语言中标志位的那个。</li>
</ul>
<h3 id="操作控制器和时序产生器"><a href="#操作控制器和时序产生器" class="headerlink" title="操作控制器和时序产生器"></a>操作控制器和时序产生器</h3><h4 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h4><!-- 等着抄ppt16页 -->
<h4 id="操作控制器"><a href="#操作控制器" class="headerlink" title="操作控制器"></a>操作控制器</h4><p>功能：  </p>
<p>根据设计方法的不同分类：</p>
<ul>
<li>时序逻辑型 硬布线控制器(RISC也是)</li>
<li>存储逻辑性 微程序控制器(CISC也是)</li>
</ul>
<h4 id="时序产生器"><a href="#时序产生器" class="headerlink" title="时序产生器"></a>时序产生器</h4><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p>基本概念</p>
<ul>
<li>指令周期：<strong>取指令、分析指令、执行指令</strong>的time<br>由于各种指令的操作功能不同，各种指令的指令周期长度是不同的。<br>指令周期通常包含若干个CPU周期</li>
<li>CPU周期，也称机器周期<br>内存中读取一个指令字的最短time<br>可以分成若干个时钟周期</li>
<li>时钟周期<br>处理操作的最基本的单位，也成为节拍脉冲&#x2F;T周期</li>
</ul>
<blockquote>
<p>时钟周期是最基本的周期单位<br>如图<br><img src="https://api2.mubu.com/v3/document_image/2fa84ec0-9a03-4917-af3d-46afef8138e3-16175743.jpg" alt="z"><br>↑图中，分析指令过程被包含在执行指令过程中。时钟周期是最小单位，若干时钟周期组成CPU周期，若干CPU周期组成指令周期。</p>
</blockquote>
<p>程序示例<br><img src="https://api2.mubu.com/v3/document_image/936c8718-341d-452a-8b37-fd2951613ea7-16175743.jpg" alt="ex"></p>
<blockquote>
<p>Intel 汇编语言的指令与 AT&amp;T 的指令操作数的方向上正好相反：在 Intel 语法中，第一个操作数是目的操作数，第二个操作数源操作数。而在 AT&amp;T 中，第一个数是源操作数，第二个数是目的操作数。<br><mark>这个程序示例里面是AT&amp;T</mark></p>
</blockquote>
<p>STO为写数指令</p>
<p>凡是RR型指令，都是2个CPU周期，RS型指令，都是3个COU周期。<br>每条指令的<strong>取指令阶段</strong>都是一样的，花费<strong>一个CPU周期</strong>，具体步骤是</p>
<ol>
<li>根据PC的之（将要执行的指令的地址）从内存中取出指令，送到IR</li>
<li>取完之后PC就++</li>
<li>分离操作码和操作数，对指令进行译码</li>
</ol>
<p>RS型指令多一个CPU周期的原因是需要送操作数地址。<br>特别的，JMP指令是无条件的转移指令，相当于是把某个立即数送到寄存器PC，并没有访问memory，所以还是2周期。</p>
<p>最后，检查有无中断的操作也是每条指令都要进行的操作。</p>
<h4 id="方框图"><a href="#方框图" class="headerlink" title="方框图"></a>方框图</h4><ul>
<li>方框：<strong>代表一个CPU周期</strong>，方框中的内容表示数据通路的操作或某种控制操作</li>
<li>菱形：通常用来表示某种判别或测试，在<strong>时间上依附于紧接它的前面一个方框的CPU周期，不单独占用一个CPU周期</strong><br><img src="https://api2.mubu.com/v3/document_image/5e4bf550-24cc-4882-a0c9-18d0c5509a29-16175743.jpg" alt="五条典型指令的周期方框图"></li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://api2.mubu.com/v3/document_image/5a6fedbd-b29d-4fc9-a1d4-785b38f987d7-16175743.jpg" alt="例子1"><br><img src="https://api2.mubu.com/v3/document_image/ce79b93d-c471-4fea-a2bc-4c35ba366fa7-16175743.jpg" alt="例子2"></p>
<p>答案<br>（1）：<br><img src="https://api2.mubu.com/v3/document_image/055d35ce-728f-4576-b6c6-a8ddb7febb09-16175743.jpg" alt="1"></p>
<p>（2）：<br><img src="https://api2.mubu.com/v3/document_image/2b05b876-84ff-40ec-ae72-83b9d1104bda-16175743.jpg" alt="2"></p>
<p>指令周期参考信号图</p>
<p><img src="https://api2.mubu.com/v3/document_image/0d66f063-c178-43a9-96da-8820305d3b97-16175743.jpg" alt="图"></p>
<p>STO指令：<br><img src="https://api2.mubu.com/v3/document_image/2f428f2c-7149-47dc-964a-7c3f019fb45f-16175743.jpg" alt="sto"></p>
<h3 id="5-3时序产生器和控制方式"><a href="#5-3时序产生器和控制方式" class="headerlink" title="5.3时序产生器和控制方式"></a>5.3时序产生器和控制方式</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>时序 Timing</p>
<p>计算机以时序信号为基准完成协调动作</p>
<p>控制器分类：</p>
<ul>
<li>硬布线控制器<br>时序信号一般采用主状态周期-节拍电位-节拍脉冲三级体制。节拍电位的时间&#x3D;CPU周期的时间</li>
<li>微程序控制器<br>时序信号比较简单。一般采用节拍电位-节拍脉冲二级体制</li>
</ul>
<p>微程序控制器中<strong>时序信号产生器</strong>的组成：</p>
<ul>
<li>时钟源</li>
<li>环形脉冲发生器</li>
<li>节拍脉冲和读&#x2F;写时序的译码</li>
<li>启停控制逻辑</li>
</ul>
<p>框图：<br><img src="https://api2.mubu.com/v3/document_image/1fe83be4-8442-43f5-80b9-5d8d8ac87ef5-16175743.jpg" alt="kt"></p>
<h5 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h5><h5 id="环形脉冲发生器"><a href="#环形脉冲发生器" class="headerlink" title="环形脉冲发生器"></a>环形脉冲发生器</h5><ul>
<li>产生一组有序的间隔相等或不等的脉冲序列，以便通过译码电路来产生最后所需的节拍脉冲</li>
<li>为了在节拍脉冲上不带干扰毛刺，环形脉冲发生器通常采用<strong>循环移位寄存器</strong>形式</li>
</ul>
<h5 id="节拍脉冲和读写时序的译码"><a href="#节拍脉冲和读写时序的译码" class="headerlink" title="节拍脉冲和读写时序的译码"></a>节拍脉冲和读写时序的译码</h5><p>译码逻辑：<br>一种环形脉冲发生器：<br><img src="https://api2.mubu.com/v3/document_image/37b5b894-2b32-4972-97de-5ba56743e826-16175743.jpg" alt="图"></p>
<blockquote>
<p>关于D触发器：左边的SD端是清零端，右边的RD端是预置端（置1）（）二者都是低电平有效。<br>分析得，上图的电路状态是一个循环。<br>C1,C2,C3–&gt;<font color=blue>000</font>-&gt;100-&gt;110-&gt;111-&gt;<font color=blue>000</font></p>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/897c66d7-8382-4b42-a508-d879aa65766f-16175743.jpg" alt="t1-t4"></p>
<p>节拍电位与节拍脉冲时序关系图<br><img src="https://api2.mubu.com/v3/document_image/1f6a383c-dd98-4e7e-8ba7-c355e4cafd73-16175743.jpg" alt="y"></p>
<h5 id="启停控制逻辑"><a href="#启停控制逻辑" class="headerlink" title="启停控制逻辑"></a>启停控制逻辑</h5><p>启停控制逻辑<br>u机器一旦接通电源，就会自动产生原始的节拍脉冲信号T1°-T4°。但只有发出启动信号后，才允许时序产生器发出CPU工作所需的完整节拍脉冲</p>
<p>启动信号保证产生完整的CPU周期信号</p>
<p>启停控制逻辑</p>
<p><img src="https://api2.mubu.com/v3/document_image/0dadc9f0-48de-4861-99c1-3c110daaf712-16175743.jpg" alt="电路图"><br>当触发器Cr的Q端为“1”时，原始节拍脉冲和读写信号通过门电路发送出去，变成CPU真正需要的节拍脉冲信号和读写时序，反之，就关闭时序产生器.<br>T4信号取反做时钟信号的原因：<br>保证时序信号以T1,T2,T3,T4的顺序输出。</p>
<h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h4><h5 id="同步控制方式"><a href="#同步控制方式" class="headerlink" title="同步控制方式"></a>同步控制方式</h5><p>Def:在任何情况下，各指令在执行时所需的机器周期数和时钟周期数是固定的</p>
<p>实现方案：</p>
<ol>
<li>采用完全统一的机器周期执行不同的指令。简单指令会导致时间浪费</li>
<li>采用不定长机器周期，复杂指令采取延长机器周期的方法</li>
<li>中央控制与局部控制结合，上面俩结合</li>
</ol>
<h5 id="异步控制方式"><a href="#异步控制方式" class="headerlink" title="异步控制方式"></a>异步控制方式</h5><ol>
<li>每条指令，操作<strong>按需</strong>占用时间</li>
<li>不采用统一的时序信号，而是根据指令或者部件的具体情况而定。“应答”方式，没有时间上的浪费，但控制比较复杂.</li>
</ol>
<h5 id="联合控制方式"><a href="#联合控制方式" class="headerlink" title="联合控制方式"></a>联合控制方式</h5><p>同步和异步相结合</p>
<ol>
<li>大部分操作序列安排在固定的机器周期中，对某些时间难以确定的操作则采用“应答”信号作为本次操作的结束</li>
<li>机器周期的节拍脉冲数是固定的，但是各条指令的机器周期数不固定</li>
</ol>
<h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a><mark>微程序控制器</mark></h3><p>微程序设计技术是利用<strong>软件方法</strong>来<strong>设计硬件</strong>的一门技术<br>微程序控制器与硬布线控制器相比较，具有<strong>规整性、灵活性、可维护性</strong>等一系列优点</p>
<p>基本思想</p>
<ul>
<li>用多条微指令（即：一个微程序）解释每条指令的执行过程。全部的微程序有机地组合在一起，存储在控制存储器（只读存储器）中。</li>
<li>当机器运行时，一条一条地读出这些微指令，从而产生全机所需要的各种操作控制信号，使相应的部件执行特定的操作</li>
</ul>
<h4 id="微命令和微操作"><a href="#微命令和微操作" class="headerlink" title="微命令和微操作"></a>微命令和微操作</h4><p>计算机的构成</p>
<ul>
<li>控制部件–控制器</li>
<li>执行部件–运算器、存储器、外围设备</li>
</ul>
<p><strong>微命令</strong>－控制部件通过控制线向执行部件发出各种控制命令（<strong>即：控制信号</strong>）<br>微操作－执行部件接受微命令后所进行的特定操作</p>
<p>反馈信息<br>通常执行部件使用反馈线向控制部件报告操作情况，控制部件则根据执行部件的“状态”发出新的微命令。</p>
<p>分类：</p>
<ul>
<li>相容性操作：同时或在同一个CPU周期内可以并行执行的微操作</li>
<li>相斥性操作：不能同时或不能在同一个CPU周期内并行执行的微操作</li>
</ul>
<h4 id="微指令"><a href="#微指令" class="headerlink" title="微指令"></a>微指令</h4><ul>
<li>在机器的一个CPU周期中，一组实现一定操作功能的<strong>微命令的组合</strong>，构成一条微指令<br>或者说</li>
<li>用一条微指令对应一条机器指令的一个执行步骤</li>
<li>微指令需要具备的2个功能<ul>
<li>供一条机器指令的一个执行步骤所需要的控制信号，以实现该执行步骤的操作功能</li>
<li>提供读出下一条待用微指令的地址，以便自动有序地读出每一条微指令，解决机器指令执行步骤之间的正确的接续关系</li>
</ul>
</li>
</ul>
<h5 id="微指令基本格式"><a href="#微指令基本格式" class="headerlink" title="微指令基本格式"></a>微指令基本格式</h5><p><img src="https://api2.mubu.com/v3/document_image/383c97cf-53d9-4d5e-bfd6-2bd0436fcd2b-16175743.jpg" alt="tu"></p>
<h4 id="微程序控制器-1"><a href="#微程序控制器-1" class="headerlink" title="微程序控制器"></a>微程序控制器</h4><ul>
<li>控制存储器</li>
<li>微指令寄存器<ul>
<li>微地址寄存器</li>
<li>微命令寄存器</li>
</ul>
</li>
<li>地址转移逻辑</li>
</ul>
<p>原理框图：<br><img src="https://api2.mubu.com/v3/document_image/58a90eb4-a580-405a-ad0f-98de5b7bd62f-16175743.jpg" alt="tu"></p>
<h4 id="微程序的特点"><a href="#微程序的特点" class="headerlink" title="微程序的特点"></a>微程序的特点</h4><ul>
<li><p>一条<strong>机器指令是若干条微指令组成的序列</strong>来实现的</p>
</li>
<li><p>一条机器指令<strong>对应着一段微程序</strong>，而微程序的总和便可实现整个的指令系统</p>
</li>
<li><p>微程序设计可以很容易地在不同的微体系结构上实现相同的</p>
</li>
<li><p>以十进制加法指令操作码为地址，去查微地址映射部件得到微程序在控制存储器中的地址，就可以调出所需要的微程序（如上图中微程序地址为1010）</p>
</li>
<li><p>微地址映射部件是用ROM实现的，地址输入为指令寄存器IR的操作码，输出为该指令对应的微程序段的入口地址</p>
</li>
</ul>
<h4 id="微程序举例"><a href="#微程序举例" class="headerlink" title="微程序举例"></a>微程序举例</h4><p><a href="https://api2.mubu.com/v3/document_image/527b8a8b-2c78-4389-bead-b4b2fbf09e07-16175743.jpg">微程序举例，十进制BCD码加法</a></p>
<h4 id="微指令周期与CPU周期的关系"><a href="#微指令周期与CPU周期的关系" class="headerlink" title="微指令周期与CPU周期的关系"></a>微指令周期与CPU周期的关系</h4><p>微指令周期 &#x3D; 读出微指令的时间 + 执行该条微指令的时间</p>
<p>为了保证整个机器控制信号的同步，可以将一个微指令周期 时间设计得恰好和CPU周期时间相等</p>
<p><img src="https://api2.mubu.com/v3/document_image/59fd1ac9-7829-47ef-ade6-61b48707e9ea-16175743.jpg" alt="微指令周期与CPU周期的关系"></p>
<h4 id="机器指令与微指令的关系"><a href="#机器指令与微指令的关系" class="headerlink" title="机器指令与微指令的关系"></a>机器指令与微指令的关系</h4><p><img src="https://api2.mubu.com/v3/document_image/f617eec9-90f1-48ba-8330-46226f08b2af-16175743.jpg" alt="关系"></p>
<h3 id="5-4微程序设计技术"><a href="#5-4微程序设计技术" class="headerlink" title="5.4微程序设计技术"></a>5.4微程序设计技术</h3><h4 id="微命令编码"><a href="#微命令编码" class="headerlink" title="微命令编码"></a>微命令编码</h4><p>微指令操作控制字段的微命令表示方法可分为3类</p>
<ul>
<li><strong>直接表示</strong>法：操作控制字段中的每一位代表一个微命令</li>
<li><strong>直接编码</strong>表示法：<br>把一组<strong>相斥性</strong>的微命令信号组成一个小组(即一个字段) ，然后通过小组(字段）译码器对每一个微命令信号进行译码 ，译码输出作为操作控制信号<blockquote>
<p>编码表示法使微指令字的长度大大缩短。但由于增加译码电路，微程序的执行速度稍稍减慢编码表示法使用较</p>
</blockquote>
</li>
<li><strong>混合</strong>表示法：见图<br><img src="https://api2.mubu.com/v3/document_image/0bf4a4b1-ae5e-44c8-92d9-0614a2408d6b-16175743.jpg" alt="ru"></li>
</ul>
<p>在微指令中还可附设一个常数字段</p>
<ul>
<li>可作为操作数送入ALU运算</li>
<li>也可作为计数器初值用来控制微程序循环次数</li>
</ul>
<h4 id="微地址的形成方法"><a href="#微地址的形成方法" class="headerlink" title="微地址的形成方法"></a>微地址的形成方法</h4><p>产生后继微地址的方法</p>
<ul>
<li>计数器方式(类似PC)</li>
<li>多路转移方式(跳转)<ul>
<li>当微程序不产生分支时，后继微地址直接由微指令的顺序控制字段给出</li>
<li>当微程序出现分支时，有若干“候选”微地址可供选择：即按顺序控制字段P的“判别测试”和“状态条件”标志来选择其中一个微地址</li>
<li>“状态条件”有n位标志，可实现微程序2n路转移，且涉及微地址寄存器的n位</li>
</ul>
</li>
<li>由指令的操作码转换得到，典型方式为查表方式</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/8d5d9a41-8571-40d9-9b96-e223391e222e-16175743.jpg" alt="例子"></p>
<h4 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h4><ul>
<li>水平型微指令</li>
<li>竖直型微指令</li>
</ul>
<p>简单说，水平行比较长，上面那三种译码方式都是针对水平指令的，一次能定义并执行多个并行操作微命令。效率高，灵活性强，但基本别想凭肉眼看懂，因为每一位代表一个操作，然后每条指令就是微操作的组合（位的组合），然后最后写出来的微程序比较短，整体是个躺着的长方形（不恰当的比喻）。</p>
<p>竖直型指令就有点像经常见的指令了，有操作码，有源地址和目的地址。<br>每条指令完成的功能比较简单，所以最后写出来的微程序比较长，整体看就是个竖着的长方形。特别的，竖直型指令虽然完成的功能简单，这玩意儿执行时间还长。</p>
<h3 id="5-5硬连线控制器"><a href="#5-5硬连线控制器" class="headerlink" title="5.5硬连线控制器"></a>5.5硬连线控制器</h3><p>基本概念：<br><img src="https://api2.mubu.com/v3/document_image/97adce27-8881-477a-8751-ce093f4cb6a4-16175743.jpg" alt="j"></p>
<p>硬连线控制器原理框图：<br><img src="https://api2.mubu.com/v3/document_image/11d6c042-cf3a-4b9d-a329-937fc81f0065-16175743.jpg" alt="图"></p>
<p>写出以下控制信号的逻辑表达式：<br>例子：<br><img src="https://api2.mubu.com/v3/document_image/55d7ec59-90e7-4335-9d91-4f078eb0e28a-16175743.jpg" alt="例子"></p>
<p>另一个举例：<br>这里需要注意的是T信号的划分：<br><mark>一般一个微操作分配一个时钟周期，读写内存分配两个时钟周期</mark><br><img src="https://api2.mubu.com/v3/document_image/afbb828f-3d6b-4e56-b3af-618153c6d530-16175743.jpg" alt="例子"></p>
<h3 id="5-6流水CPU"><a href="#5-6流水CPU" class="headerlink" title="5.6流水CPU"></a>5.6流水CPU</h3><p>流水方式CPU：指令部件、指令队列、执行部件</p>
<ul>
<li>指令部件</li>
<li>指令队列：FIFO寄存器栈</li>
<li>执行部件：可以有多个采用流水线方式构成的算术逻辑部件构成，可以将定点运算部件和浮点运算部件分开</li>
</ul>
<p>几个缩写的含义：</p>
<ul>
<li>IF（Instruction Fetch取指）</li>
<li>ID（Instruction Decode指令译码）</li>
<li>EX（Execution执行）</li>
<li>WB（Write Back写回</li>
</ul>
<p>4级指令流水线<br><img src="https://api2.mubu.com/v3/document_image/e26adf24-76a8-422a-9bdf-c676e98102f3-16175743.jpg" alt="4"></p>
<p>几个概念：</p>
<p>线性流水线的时钟周期</p>
<p>$$<br>\tau&#x3D;\max {\tau_i}+\tau_1&#x3D;\tau+m+\tau_1;<br>$$</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记_chapter6</title>
    <url>/2022/06/07/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0_chapter6/</url>
    <content><![CDATA[<h1 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h1><h2 id="6-1总线概念-amp-基本结构"><a href="#6-1总线概念-amp-基本结构" class="headerlink" title="6.1总线概念&amp;基本结构"></a>6.1总线概念&amp;基本结构</h2><p>总线定义：</p>
<p>是指在功能部件和功能部件之间或设备与设备之间的一组进行互连和传输信息的信号线，<br>这里信息可以是指令、数据或地址</p>
<p>总线的优点：</p>
<ul>
<li>解决外设多而杂的问题，容易添加新的设备</li>
<li>降低成本</li>
<li>简化设计</li>
</ul>
<p>总线的缺点：</p>
<ul>
<li>总线带宽可能限制整条总线的吞吐量</li>
</ul>
<p>总线的最高速度的影响因素：</p>
<ul>
<li>总线长度</li>
<li>负载的设备树</li>
<li>负载设备的特性：设备的延迟？设备数据传输率？<br>所以我们设计的时候尽量把速度差不多的设备挂在同一条总线上。</li>
</ul>
<p>总线分类</p>
<ul>
<li>内部总线</li>
<li>系统总线<ul>
<li>数据总线DBUS，双向，与机器字长，存储字长有关</li>
<li>地址总线ABUS，单向，与存储地址，IO字长有关</li>
<li>控制总线，一般单向</li>
</ul>
</li>
<li>设备总线</li>
</ul>
<p>总线的层次结构<br><img src="/7" alt="7"></p>
<p>总线的内部结构<br><img src="/9" alt="9"></p>
<p>总线的特性</p>
<p>总线的性能指标</p>
<!-- ppt11 -->
<ul>
<li>总线宽度<ul>
<li>数据线的条数，串，并行性</li>
</ul>
</li>
<li>总线传输率（带宽）</li>
<li>定时协定</li>
<li>信号线数</li>
<li>负载能力</li>
</ul>
<p><mark>记得换算单位！</mark></p>
<p>总线的标准化</p>
<p>目前已经出现了很多总线标准：</p>
<ul>
<li>PCI</li>
<li>ISA</li>
</ul>
<p>总线的连接方式</p>
<p>适配器（又称接口：<!---ppt14---></p>
<p>单机系统中总线结构的三种基本类型：</p>
<ul>
<li>单总线</li>
<li>双总线</li>
<li>三总线</li>
</ul>
<blockquote>
<p>这三种总线基本上是按照不同设备的不同速度进行了不同精度的划分</p>
</blockquote>
<p>单总线结构：<br><img src="/15" alt="15"><br>双总线结构：<br><img src="/16" alt="16"><br>三总线结构：<br><img src="/17" alt="17"></p>
<p>典型总线：<br><img src="/18" alt="ppt18"></p>
<h2 id="6-2总线接口"><a href="#6-2总线接口" class="headerlink" title="6.2总线接口"></a>6.2总线接口</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>信息传送的方式<ul>
<li>串行</li>
<li>并行</li>
</ul>
</li>
<li>出于速度和效率上的考虑，一般用并行</li>
</ul>
<h3 id="串行传送"><a href="#串行传送" class="headerlink" title="串行传送"></a>串行传送</h3><ul>
<li>使用一条传输线，成本低，适合长距离传输，但是速度慢</li>
</ul>
<h3 id="并行传送"><a href="#并行传送" class="headerlink" title="并行传送"></a>并行传送</h3><p>一般采用电位传送，每一数据位需要一条传输线<br>为了节省线的条数，采用分时复用</p>
<h3 id="接口的基本概念"><a href="#接口的基本概念" class="headerlink" title="接口的基本概念"></a>接口的基本概念</h3><ul>
<li>接口是CPU和主存、外设之间通过总线进行连接的逻辑部件</li>
<li>接口的典型功能：控制、缓冲、状态、转换和程序中断<!-- ppt24 --></li>
</ul>
<h2 id="6-3总线的仲裁"><a href="#6-3总线的仲裁" class="headerlink" title="6.3总线的仲裁"></a>6.3总线的仲裁</h2><p>主设备和从设备的交互称为一个总线事务单元，因此总线事务包括两个部分：</p>
<ul>
<li>发起命令</li>
<li>传输数据</li>
</ul>
<p>总线占用期：主设备持续控制总线的时间</p>
<h3 id="集中式仲裁"><a href="#集中式仲裁" class="headerlink" title="集中式仲裁"></a>集中式仲裁</h3><p>有点像交通警察在路口指挥交通</p>
<h4 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h4><p>ppt30<br>总线请求-&gt;转递请求-&gt;总线响应-&gt;总线忙</p>
<p>总线请求(&#x2F;BR)和总线忙(&#x2F;BB)都是低电平有效。</p>
<p>链式查询有隐含的优先级，离仲裁器近的优先级高</p>
<p>优点：</p>
<ul>
<li>实现简单</li>
<li>便于增删</li>
</ul>
<p>缺点：</p>
<ul>
<li>故障敏感，有点像电路，前一个模块出现问题后面的都不能工作</li>
<li>仲裁速度慢</li>
<li>优先级不能改变，优先级低的设备可能会“饿死”</li>
</ul>
<p>电路图：<br><img src="/(https:/api2.mubu.com/v3/document_image/2a959174-a2b1-4d36-bf90-bc432a6f3d63-16175743.jpg)" alt="34"></p>
<h4 id="计数器定时查询"><a href="#计数器定时查询" class="headerlink" title="计数器定时查询"></a>计数器定时查询</h4><p><img src="https://api2.mubu.com/v3/document_image/b518873e-2241-4b53-817a-9429bd635a59-16175743.jpg" alt="jsq"></p>
<h4 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h4><p><img src="https://api2.mubu.com/v3/document_image/2248541b-f7d1-4742-bc69-22614b07b832-16175743.jpg" alt="duli"><br>优点</p>
<ul>
<li>响应时间短</li>
<li>控制相当灵活</li>
<li>故障不敏感</li>
</ul>
<p>缺点</p>
<ul>
<li>线路复杂</li>
<li>不易增加设备（总线仲裁器的引脚数是定的）</li>
</ul>
<h3 id="分布式仲裁"><a href="#分布式仲裁" class="headerlink" title="分布式仲裁"></a>分布式仲裁</h3><p>分布式仲裁不需要集中的总线仲裁器，每个潜在的主方功能模块都有自己的仲裁号和仲裁器。当它们有总线请求时，把它们唯一的<strong>仲裁号</strong>发送到共享的仲裁总线上，每个仲裁器将仲裁总线上得到的号与自己的号进行比较。如果仲裁总线上的号大，则它的总线请求不予响应，并撤销它的仲裁号。最后，获胜者的仲裁号保留在仲裁总线上。显然，分布式仲裁是以优先级仲裁策略为基础。</p>
<p>有点像路口没有警察，所有车辆先停下，确认其他方向没有来车之后再通行</p>
<p>示意图<br><img src="https://api2.mubu.com/v3/document_image/b50c15e8-ead4-48de-b290-aaff1ac0fa23-16175743.jpg" alt="tu"></p>
<h2 id="6-4-总线的定时和数据传送模式"><a href="#6-4-总线的定时和数据传送模式" class="headerlink" title="6.4 总线的定时和数据传送模式"></a>6.4 总线的定时和数据传送模式</h2><h3 id="总线的定时"><a href="#总线的定时" class="headerlink" title="总线的定时"></a>总线的定时</h3><h4 id="同步定时"><a href="#同步定时" class="headerlink" title="同步定时"></a>同步定时</h4><h4 id="异步定时"><a href="#异步定时" class="headerlink" title="异步定时"></a>异步定时</h4><h3 id="总线数据传送模式"><a href="#总线数据传送模式" class="headerlink" title="总线数据传送模式"></a>总线数据传送模式</h3><ul>
<li>读写操作<ul>
<li>读操作是由从方到主方的数据传送</li>
<li>写操作是由主方到从方的数据传送</li>
</ul>
</li>
</ul>
<blockquote>
<p>为了提高总线利用率，减少延时损失，主方完成寻址总线周期后可让出总线控制权，以使其他主方完成更紧迫的操作。然后再重新竞争总线，完成数据传送总线</p>
</blockquote>
<ul>
<li><p>块传送操作</p>
<ul>
<li>只需给出块的起始地址，然后对固定块长度的数据逐一地读出或写入。对于CPU（主方）-存储器（从方）而言的块传送，常称为突发式传送，其块长一般固定为数据线宽度（存储器字长）的<strong>4倍</strong></li>
</ul>
</li>
<li><p>写后读、读-修改-写操作<br>这是两种组合操作。只给出地址一次（表示同一地址），或进行先写后读操作，或进行先读后写操作。前者用于校验目的，后者用于多道程序系统中对共享存储资源的保护。这两种操作和突发式操作一样，主方掌管总线直到整个操作完成</p>
</li>
<li><p>广播、广集操作</p>
<ul>
<li>一般而言，数据传送只在一个主方和一个从方之间进行。</li>
<li>但有的总线允许<strong>一个主方</strong>对<strong>多个从方</strong>进行写操作，这种操作称为广播。</li>
<li>与广播相反的操作称为广集，它将选定的<strong>多个从方数据</strong>在总线上完成AND或OR操作，用以检测多个中断源。</li>
</ul>
</li>
</ul>
<h2 id="6-5HOST总线和PCI总线"><a href="#6-5HOST总线和PCI总线" class="headerlink" title="6.5HOST总线和PCI总线"></a>6.5HOST总线和PCI总线</h2><p><img src="https://api2.mubu.com/v3/document_image/34b2d4d3-23b7-4a78-836e-8817e697b701-16175743.jpg" alt="多总线框图"></p>
<h3 id="PCI总线"><a href="#PCI总线" class="headerlink" title="PCI总线"></a>PCI总线</h3><p>Peripheral Component Interconnect 周边器件的互联</p>
<h4 id="PCI总线信号"><a href="#PCI总线信号" class="headerlink" title="PCI总线信号"></a>PCI总线信号</h4><h4 id="总线周期类型"><a href="#总线周期类型" class="headerlink" title="总线周期类型"></a>总线周期类型</h4>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记-1综述</title>
    <url>/2022/03/09/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0-1%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="1-3网络软件"><a href="#1-3网络软件" class="headerlink" title="1.3网络软件"></a>1.3网络软件</h2><h3 id="协议层次结构Protocol-Hierarchies"><a href="#协议层次结构Protocol-Hierarchies" class="headerlink" title="协议层次结构Protocol Hierarchies"></a>协议层次结构Protocol Hierarchies</h3><ul>
<li>为了降低网络设计的复杂性，绝大多数网络都组成了层次栈(a stack of layer)或(a stack of level)。从某种意义上来说，每一层都是一种虚拟机，第n层向第n+1层提供服务。</li>
<li><strong>协议protocol</strong>：通信双方的一种约定</li>
<li><strong>对等体peers</strong>：不同机器上同一层的实体</li>
<li><strong>物理层次Physical medium</strong>：铜线，光纤</li>
<li><strong>接口interface</strong>：Defines which <mark>primitive operations原语操作</mark> and services the lower layer makes available to the upper one，类似于函数调用的接口</li>
<li><strong>网络体系结构</strong>&#x3D;层+协议A set of layers and protocols 网络体系结构<strong>不包括</strong>协议内部的实现细节，也不包括接口的规范。</li>
<li><img src="https://api2.mubu.com/v3/document_image/3f2c4521-c474-4228-8629-b682619c7f09-16175743.jpg"></li>
<li>支持第五层虚拟通信的信息流：假设在第5层上运行的一个应用进程产生了一.条消息M,并且将它传递给第4层以便传给对等进程;第4层在消息的前面加上一一个头(header)， 用来标识该消息，并且把结果传给第3层;该头包含了一些控制信息，例如地址，主要被目标机器的第4层用来递交消息。某些层次所用的控制信息还可以包含消息序号(以防下层不保留消息顺序)、消息大小、时间等。<br><img src="https://api2.mubu.com/v3/document_image/4bd06528-60a8-4049-8fb3-63709fa51e26-16175743.jpg" alt="支持第五层虚拟通信的信息流"><br>在许多网络中，对于第4层上传递的消息<strong>大小</strong>没有任何限制，但是几乎所有第3层协议对此总会强加一个限制。因此，第3层必须把入境消息分割成较小的单元，即数据包或包(packet)，并且在每个数据包前面加上第3层的头。在这个例子中，M被分割成两部分：M1和M2，这两部分内容是被单独传输的。</li>
</ul>
<p><strong>第3层</strong>决定使用哪些<strong>输出线路</strong>，并且把分组传递给第2层；<strong>第2层不仅在每一个信息上加上一个头信息还要加上一个尾</strong>，然后将结果传输单元送给第1层以便进行物理传输。在接收端的机器上，消息自底向上逐层传递，<strong>在传递过程中各个头被逐层剥离</strong>。没有一个第n层以下的头会被传递到第n层。</p>
<h3 id="层次设计问题Design-Issues-for-the-Layers"><a href="#层次设计问题Design-Issues-for-the-Layers" class="headerlink" title="层次设计问题Design Issues for the Layers"></a>层次设计问题Design Issues for the Layers</h3><ul>
<li>可靠性Reliability</li>
<li>网络发展Network evolution：可拓展性，网络互通性</li>
<li>资源分配Resource allocation：统计复用，流量控制</li>
<li>QoS（服务质量）：quality of service，包括的指标有 带宽bandwidth、延迟delay&#x2F;latency、抖动（Jitter）</li>
<li>安全Security</li>
</ul>
<h3 id="面向连接的服务和无连接的服务"><a href="#面向连接的服务和无连接的服务" class="headerlink" title="面向连接的服务和无连接的服务"></a>面向连接的服务和无连接的服务</h3><ul>
<li>面向连接Connection-oriented: telephone system，需要建立连接</li>
<li>无连接Connection-less: postal system，不需要事先建立连接</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/79af3961-0095-4781-b7a7-31ed1b3022a9-16175743.jpg" alt="Six different types of service"><br><img src="https://api2.mubu.com/v3/document_image/848bcef7-4baa-40fb-a356-7d14ac0f211e-16175743.jpg" alt="Six different types of service"></p>
<p><mark>Point：有链接的服务<strong>不一定</strong>是可靠的！</mark></p>
<h3 id="服务原语Service-Primitives"><a href="#服务原语Service-Primitives" class="headerlink" title="服务原语Service Primitives"></a>服务原语Service Primitives</h3><ul>
<li>原语可能看起来像函数调用中的函数名字</li>
<li>PDU: Protocol Data Unit协议数据单元：信息在对等体之间交换</li>
</ul>
<h3 id="服务与协议之间的关系"><a href="#服务与协议之间的关系" class="headerlink" title="服务与协议之间的关系"></a>服务与协议之间的关系</h3><p>服务和协议是两个截然不同的概念，它们之间的区别非常重要。</p>
<ul>
<li><p><strong><mark>服务是指</mark>某一层向它上一层提供的一-组原语(操作)。服务定义了该层准备代表其用户执行哪些操作，但是它并不涉及如何实现这些操作。</strong> 服务与两层之间的接口有关，<strong>低层是服务提供者，而上层是服务用户</strong>。</p>
</li>
<li><p>与此不同的是，**<mark>协议是</mark>一组规则，规定了同一层上对等实体之间所交换的数据包或者报文的格式和含义<strong>。对等实体利用协议来实现它们的服务定义，它们可以自由地改变协议，只要不改变呈现给它们用户的服务即可。按照这种方式，</strong>服务和协议是完全相分离的**，这是任何一个网络设计者应该很好理解的关键概念。</p>
</li>
<li><p>不改变服务，可以随意改变协议。</p>
</li>
</ul>
<h2 id="1-4-参考模型Reference-Models"><a href="#1-4-参考模型Reference-Models" class="headerlink" title="1.4 参考模型Reference Models"></a>1.4 参考模型Reference Models</h2><h3 id="OSI参考模型-The-OSI-Reference-Model"><a href="#OSI参考模型-The-OSI-Reference-Model" class="headerlink" title="OSI参考模型 The OSI Reference Model"></a>OSI参考模型 The OSI Reference Model</h3><ul>
<li>OSI体系结构是要求记住的，因为计算机网络的核心是计算机体系结构。但是OSI结构在日常生活中也不咋见到，用的人少。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/ba8267b6-e3d1-404d-a27e-4811a15b006f-16175743.jpg" alt="OSI体系结构"></p>
<p>对应的中文对照：<br><img src="https://api2.mubu.com/v3/document_image/89804771-1c92-46b4-b0eb-a65599fe34c4-16175743.jpg" alt="OSI体系结构-zh"></p>
<p>一般的，在网络里的路由设备只需要完成1，2，3层的协议就可以(如框框里圈起来的part)</p>
<ol>
<li>物理层：使用通信的信道传输原始的bit流</li>
</ol>
<ul>
<li>使用多少伏特表示1，多少伏特表示0</li>
<li>每个比特持续多长时间</li>
<li>传输是否能够双向同时(simultaneously)发送信息</li>
<li>初始链接是如何链接以及如何释放的，比如打电话，挂断，一般链接是按时间计费的</li>
</ul>
<ol start="2">
<li><p>数据链路层：把原始的传输转化成逻辑的信道。一句话总结，就是(可靠的)数据帧的传输 <mark><strong>Point To Point点到点</strong></mark></p>
<ul>
<li>将到达的数据变成一块一块的frame(帧）(这个功能仅部分的数据链路层拥有)</li>
<li>如果要求可靠的传输，要对正确的数据帧发送comfirm</li>
<li>流量控制：保持快速传输，防止数据传输缓慢</li>
<li>广播网络：管理共享信道的使用权力(access)</li>
</ul>
</li>
<li><p>网络层：主要控制的是路由和转发的问题，控制子网的运行</p>
<ul>
<li>传递forwarding</li>
<li>路由router：静态路由；规划路由；<strong>动态路由highly dynamic</strong>；</li>
<li>拥塞控制congestion</li>
<li>QoS：delay延迟，transit time传输时间，jitter抖动, 带宽，丢包率etc.</li>
<li>异构网络互联Heterogeneous networks interconnection</li>
<li>广播网络 routing is simple</li>
</ul>
</li>
<li><p>传输层：<mark>End To End端到端</mark></p>
<ul>
<li>从上层接受数据，把这些数据分成小的数据单元(if needed)，把这些数据单元</li>
<li>决定向会话层提供何种服务</li>
<li>控制拥塞</li>
</ul>
</li>
<li><p>会话层：通信的双方(虚拟层面的不同机器)建立会话链接</p>
<ul>
<li>对话控制</li>
<li>令牌Token管理</li>
<li>同步：断点重传</li>
</ul>
</li>
<li><p>表示层：信息传递的 <em>语法和语义</em></p>
<ul>
<li>抽象定义被传输的信息。比如大端小端。</li>
</ul>
</li>
<li><p>应用层：包括通常被用户使用的各种协议</p>
</li>
</ol>
<h3 id="TCP-x2F-IP参考模型-The-TCP-x2F-IP-Reference-Model"><a href="#TCP-x2F-IP参考模型-The-TCP-x2F-IP-Reference-Model" class="headerlink" title="TCP&#x2F;IP参考模型 The TCP&#x2F;IP Reference Model"></a>TCP&#x2F;IP参考模型 The TCP&#x2F;IP Reference Model</h3><p>TCP&#x2F;IP参考模型：<strong>右侧</strong><br><img src="https://api2.mubu.com/v3/document_image/1823c7c6-b736-4899-8148-728753f9aeaa-16175743.jpg" alt="TCP/IP参考模型"></p>
<ul>
<li><p>网络接口层(PPT)，中文书上叫链路层，这不是一个真正意义上的层，而是主机与传输路线之间的一个接口。</p>
</li>
<li><p>互联网层：一个基于无连接互联网络的数据包交换网络</p>
<ul>
<li>定义了一种官方的数据包和协议格式，叫做IP(Internet Protocol)</li>
<li>网络层的工作是把IP数据包发送到他们应该去往的地方，这里面又包括了路由问题，避免拥塞问题</li>
</ul>
</li>
<li><p>传输层：</p>
<ol>
<li><p><strong>传输控制协议TCP (Transmission Control Protocol)</strong></p>
<ul>
<li>面向连接的、可靠的、字节流</li>
<li>碎片化fragment字节流</li>
<li>重新组装接收到的信息到输出流(保证了传输顺序)</li>
<li>流量控制，避免淹没</li>
</ul>
</li>
<li><p><strong>用户数据报协议: The UDP(User Datagram Protocol)</strong></p>
<ul>
<li>无连接的、不可靠的、消息流(一块一块的发送消息)</li>
<li>适用于不想要TCP有序控制和流量控制，而宁可自己提供这些功能的应用程序。比如及时交付比准确交付更重要的应用，比如语音和视频通话</li>
</ul>
</li>
</ol>
</li>
<li><p>应用层：略<br>TCP&#x2F;IP模型以及各种需要学习的协议<br><img src="https://api2.mubu.com/v3/document_image/4eba9cfd-9f3d-4a91-9fec-d12fdf829f32-16175743.jpg" alt="一览表"><br>中文简化版：<br><img src="https://api2.mubu.com/v3/document_image/53465012-ec7b-4b4b-9891-e2637d5dbbbc-16175743.jpg" alt="中文简化版："></p>
</li>
</ul>
<h3 id="OSI参考模型与TCP-x2F-IP参考模型的比较"><a href="#OSI参考模型与TCP-x2F-IP参考模型的比较" class="headerlink" title="OSI参考模型与TCP&#x2F;IP参考模型的比较"></a>OSI参考模型与TCP&#x2F;IP参考模型的比较</h3><p>略，gzc没细讲，有兴趣让看书。</p>
<h3 id="OSI模型和协议的评判"><a href="#OSI模型和协议的评判" class="headerlink" title="OSI模型和协议的评判"></a>OSI模型和协议的评判</h3><p>gzc没讲，书上骂了一通，可以看个乐。截个图感受下。<br><img src="https://api2.mubu.com/v3/document_image/e13d23a0-3431-4a4b-8f63-d2118c9b9c80-16175743.jpg" alt="乐"></p>
<h3 id="TCP-x2F-IP参考模型的评判"><a href="#TCP-x2F-IP参考模型的评判" class="headerlink" title="TCP&#x2F;IP参考模型的评判"></a>TCP&#x2F;IP参考模型的评判</h3><p>没讲，没看</p>
<h2 id="1-5网络实例"><a href="#1-5网络实例" class="headerlink" title="1.5网络实例"></a>1.5网络实例</h2><p>没咋讲，没啥要记的东西，略</p>
<h2 id="网络标准化1-6-Network-Standardization"><a href="#网络标准化1-6-Network-Standardization" class="headerlink" title="网络标准化1.6 Network Standardization"></a>网络标准化1.6 Network Standardization</h2><h3 id="电信领域有影响力的组织"><a href="#电信领域有影响力的组织" class="headerlink" title="电信领域有影响力的组织"></a>电信领域有影响力的组织</h3><p><strong>国际电信联盟ITU (International Telecommunication Union)</strong></p>
<p>主要部门：</p>
<ul>
<li>Radio communications(ITU-R)</li>
<li>Telecommunications Standardization(ITU-T)<br>$\tiny CCITT, Comité Consultatif International Télégraphique et Téléphonique (1956-1993)$</li>
<li>Development(ITU-D)</li>
</ul>
<h3 id="国际标准有影响力的组织"><a href="#国际标准有影响力的组织" class="headerlink" title="国际标准有影响力的组织"></a>国际标准有影响力的组织</h3><ul>
<li>国际标准化组织ISO (International Standards Organization):OSI是在计算机网络里的一个例子</li>
<li>ANSI (American National Standards Institute)</li>
<li>IEEE (Institute of Electrical and Electronics Engineers)<br><img src="https://api2.mubu.com/v3/document_image/8f845344-a835-4a69-8c8f-7cb3557ed8cf-16175743.jpg"><br>TCP&#x2F;IP是属于IETF的</li>
</ul>
<h3 id="计算机网络中的单位换算"><a href="#计算机网络中的单位换算" class="headerlink" title="计算机网络中的单位换算"></a>计算机网络中的单位换算</h3><p>不同于计算内存的KB,MB,GB(2的幂次)，因为内存总是2的幂次。</p>
<p>此外，这种情况下用大写的B表示Byte字节，而小写的b表示bit比特。</p>
<p><img src="https://api2.mubu.com/v3/document_image/50180420-6d48-47d4-ae7c-9647d65a4d18-16175743.jpg" alt="单位"></p>
<p>由于$milli和micro$都以字母m开头，所以两者必须进行区分。通常情况下，$m$ 代表毫(milli),而$μ$ (希腊字母)代表微(micro)。</p>
<p>在本书中，为了避免二义性，我们将使用符号KB、MB、GB和TB分别代表$2^{10}、2^{20}、2^{30}$ 和 $2^{40}$ 字节;用符号 $kbps、Mbps、Gbps$ 和 $Tbps$分别代表$10^3,10^6,10^9和10^{12}$位&#x2F;秒。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记_传输层</title>
    <url>/2022/06/06/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h2 id="6-1-传输服务"><a href="#6-1-传输服务" class="headerlink" title="6.1 传输服务"></a>6.1 传输服务</h2><h2 id="6-2-传输协议的要素"><a href="#6-2-传输协议的要素" class="headerlink" title="6.2 传输协议的要素"></a>6.2 传输协议的要素</h2><h2 id="6-3-拥塞控制"><a href="#6-3-拥塞控制" class="headerlink" title="6.3 拥塞控制"></a>6.3 拥塞控制</h2><p>AIMD</p>
<h2 id="6-4-UDP"><a href="#6-4-UDP" class="headerlink" title="6.4 UDP"></a>6.4 UDP</h2><h2 id="6-5-TCP"><a href="#6-5-TCP" class="headerlink" title="6.5 TCP"></a>6.5 TCP</h2><h3 id="1-TCP概述"><a href="#1-TCP概述" class="headerlink" title="1 TCP概述"></a>1 TCP概述</h3><h3 id="2-TCP服务模型"><a href="#2-TCP服务模型" class="headerlink" title="2 TCP服务模型"></a>2 TCP服务模型</h3><h3 id="3-TCP协议"><a href="#3-TCP协议" class="headerlink" title="3 TCP协议"></a>3 TCP协议</h3><h3 id="4-TCP段的头"><a href="#4-TCP段的头" class="headerlink" title="4 TCP段的头"></a>4 TCP段的头</h3><p><img src="https://api2.mubu.com/v3/document_image/b3a64ccc-3fc0-4b76-9bff-39b0c584a906-16175743.jpg" alt="TCP头"><br>序号seq是计数的字节数，因为TCP是咩有边界的，所以只能以字节计数。<br>ACK号是指的下一个期待的字节，而不是已经正确接收了的字节。并且是累计确认。<br>TCP的数据可以为0，就是说TCP报文段里可以不携带任何信息。<br>MSS(maximum sigment size)</p>
<p>根据改变发送窗口的尺寸</p>
<p>分析IP报文，先看协议类型，06是tcp，</p>
<h3 id="5-TCP连接建立"><a href="#5-TCP连接建立" class="headerlink" title="5 TCP连接建立"></a>5 TCP连接建立</h3><h3 id="6-TCP连接释放"><a href="#6-TCP连接释放" class="headerlink" title="6 TCP连接释放"></a>6 TCP连接释放</h3><h3 id="7-TCP连接管理模型"><a href="#7-TCP连接管理模型" class="headerlink" title="7 TCP连接管理模型"></a>7 TCP连接管理模型</h3><h3 id="8-TCP滑动窗口"><a href="#8-TCP滑动窗口" class="headerlink" title="8 TCP滑动窗口"></a>8 TCP滑动窗口</h3><h3 id="9-TCP计时器管理"><a href="#9-TCP计时器管理" class="headerlink" title="9 TCP计时器管理"></a>9 TCP计时器管理</h3><h3 id="10-TCP拥塞控制"><a href="#10-TCP拥塞控制" class="headerlink" title="10 TCP拥塞控制"></a>10 TCP拥塞控制</h3><h3 id="11-TCP未来"><a href="#11-TCP未来" class="headerlink" title="11 TCP未来"></a>11 TCP未来</h3>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记_物理层1</title>
    <url>/2022/03/10/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0-%E7%89%A9%E7%90%86%E5%B1%821/</url>
    <content><![CDATA[<p>学不会了，单纯进行一个复制粘贴<br>可能应该去信通蹭蹭课了 <font size="7">悲</font></p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li>Channel<strong>信道</strong>：传输信息的媒体</li>
<li>Bit Rate<strong>数据率</strong>：数据传输速率（bps）</li>
<li>Baud<strong>波特</strong>：符号&#x2F;码元传输速率 $1Baud &#x3D;(\log_2{V})bps$，其中V是信号的电平级数(理解为<strong>进制数</strong>，每一个电平级数用一个符号表示，换成二进制位数就是这个公式)，比如电平级数为2时，波特速率等于比特速率。如果在数字传输过程中，0V、2V、4V和6V分别表示00、01、10和11，那么每个码元有四种状态00、01、10和11。每个码元代表两个二进制数字。大部分情况下，波特速率&gt; bit速率。<br><img src="https://api2.mubu.com/v3/document_image/164707928280699fe.jpg" alt="111"></li>
<li>Propagation Speed<strong>传播速度</strong>：通信线路上，信号单位时间内传送的距离(m&#x2F;s)。光速：$3\times10^8m&#x2F;s$。</li>
<li>Bandwidth<strong>带宽</strong>：<mark>在单位时间里，能发送的最大比特数</mark>PPT上写“信号占用的频率范围(HZ)不知道是什么意思。但是HZ本身就是($s^{-1}$)，和bps($\tiny\cfrac{比特数}{传输这些比特所用的时间}$)的单位一样。<br>补充↑：带宽的两种意思<br><img src="https://api2.mubu.com/v3/document_image/58cded3d-2107-41e9-8fd9-f601dcece668-16175743.jpg" alt="补充：带宽的两种意思"></li>
<li>Channel Capacity信道容量：信道的<strong>最大</strong>数据率</li>
<li>Throughput吞吐量：网络容量的度量，表示单位时间内网络可以传送的数据位数(bps)</li>
<li>Bit Error Rate误码率(BER):信道传输可靠性指标，可能会很低，如$10^{-12}$等<br>$P&#x3D;\cfrac{传送错误的位数}{传输总位数}$</li>
<li>Delay时延：<mark>从向网络中发送数据块的第一比特开始，到最后一位数据被接收所经历的时间</mark>。包括发送时间+传播时间+处理时间+排队时间，</li>
<li>时延的组成<ul>
<li>传播时延：信号通过传输介质的时间</li>
<li>发送时延：设备发送一个数据块所需要的时间<br>$发送时延&#x3D;\cfrac{数据块长度}{信道带宽}$，这里的带宽指的是<mark>单位时间内能发送的最大比特数</mark>。注意二者单位的统一。</li>
<li>处理时间：交换机&#x2F;路由器检查数据、选路的时间</li>
<li>排队时延：在交换机&#x2F;路由器中排队等待的时间</li>
</ul>
</li>
<li>几种通信方式：Simplex【单工链路】, Half-duplex【半双工链路】, Full-duplex【全双工】，其中，全双工是最常见的。<ul>
<li>Simplex【单工链路】：只能单向，腾讯课堂这样的</li>
<li>Half-duplex【半双工链路】：双方都可发送可接受，但不能同时发送和接受，对讲机</li>
<li>Full-duplex【全双工】：双车道一样的，可以同时发送和接受</li>
</ul>
</li>
<li>并行通信Parallel$\tiny平行的并行的$ transmission<img src="https://api2.mubu.com/v3/document_image/4e3e79a4-f002-46e0-8a92-1c0805542a31-16175743.jpg"></li>
<li>串行通信Serial transmission(在不同机器之间的通信较为常见)<img src="https://api2.mubu.com/v3/document_image/284a2a06-99a7-47f1-9a85-b9c144192557-16175743.jpg"><ul>
<li>同步Synchronous</li>
<li>异步Asynchronous，始终不需要同步，仅需三条线路（一来一回+地线）便可以完成，（同步需要五条线，一来一回需要两个时钟信号）但收发双方的时钟可能出现偏差，一般应用于短距离通信。</li>
</ul>
</li>
</ul>
<h2 id="2-1数据通信的理论基础"><a href="#2-1数据通信的理论基础" class="headerlink" title="2.1数据通信的理论基础"></a>2.1数据通信的理论基础</h2><h3 id="傅里叶分析"><a href="#傅里叶分析" class="headerlink" title="傅里叶分析"></a>傅里叶分析</h3><p>高数学到狗肚子里去了，根本看不懂(大草)。</p>
<h3 id="带宽有限的信号"><a href="#带宽有限的信号" class="headerlink" title="带宽有限的信号"></a>带宽有限的信号</h3><p>不要求会算，但是要求理解带宽对速率的限制。(我不理解，哭哭)</p>
<ul>
<li><p>没有设备能够不损耗能量地传输信号</p>
</li>
<li><p>所有的传输设施对于不同傅里叶分量的衰减程度并不相同，从而导致接收端收到的结果信号发生也就是说，如果等量的衰减，是不会变形的。</p>
</li>
<li><p><strong>带宽的定义</strong>：课本和ppt是这样说的</p>
<blockquote>
<p>一般情况下对导线而言，在0到某个频率$f_c$的这段范围内，振幅在传输过程中不会衰减(这里$f_c$可以用Hz(赫兹)来度量)，而在此截止频率$f_c$之上的所有频率的振幅都将有不同程度的减弱。这段在传输过程中振幅不会明显减弱的频率的宽度就称为带宽(bandwidth)。通常引用的带宽是指从0到使得接收能量保留一半的那个频率位置。ps:滤波器一般可用来进一步限制信号的带宽。</p>
</blockquote>
</li>
<li><p>决定带宽的因素：<strong>带宽是传输介质的一种物理性质</strong>，由以下决定</p>
<ul>
<li>介质的构成</li>
<li>介质的厚度</li>
<li>电线或者光纤(也就是介质 阿巴阿巴)的长度</li>
</ul>
</li>
</ul>
<h3 id="信道的最大数据速率"><a href="#信道的最大数据速率" class="headerlink" title="信道的最大数据速率"></a>信道的最大数据速率</h3><blockquote>
<p>待补充，回头写</p>
</blockquote>
<ol>
<li><p>Nyquist’s theorem (1924)<br>If a signal has been run through a low-pass filter of bandwidth H,  the signal can be completely reconstructed by making 2H samples per second<br>  C&#x3D;2Hlog2V</p>
</li>
<li><p>Shannon’s Theorem (1948)</p>
</li>
</ol>
<blockquote>
<p>$\tiny摘自百度百科$<br>类比：城市道路上的汽车的车速（业务速率）和什么有关系？<br>除了和自己车的动力有关之外，主要还受限于道路的宽度（带宽）和车辆多少、红灯疏密等其他干扰因素（信噪比）。<br>俗话说：“<strong>有线的资源是无限的，而无线的资源却是有限的。</strong>”无线信道并不是可以任意增加传送信息的速率，它受其固有规律的制约，就像城市道路上的车一样不能想开多快就开多快，还受到道路宽度、其他车辆数量等因素影响。这个规律就是香农定理。香农定理是所有通信制式最基本的原理，它描述了有限带宽、有随机热噪声信道的最大传输速率与信道带宽、信号噪声功率比之间的关系。</p>
</blockquote>
<p>香农定理由如下的公式给出: <mark><br>$C&#x3D;W\times\log_2{(1+\frac{S}{N})}$<br></mark>其中C是可得到的链路速度，W是链路的带宽，S是平均信号<strong>功率</strong>,N是平均噪声<strong>功率</strong>，信噪比（S&#x2F;N）通常用分贝（dB）表示，<mark>$分贝数&#x3D;10\times\log_{10}{(\frac{S}{N})}$</mark>,这里的分贝不同于平时认为的声音大小的单位，而在实际上，声音大小的单位也并不是分贝(分贝本身是一个同单位比值),而是用声压大小反映，由于分贝取对数的特性符合日常表达需要，所以用声压对应的分贝来表示声音大小。真正的分贝分为两种，功率之比和幅值之比，香农公式这里采用的是功率之比的定义。详见 <a href="https://zhuanlan.zhihu.com/p/22821588">这里</a> 以及<a href="https://baike.baidu.com/item/%E5%88%86%E8%B4%9D/553473">这里</a>(后者为百度百科)。</p>
<h2 id="2-2引导性传输介质Guided-Transmission-Media"><a href="#2-2引导性传输介质Guided-Transmission-Media" class="headerlink" title="2.2引导性传输介质Guided Transmission Media"></a>2.2引导性传输介质Guided Transmission Media</h2><p>这块儿懒得记，应该是兴趣性了解即可，书上还有点儿笑话看。<br>这儿就记个大纲</p>
<ol>
<li><p>磁介质 Manetic Media<br>“永远不要低估一辆满载着磁带在高速公路上飞驰的旅行车的带宽”<br>高带宽高延迟</p>
</li>
<li><p>双绞线 Twisted Pair<br>  到6类为止，所有的双绞线都成为<strong>非屏蔽双绞线(UTP)</strong>(unsheild twisted pair)<br>  7类双绞线在每对、整个线缆外加一个屏蔽层</p>
</li>
<li><p>同轴电缆 coaxial cable<br>  <font size="2">cable(钢索，电缆)</font><br>  <img src="https://api2.mubu.com/v3/document_image/7fdd5fef-512e-438a-8002-5c152f02f95d-16175743.jpg" alt="1"></p>
</li>
<li><p>电线 Power line</p>
</li>
<li><p>光纤 （Fiber Cables）&amp; 光缆<br>根据中心光纤的直径，分为多模、单模<br>多模以不同的角度来回反射着前进，单模直径只有几光波，几乎沿直线传输</p>
</li>
</ol>
<blockquote>
<p>参考链接<br><a href="https://zhuanlan.zhihu.com/p/350152827#:~:text=%E5%88%86%E8%B4%9D%E4%B8%8E%E4%BF%A1%E5%99%AA%E6%AF%94%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%BA%20%3A%20db%3D10lg%EF%BC%88s%2Fn%EF%BC%89%20%E4%BF%A1%E5%99%AA%E6%AF%94%E6%98%AF%E4%BF%A1%E5%8F%B7%E7%94%B5%E5%8E%8B%E5%AF%B9%E4%BA%8E%20%E5%99%AA%E5%A3%B0%E7%94%B5%E5%8E%8B%20%E7%9A%84%E6%AF%94%E5%80%BC%EF%BC%8C%E9%80%9A%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7%20s%2Fn%20%E6%9D%A5%E8%A1%A8%E7%A4%BA%E3%80%82,%E4%B8%BA45~55db%EF%BC%8C%E8%8B%A5%E4%B8%BA50db%EF%BC%8C%E5%88%99%E5%9B%BE%E5%83%8F%E6%9C%89%E5%B0%91%E9%87%8F%E5%99%AA%E5%A3%B0%EF%BC%8C%E4%BD%86%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E8%89%AF%E5%A5%BD%EF%BC%9B%E8%8B%A5%E4%B8%BA60db%EF%BC%8C%E5%88%99%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E4%BC%98%E8%89%AF%EF%BC%8C%E4%B8%8D%E5%87%BA%E7%8E%B0%E5%99%AA%E5%A3%B0%E3%80%82%20%E7%BD%91%E9%A1%B5%E4%BF%A1%E5%99%AA%E6%AF%94%20%E6%9F%A5%E8%AF%A2%E4%BF%A1%E5%99%AA%E6%AF%94%20%28Signal%2FNoise%29%EF%BC%8C%E5%8E%9F%E6%98%AF%E7%94%B5%20%E5%A3%B0%E5%AD%A6%20%E9%A2%86%E5%9F%9F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%8C%87%E5%A3%B0%20%E9%9F%B3%E6%BA%90%20%E4%BA%A7%E7%94%9F%E6%9C%80%E5%A4%A7%E4%B8%8D%E5%A4%B1%E7%9C%9F%E5%A3%B0%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%BC%BA%E5%BA%A6%E4%B8%8E%E5%90%8C%E6%97%B6%E5%8F%91%E5%87%BA%E5%99%AA%E9%9F%B3%E5%BC%BA%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E7%8E%87%E3%80%82">信噪比</a></p>
</blockquote>
<!---
## 2.4通信卫星

## 2.5数字调制与多路复用

## 2.6公共电话交换网络

## 2.7移动电话系统

## 2.8有线电视

--->
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记-物理层2</title>
    <url>/2022/03/20/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0-%E7%89%A9%E7%90%86%E5%B1%822/</url>
    <content><![CDATA[<h2 id="2-3无线传输"><a href="#2-3无线传输" class="headerlink" title="2.3无线传输"></a>2.3无线传输</h2><p>胡乱写一写，基本都是截图，物理层实在让人不懂。大哭。</p>
<h3 id="电磁频谱-The-Electromagnetic-Spectrum"><a href="#电磁频谱-The-Electromagnetic-Spectrum" class="headerlink" title="电磁频谱 The Electromagnetic Spectrum"></a>电磁频谱 The Electromagnetic Spectrum</h3><ul>
<li>Electromagnetic spectrum and its uses for communication↓</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/8786acbc-2976-43f0-b3f3-f321a9e9f27f-16175743.jpg" alt="111"></p>
<img src="https://api2.mubu.com/v3/document_image/6f159e0b-7dc7-449a-9ccf-c049c2037e08-16175743.jpg" width="400" height="80">

<ul>
<li>Using narrow frequency band大多数信息传输使用窄带通信</li>
<li>Spread Spectrum (bluetooth, wlan, cdma)<br>  FHSS: 跳频扩频Frequency hopping spread spectrum<br>Hedy Lamarr (1913-2000)<br>  DSSS: 直接序列扩频Direct sequence spread spectrum<br>  UWB 超宽带通信(Ultra-WideBand) communication.<br>  UWB sends a series of rapid pulses, varying their positions to communicate information.</li>
<li>除非特别声明，我们假设所有的传输都使用窄带频段</li>
</ul>
<h3 id="无线电传输"><a href="#无线电传输" class="headerlink" title="无线电传输"></a>无线电传输</h3><ul>
<li>无线电传输是像个气球一样沿着各个方向传播的，所以不用刻意对齐(下面那个微波传输就得对齐)</li>
<li>无线电频率RF（Radio Frequency）</li>
<li>路径损耗 不同于引导性介质上的信号衰减是以y&#x3D;b-kx的大致形式衰减，无线电波随着距离增加，信号能量<strong>衰减的速度</strong>以距离的-2次幂下降(相当于下降的斜率在不断减小)，这意味着无线电信号可以传播很长的距离。</li>
</ul>
<h3 id="微波传输"><a href="#微波传输" class="headerlink" title="微波传输"></a>微波传输</h3><p>在超过100MHZ的频段，电磁波沿着直线传播，微波在$10^8$~$10^{10}$之间，所以也沿着直线传播</p>
<p><font size="10" color="green">其余跳过</font></p>
<h2 id="2-5数字调制与多路复用"><a href="#2-5数字调制与多路复用" class="headerlink" title="2.5数字调制与多路复用"></a>2.5数字调制与多路复用</h2><ul>
<li>定义：比特与代表它们的信号之间的转换过程称为数字调制( digital modulation)。</li>
<li>信道通常被多个信号共享。毕竟，用单根线缆传送几个信号比为每个信号铺设一-根线缆要便利得多。这种信道的共享形式称为<strong>多路复用技术( multiplexing)</strong></li>
</ul>
<h3 id="基带传输"><a href="#基带传输" class="headerlink" title="基带传输"></a>基带传输</h3><p><strong>baseband transmission</strong>：如何把数据比特<strong>直接</strong>转换成信号的一些方案。信号的传输占有传输介质上从零到最大值之间的<strong>全部频率</strong>，而最大频率则取决于信令signaling速率。是<strong>有线介质</strong>普遍使用的一种调制方法。</p>
<p><img src="https://api2.mubu.com/v3/document_image/bddb772e-158f-4cb6-bea6-8b23247de897-16175743.jpg" alt="2"></p>
<h3 id="通带传输"><a href="#通带传输" class="headerlink" title="通带传输"></a>通带传输</h3><p><strong>passband transmission</strong>：通过调节载波信号的<strong>幅值、相位或频率</strong>来运载比特的方案。信号占据了以载波信号频率为中心的一段频带。是<strong>无线和光纤信道</strong>最常使用的调制方法。<strong>只能</strong>在<strong>给定的频带</strong>中传输信号。<br><img src="https://api2.mubu.com/v3/document_image/da181503-0649-4509-8685-ccb573dbc8e9-16175743.jpg" alt="5"><br>(a):<!---QPSK Quadrature phase shift keying 正交相移键控---><br>(b):<!---QAM-16 Quadrature Ampllitude Modulation 正交调幅---><br>(c):<!---QAM-64---><br>答案用注释藏起来了，忘记了的话请F12或者看物理层ppt（皮）。</p>
<h3 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h3><p><strong>Frequency Division Multiplexing</strong><br><img src="https://api2.mubu.com/v3/document_image/3330e8fa-d7c5-4714-981e-a11d2c733e0d-16175743.jpg" alt="6"><br>(a) The original bandwidths.<br>(b) The bandwidths raised in frequency.<br>(b) The multiplexed channel.</p>
<h3 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h3><p><strong>Time Division Multiplexing</strong><br><img src="https://api2.mubu.com/v3/document_image/25bd7832-63ea-4af4-bd0b-d3840f628701-16175743.jpg" alt="7"></p>
<h3 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h3><p><strong>CDMA – Code Division Multiple Access</strong><br><img src="https://api2.mubu.com/v3/document_image/872dce89-17c9-4d4a-86b7-917e4d74bf72-16175743.jpg" alt="8"></p>
<h2 id="2-6公共电话交换网络"><a href="#2-6公共电话交换网络" class="headerlink" title="2.6公共电话交换网络"></a>2.6公共电话交换网络</h2><h3 id="本地回路：调制解调器、ADSL和Fiber"><a href="#本地回路：调制解调器、ADSL和Fiber" class="headerlink" title="本地回路：调制解调器、ADSL和Fiber"></a>本地回路：调制解调器、ADSL和Fiber</h3><ul>
<li><p>调制解调器<br>modem&#x3D;modulator调制器+demodulator解调器<br>  <img src="https://api2.mubu.com/v3/document_image/83e23a78-739d-43e5-b983-5d3124d35d73-16175743.jpg" alt="3"><br>  <img src="https://api2.mubu.com/v3/document_image/a57925f1-a68b-4ffc-be9d-670cef75ec7c-16175743.jpg" alt="4"></p>
</li>
<li><p>ADSL<br>OFDM编码方式可以用于这些信道上发送数据，在ASDL文档中经常被称为DMT（Discrete MultiTone 离散多音），<br><img src="https://api2.mubu.com/v3/document_image/d9af3f5c-ec1c-42ed-bd97-bce7a5faecea-16175743.jpg" alt="ADSL"><br><img src="https://api2.mubu.com/v3/document_image/d1dd9c3e-bb15-4b57-a9db-b9e2c51fa569-16175743.jpg" alt="ADSL"></p>
</li>
<li><p>一种典型的ADSL设备配置<br><img src="https://api2.mubu.com/v3/_document_image_/2f6e0473-4016-4f14-b3b1-fc226a81ae3f-16175743.jpg" alt="2"></p>
</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/06a0d98b-2b88-4ffa-b206-fb0bf7da2f77-16175743.jpg" alt="3"></p>
<ul>
<li>FttH:fiber to the home 光纤入户<br><img src="https://api2.mubu.com/v3/document_image/41c22d14-89c8-4ce0-a45a-64ca90f8b07e-16175743.jpg" alt="5"></li>
</ul>
<h3 id="中继和多路复用"><a href="#中继和多路复用" class="headerlink" title="中继和多路复用"></a>中继和多路复用</h3><p>trunk and Multiplexing</p>
<ul>
<li><p>PCM：脉冲编码调制，关于为什么是64bps、125Чsec<br><img src="https://api2.mubu.com/v3/document_image/ebff4d33-7a87-47a8-ae47-d69a7769b288-16175743.jpg" alt="10"></p>
</li>
<li><p>TDM时分多路复用<br><img src="https://api2.mubu.com/v3/document_image/b05b3ba8-0d7f-4a62-8e29-adbbc7c44f1a-16175743.jpg" alt="4"><br>The T1 carrier (1.544 Mbps).<br>E1 2.048<strong>Mbps</strong></p>
</li>
<li><p><strong>TDM数据传输</strong><br><img src="https://api2.mubu.com/v3/document_image/9fc8a918-402c-449e-84cc-0f2a53540d7b-16175743.jpg" alt="2-8TDM数据传输"></p>
</li>
</ul>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>电路交换和包交换的比较<br><img src="https://api2.mubu.com/v3/document_image/6b76cb90-5dc3-4e61-9c76-f241e1418af4-16175743.jpg" alt="比较"><br><img src="https://api2.mubu.com/v3/document_image/ecc4e8fa-fd80-4174-b0e1-e4fa87b63b30-16175743.jpg" alt="比较"></p>
<p><img src="https://api2.mubu.com/v3/document_image/560e8f18-fd1a-430b-a28e-047656cd29eb-16175743.jpg" alt="课本上的图"></p>
<p><img src="https://api2.mubu.com/v3/document_image/74258e7a-36e5-4d57-aa37-097eaccfd52d-16175743.jpg" alt="画图画的包传输"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计网阅读笔记_1 引言</title>
    <url>/2022/03/02/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0_1%E5%BC%95%E8%A8%80/</url>
    <content><![CDATA[<h2 id="术语-szh这个电脑垃圾的自我科普"><a href="#术语-szh这个电脑垃圾的自我科普" class="headerlink" title="术语(szh这个电脑垃圾的自我科普)"></a>术语(szh这个电脑垃圾的自我科普)</h2><ul>
<li><strong>CN</strong> computer networks计算机网络</li>
<li>interconnected 相互连接的：这两台计算机能够交换信息</li>
<li><strong>计算机网络</strong>和<strong>分布式系统</strong>的关键差别：由一组独立计算机组成的分布式系统呈现给用户的是一个关联系统。在用户看来，分布式系统只是一个模型或泛型。通常在操作系统之上有一层软件负责实现这个模型，这个软件就称为中间件(middleware)。最著名的分布式系统是万维网(World Wide Web)。分布式系统是建立在网络之上的软件系统。网络与分布式系统之间的区别在于软件(尤指操作系统)，而非硬件。</li>
<li>VPN(virtual private networks) 虚拟专用网络:目的是试图终结“地理位置的束缚”</li>
<li>Server 服务器：数据存储的性能最强大的计算机</li>
<li>client 客户机：其他人使用的机器</li>
<li>IP telephone IP电话：通过计算机网络打电话，如果采用了Internet技术则称为IP语音(VoIP,voice over IP)。</li>
<li>e-commerce，electronic commerce 电子商务：简单来说就是网购</li>
<li><a href="www.acm.org">ACM</a> <a href="www.computer.org">IEEE</a></li>
<li>peer-to-peer 对等通信：每个人可以与一个或者多个其他人通信，这里的客户端和服务器没有明确的分工。许多对等系统没有任何中央内容数据库，如BitTorrent(没错就是那个BT！)</li>
<li>instant messaging 即时消息：UNIX系统有talk程序，允许两人相互实时的输入消息。多人参与的消息服务有Twitter，这样发送的消息称为tweet。</li>
<li>wiki是一个协作型的网站。最著名的Wikipedia，一部任何人都可以编辑的百科全书</li>
<li>由于to和2在英文中发音相同，电子商务有了一些可爱的小标签，B:business，C：customer，G：government<img src="https://api2.mubu.com/v3/document_image/019df50c-e675-4f48-8bc2-40bb369e9264-16175743.jpg" alt="小标签"></li>
<li>ubiquitous computing 普适计算：生活中的各种用电，燃气，传感器读数等</li>
<li><strong>RFID Radio Frequency IDentification 射频识别</strong>：可能将现实世界变成物联网</li>
<li><strong>hotspot 无线热点</strong></li>
<li>m-commerce，mobile-commerce 移动商务：就是手机支付</li>
<li><strong>NFC(Near Field Communication)近场通信</strong>：让手机可以充当RFID的智能卡和附近的RFID读写器互动完成消费支付</li>
<li>sensor network 传感器网络：由感知物理世界状态的结点组成，这些节点收集它们感知到的信息，并通过无线中继发送。</li>
<li>network neutrality 网络中立：通信不应该区分内容，来源，或内容提供者的论点</li>
<li><strong>PAN Personal Area Network 个域网</strong>：蓝牙，RFID等</li>
<li><strong>LAN local area network 局域网</strong>：私有网络，被广泛用来连接个人计算机和消费类电子设备，使他们能够共享资源(打印机)和交换信息。当局域网被用于公司消费时，被称为企业网络。</li>
<li>互联处理器的分类<img src="https://api2.mubu.com/v3/document_image/ffd1649a-0364-40e4-9a71-3dfc1b206f25-16175743.jpg" alt="互联处理器的分类"></li>
<li>AP(Access Point)接入点、(wireless router)无线路由器、(base station)基站：局域网中的一个与每台计算机进行通信的设备。</li>
<li>[quite interesting]无线局域网的一个标准称为<strong>IEEE 802.11</strong>，俗称<strong>WiFi</strong>(chapter 4 详细介绍)。而IEEE802.3的俗称我以太网(ethernet)。具体模型如图。<img src="https://api2.mubu.com/v3/document_image/5aa08c52-c410-4645-a2bd-bf0188f70298-16175743.jpg" alt="无线和有线LAN"></li>
<li><strong>MAN Metropolitan Area Network 城域网</strong></li>
<li><strong>WAN Wide Area Network 广域网</strong>：一般跨越比较大的地理区域。我们把专门运行用户程序的计算机称为<strong>主机(host)<strong>，连接这些主机的网络其余部分称为</strong>通信子网(communication subnet)</strong>,或简称<strong>子网(subnet)</strong></li>
<li>多数广域网中，子网由<strong>传输线路(transmission)</strong> 和 <strong>交换元素(switching element)</strong> 组成。</li>
<li>传输线路：负责在机器之间移动比特，可以是铜线光纤无线链路</li>
<li>交换元素：switching element简称<strong>交换机switch</strong>，是专用的计算机，负责链接两条或者两条以上的线路。</li>
<li>Internet：特指每天使用的互联网</li>
<li>Internet：连接在一起的网络</li>
<li>网关&#x3D;&#x3D;路由器</li>
<li>传输技术的分类：按照transmission technology分类：分为 广播式(broadcast)和点到点(point-to-point)链路</li>
<li>点到点传输只有一个发送方和一个接收方，故也称为单播。</li>
<li>而广播网络上：通信信道被网络上的所有机器共享，一般只要特定的一个机器对其响应，无线网络是一个常见例子。特别的，如果地址字段使用一组特殊的编码，所有机器(Broadcasting广播)或者一组机器(multicasting组播)都会对其响应。</li>
<li>互联网络：两个或多个网络的链接，Internet是最著名的互联网络实例。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记_MAC1</title>
    <url>/2022/04/13/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0_MAC1/</url>
    <content><![CDATA[<p>咕咕咕咕咕咕<br>鸽了很久的笔记<br>主要是每天躺着根本不想听课<br>就想着玩儿了</p>
<p>MAC:The Medium Access Control Sublayer 介质访问控制子层</p>
<h2 id="4-1-信道分配问题"><a href="#4-1-信道分配问题" class="headerlink" title="4.1 信道分配问题"></a>4.1 信道分配问题</h2><p>The Channel Allocation Problem</p>
<!---网桥是重点--->
<!---路由是网络层的--->
<!---VLAN虚拟的局域网，是为了安全--->
<h3 id="M-x2F-M-x2F-1-system"><a href="#M-x2F-M-x2F-1-system" class="headerlink" title="M&#x2F;M&#x2F;1 system"></a>M&#x2F;M&#x2F;1 system</h3><p>信道到达信息的概率服从泊松分布<br><img src="https://api2.mubu.com/v3/document_image/db416156-5a59-4ad2-9cd8-e066d232d4a6-16175743.jpg" alt="泊松分布"><br>其中，λ 是 arrival rate (frames&#x2F;sec)<br>标准排队理论的结果是<br>$T&#x3D;\cfrac{1}{\mu C-\lambda}$<br><img src="https://api2.mubu.com/v3/document_image/16501209178869b8a.jpg" alt="标准排队理论"><br>就是说，信道越小，<u>该信道上</u>发送一个帧的平均时延越小。（或许可以考虑一大群黄鳝源源不断的从一段管道中通过？（如果这样想能想明白的话）总之这个T是针对某个信道而言的）</p>
<p>$$信道分配问题\left{<br>\begin{matrix}<br>    静态信道分配Static\<br>    动态信道分配Dynamic<br>\end{matrix}<br>\right.$$</p>
<h3 id="动态信道分配"><a href="#动态信道分配" class="headerlink" title="动态信道分配"></a>动态信道分配</h3><ol>
<li>受控的多路通道<ol>
<li>中心化的：polling，投票，挨个询问</li>
<li>无中心的：token，令牌，谁拿到谁发</li>
</ol>
</li>
<li>随机的多路access<ol>
<li>ALOHA</li>
<li>CSMA, CSMA&#x2F;CD, CSMA&#x2F;CA</li>
</ol>
</li>
</ol>
<h2 id="4-2-多路访问协议"><a href="#4-2-多路访问协议" class="headerlink" title="4.2 多路访问协议"></a>4.2 多路访问协议</h2><h3 id="ALOHA协议（读作allow）"><a href="#ALOHA协议（读作allow）" class="headerlink" title="ALOHA协议（读作allow）"></a>ALOHA协议（读作<del>allow</del>）</h3><h4 id="pure-ALOHA"><a href="#pure-ALOHA" class="headerlink" title="pure ALOHA"></a>pure ALOHA</h4><ol>
<li>数据帧被传输在完全的随机时间，如果有冲突，就等一个随机的时间再发<br><img src="https://api2.mubu.com/v3/document_image/cbafc61d-5bd0-4657-b7dd-0c21070ad96c-16175743.jpg" alt="pure ALOHA"></li>
<li>这里的冲突是指的只要有一个bit的重叠，就被毁掉了，因为是电信号一旦重叠就肯定被毁了。</li>
<li>Collision Demo：<img src="https://api2.mubu.com/v3/document_image/329188b8-47f6-41a0-be49-5333580eb2eb-16175743.jpg" alt="Collision Demo："></li>
<li>Vulnerable period for the shaded frame.就是说在灰色帧发送的t0时刻前后的t时间里，不能有别的帧发送。<img src="https://api2.mubu.com/v3/document_image/b519b5f4-7125-47ec-b943-62f6267d564c-16175743.jpg" alt="11"></li>
<li>假设：帧长固定，帧发送时间也固定</li>
</ol>
<h4 id="Sloted-ALOHA"><a href="#Sloted-ALOHA" class="headerlink" title="Sloted ALOHA"></a>Sloted ALOHA</h4><p>一个重点是S&#x2F;G</p>
<h3 id="CMA-x2F-CD"><a href="#CMA-x2F-CD" class="headerlink" title="CMA&#x2F;CD"></a>CMA&#x2F;CD</h3><p>没写，回头补，咕咕咕</p>
<h2 id="4-4-无线局域网"><a href="#4-4-无线局域网" class="headerlink" title="4.4 无线局域网"></a>4.4 无线局域网</h2><p>Wireless LAN Protocols</p>
<p>需要解决的问题：<br>Hidden station problem<br>Exposed station problem<br>解决方法：</p>
<ul>
<li>PCF (Point Coordination Function)</li>
<li>DCF (Distributed Coordination Function)：<ul>
<li>CSMA&#x2F;CA:CSMA with Collision Avoidance</li>
<li>MACA(Multiple Access with Collision Avoidance)  protocol<br>MACA: Collision Avoidance</li>
</ul>
</li>
<li>A发给B一个RTS（request to send）（30 bytes长，包含将要发送的数据的长度）</li>
<li>B回复一个CTS（clear to send）（contains data length from RTS）</li>
<li>当收到CTS的时候，A开始发送数据</li>
<li>听到RTS的其他站点保持足够长的沉默时间（C,E）</li>
<li>听到CTS的其他站点在即将到来的（upcoming）数据传输中保持沉默。<br><img src="https://api2.mubu.com/v3/document_image/7719c78a-d525-4c61-9d83-1e1033423609-16175743.jpg" alt="传输范围"></li>
</ul>
<h2 id="4-3-以太网Ethernet"><a href="#4-3-以太网Ethernet" class="headerlink" title="4.3 以太网Ethernet"></a>4.3 以太网Ethernet</h2><ol>
<li>以太网cable<br><img src="https://api2.mubu.com/v3/document_image/d4080a82-a43c-40a7-bae6-86dee8e91d33-16175743.jpg" alt="以太网cable"></li>
<li>以太网Topologies(拓扑)</li>
</ol>
<h3 id="Ethernet-MAC-Sublayer-Protocol"><a href="#Ethernet-MAC-Sublayer-Protocol" class="headerlink" title="Ethernet MAC Sublayer Protocol"></a>Ethernet MAC Sublayer Protocol</h3><p>帧的格式（needrem）<br><img src="https://api2.mubu.com/v3/document_image/69a402c2-a4d7-4fad-8f60-83f849e2c4c4-16175743.jpg" alt="frame fromat"></p>
<p>（a）DIX 以太网标准<br>（b）IEEE 802.3标准<br>Preamble:前导&#x2F;序言，同步时钟信号。<br>Type：发送的数据是什么类型的，网上递交交到哪里去<br>Pad：填充字段，保证Data+Pad&gt;&#x3D;46，防止帧长过小<br><a href="https://api2.mubu.com/v3/document_image/16518386874381ff3.jpg">click</a></p>
<ol>
<li>以太网地址，6字节<br>在往上就是IP，然后就是DNS了<br><img src="https://api2.mubu.com/v3/document_image/783326c4-4a41-43e5-819b-3eed68ae5aa0-16175743.jpg" alt="IEEE802"><br>前面3个字节是厂家的标识，后面是厂家给用户分配的地址（网口）<br>这个属于Unicast，其他的还有Multicast，Broadcast（全1）。</li>
<li>帧长<br>最大的帧长是<mark>1514</mark>bytes（<mark>数据是1500bytes</mark>）<br>1514:1500+6+6+2(type)<br>1518:1500+6+6+2+4(CRC)<br>最小帧长是<mark>64bytes</mark>&#x3D;46(pad)+18(跟上面那个一样)<br>也就是 64x8&#x3D;512 bits<br>为什么需要有帧长的下限：<br>Collision Detect Can take as long as 2$\tau$<br><img src="https://api2.mubu.com/v3/document_image/6dca1935-e996-411d-a4aa-3cc560bd73a1-16175743.jpg" alt="为什么需要有帧长的下限"></li>
</ol>
<h3 id="二进制指数退避算法"><a href="#二进制指数退避算法" class="headerlink" title="二进制指数退避算法"></a>二进制指数退避算法</h3><p>Binary Exponential Backoff Algorithm<br>在CMA&#x2F;CD协议中，会等一个随机数，生成这个随机数的时候会需要一个上限<br>随着冲突次数的增加，随机数的上限以2的指数次增加，一直到1024个时间片，就不再增加比如：<br><img src="https://api2.mubu.com/v3/document_image/670fceab-f222-4966-8634-00c372fe590a-16175743.jpg" alt="以2的指数次增加"><br>这个算法是分布式的，即仅考虑自己是第几次冲突</p>
<h3 id="IEEE-802-3-Performance（Ethernet）"><a href="#IEEE-802-3-Performance（Ethernet）" class="headerlink" title="IEEE 802.3 Performance（Ethernet）"></a>IEEE 802.3 Performance（Ethernet）</h3><p>Frame length: F<br>Bandwith: B<br>Cable length: L<br>Speed of signal propagation: c<br>e:就是2.71828那个e<br>channel efficency &#x3D; $\cfrac{1}{1+\cfrac{2BLe}{cF}}$</p>
<p>Efficiency of Ethernet at 10 Mbps with 512-bit slot times<br><img src="https://api2.mubu.com/v3/document_image/3ac99641-5886-4176-93ff-cda58e5c3dcd-16175743.jpg" alt="Efficiency"></p>
<h3 id="Fast-Ethernet-快速以太网"><a href="#Fast-Ethernet-快速以太网" class="headerlink" title="Fast Ethernet 快速以太网"></a>Fast Ethernet 快速以太网</h3><p>所有之前的帧的格式，接口，程序都没有改变<br>减少bit time（100ns-&gt;10ns）<br>减少最大电缆长度为原来的十分之一<br>Cabling:<br><img src="https://api2.mubu.com/v3/document_image/b4c1f47d-ee1a-409f-bdda-379dd76a256d-16175743.jpg" alt="Fast Ethernet cabling"></p>
<p>100Basw-T4:<mark>不用曼彻斯特编码</mark>了<br><img src="https://api2.mubu.com/v3/document_image/7e3c5430-0d8b-4a75-a174-a5cc6bbd862c-16175743.jpg" alt="100Basw-T4"></p>
<h3 id="Gabit-Ethernet"><a href="#Gabit-Ethernet" class="headerlink" title="Gabit Ethernet"></a>Gabit Ethernet</h3><p>千兆的标准仍然向后兼容<br>网络半径变为25米，（速率提高10倍，距离一定缩小）<br>解决方法</p>
<ol>
<li>添加padding，用于填充</li>
<li>让几个短帧拼接在一起</li>
<li>总之就是让帧的尺寸&gt;&#x3D;512bytes<br>最终让网络工作的半径保持在200米<br>Cabling:<br><img src="https://api2.mubu.com/v3/document_image/1c9bce00-30ac-4e23-9335-2565ad825b8b-16175743.jpg" alt="Cabling"><br>Flow Control:(新增功能，因为千兆太快了)</li>
</ol>
<h3 id="10Gabit-Ethernet"><a href="#10Gabit-Ethernet" class="headerlink" title="10Gabit Ethernet"></a>10Gabit Ethernet</h3><p>一般在数据中心内部</p>
<h2 id="4-5-宽带无线"><a href="#4-5-宽带无线" class="headerlink" title="4.5 宽带无线"></a>4.5 宽带无线</h2><h3 id="IEEE802-11-x2F-wifi"><a href="#IEEE802-11-x2F-wifi" class="headerlink" title="IEEE802.11&#x2F;wifi"></a>IEEE802.11&#x2F;wifi</h3><p>All use CSMA&#x2F;CA for multiple access(多路访问采用冲突避免)<br>All have base-station and ad-hoc network versions</p>
<p>尽量避免冲突<br>CSMA：在发送之前sense<br>是一个无线环境，咩办法像在有线的里面一样弄CD（冲突检测），而且也没办法监听到所有的冲突（站隐藏）<br>CSMA&#x2F;CA：用协议来避免冲突叫做CSMA&#x2F;CA,C(ollision)A(voidance)</p>
<p>当一个站点有frame要发送时</p>
<ul>
<li>监听信道直到空闲为止，等一个时间片（DIFS:分布式的帧间隔,一个比较小的时间）</li>
<li>Random backoff：可能要等一个随机的时间（0~15 time slots），这东西是个倒计时，假如是13，就13–。</li>
<li>如果帧发过去了，终点发一个简短的ACK，几乎不等待，认为是立刻发回来</li>
<li>缺少ACK会被推测为显示了一个冲突或者别的错误，把backoff的时间片翻倍，再次尝试。(类似二进制退避算法)<br><img src="https://api2.mubu.com/v3/document_image/46566387-ba5a-4f85-8821-80e5a215ec27-16175743.jpg" alt="CSMA/CA"></li>
</ul>
<p>Chanel sensing:</p>
<ul>
<li>物理监听：check媒介，看有没有信号</li>
<li>虚拟监听：每个站点维护一个逻辑的记录，记录什么时候信道被占用，通过追踪<strong>NAV（network allocation vector）</strong>；每个帧都carries一个NAV，一个数据帧的NAV包含发送一个ack所需的时间</li>
</ul>
<p>RTS:request to send<br>CTS:clear to send<br><img src="https://api2.mubu.com/v3/document_image/23ddd9f5-7de1-4626-8822-b8b2fb2f359c-16175743.jpg" alt="NAV"></p>
<p>802.11 reliability</p>
<ul>
<li>降低传输速度（rate）</li>
<li>fragment burst：碎片突发，将一个大的帧切成小的碎片，帧的尺寸没变。这就好比有一定的误码率，一个很大的帧怎么发都发不出去。</li>
</ul>
<p>802.11 省电<br>就是不定期的让客户端睡觉。然后AP在client睡着的时候，缓存发送的信息</p>
<ul>
<li>Beason frames信标帧<ul>
<li>客户端可以进入省电模式</li>
<li>AP会buffer发送的帧</li>
<li>睡醒之后发送一个poll的信息给AP（就时不时睡醒一下）</li>
</ul>
</li>
<li>APSD（automatic power save delivery）<br>当客户端发数据给AP的时候，AP把buffer的数据发给客户端。</li>
</ul>
<p>802.11 QOS：interframe Spacing(IFS,帧间隔)</p>
<blockquote>
<p>QOS:quality of sevice</p>
</blockquote>
<ul>
<li>DIFS:regular data frames</li>
<li>SIFS:<ul>
<li>ACK</li>
<li>其他的控制帧，比如RTS,CTS</li>
<li>a burst of fragment（碎片突发）</li>
</ul>
</li>
<li>AIFS1:适用于PDF方式，就是语音或者其他优先级较高的传输</li>
<li>AIFS4：后台通信，不太重要</li>
<li>EIFS：异常时间<br><img src="https://api2.mubu.com/v3/document_image/064c30a1-ab7c-4ad0-b669-841bb55fdae1-16175743.jpg" alt="interframe Spacing"></li>
</ul>
<p>QOS：TXOP 传输机会<br>TX:transmit OP:opportunity<br><img src="https://api2.mubu.com/v3/document_image/162edab3-5d51-4133-ab69-abfc80ca1eb9-16175743.jpg" alt="QOS：TXOP"><br>无线局域网中，一个站点发送完了之后其他的站点会抢信道，然后抢到的就接着发。<br>在这个例子中，发送同样长的一个帧，6Mbps的站点花费的时间是54Mbps的站点发送时间的9倍，也就是说，在单位1的时间里，有0.9的时间是6Mbps的站点在发送，0.1的时间是54Mbps的站点在发送，这段时间针对每个站点的平均速率都为5.4Mbps。对于6Mbps的站点：发0.9的时间，等0.1的时间，相当于只发了6x0.9&#x3D;5.4,对于54Mbps的站点，发0.1的时间，等0.9的时间，也相当于只发了54x0.1&#x3D;5.4。<br>用了TXOP之后，两个站点占用的时间一样，都是一半，这样带宽也就降为原来的一半。<br>这样比较公平。</p>
<blockquote>
<p>关于计算多个站点的平均速率：<br> 有公式<br> $\cfrac{1}{\cfrac{n_1}{B_1}+\cfrac{n_2}{B_2}+\cfrac{n_3}{B_3}+…}$<br> 其中，Bi是速率，ni是具有Bi速率的站点的个数。这样算出来的所有站点的速率是一样的。<br> 如果能整除就不要添了，不能整除保留两位。</p>
</blockquote>
<p>802.11的帧格式</p>
<p><img src="https://api2.mubu.com/v3/document_image/b0a79323-b67a-4b67-8176-3e81822aacd4-16175743.jpg" alt="format"></p>
<p>地址1：目的，host或者AP的地址，也就是接受的站点的地址<br>地址2：源，发送站点的地址<br>地址3：router的地址，这个router是AP链接的那个路由器<br><img src="https://api2.mubu.com/v3/document_image/f2d22197-dd21-4b51-9abd-be84897e4c93-16175743.jpg" alt="为啥还得有地址3捏"><br>就是说，AP在发送的时候，不知道router的地址，所以把地址3读出来，作为这个小过程的目的地址，而原本的AP的地址是源地址。在这个小过程中，就相当于是802.3协议了。</p>
<p>802.2：LLC，逻辑电路控制子层<br>是在802.3或者其他802协议上面跑的，就是在MAC上面，使得向网络层提供的服务是单一的，统一的服务。但是大部分设备都是没这一层玩意的。DIX是不需要的，但是802.3一般是要加上这个的。<br>提供3个服务选择<br>（懒得自己写了，抄一个：）</p>
<ul>
<li>Unreliable datagram service 不可考的数据报<br>   (best-efforts datagram service)</li>
<li>Acknowledged datagram service 可靠的数据报<br>   (Error-controlled)</li>
<li>Reliable connection-oriented service 面向链接的<br>   (Error-controlled &amp;  flow-controlled)</li>
</ul>
<blockquote>
<p>LLC头里面有个header，来控制交给上面一层的哪一个模块儿</p>
</blockquote>
<h2 id="4-8-数据链路层交换"><a href="#4-8-数据链路层交换" class="headerlink" title="4.8 数据链路层交换"></a>4.8 数据链路层交换</h2><p>DLLS：Data Link Layer Switching</p>
<h3 id="不同802协议之间的桥接"><a href="#不同802协议之间的桥接" class="headerlink" title="不同802协议之间的桥接"></a>不同802协议之间的桥接</h3><h3 id="本地互联Local-Internetworking"><a href="#本地互联Local-Internetworking" class="headerlink" title="本地互联Local Internetworking"></a>本地互联Local Internetworking</h3><p><img src="https://api2.mubu.com/v3/document_image/610f9006-61fb-4320-8614-5283f9f2dbaa-16175743.jpg"><br>左边那个是通过一个桥接设备连接起两个网络<br>右边那个相当于二层交换机<br><img src="https://api2.mubu.com/v3/document_image/48fe4bcd-5734-496e-8e9b-cf667fe5019d-16175743.jpg" alt="Protocol processing"><br>如果左右两侧的协议不同，那么需要生成一个新的帧头，网桥是工作在数据链路层的。</p>
<p>Bridges from 802.x to 802.y</p>
<p>可能遇到的一些问题</p>
<p>帧格式不一样<br><img src="https://api2.mubu.com/v3/document_image/b21a25c8-afe1-4895-918b-364bd0fd1ac4-16175743.jpg" alt="帧格式不一样"><br>数据速率不同（缓存）<br>最大帧长度不一样<br>安全问题：无限局域网支持加密，以太网不支持<br>QOS问题：802.11支持，以太网不支持</p>
<h3 id="Learning-Bridge-自学习网桥"><a href="#Learning-Bridge-自学习网桥" class="headerlink" title="Learning Bridge 自学习网桥"></a>Learning Bridge 自学习网桥</h3><p>又名Transparent，咩有CPU，便宜。</p>
<blockquote>
<p>bridge和Switch的差别：switch的端口只有以太网，但是bridge上面可能有不同的端口（不同的局域网之间桥接）,其他的工作原理一毛一样。</p>
</blockquote>
<ul>
<li>工作在混杂的mode下<br>不同于仅接受特定地址或者广播的帧，接收所有的帧</li>
<li>站点（转发点）表格<br>自学列出来每个可能的目的地址和应该转发的线路</li>
<li>针对一个正在发过来的帧的路由过程<br>检索站表<br>如果目的LAN和源LAN一样，discard<br>如果目的LAN和源LAN不一样，forward<br>如果目的LAN不知道或者multicast&#x2F;broadcast<br>采用flooding algorithm<blockquote>
<p>所以如果站表是空的，那就把除了输入端口以外的所有端口复制一份。<br>如何判断LAN一样与否？看有咩有网桥在中间做桥接</p>
</blockquote>
</li>
</ul>
<h4 id="Station-Table：Backward-Learning"><a href="#Station-Table：Backward-Learning" class="headerlink" title="Station Table：Backward Learning"></a>Station Table：Backward Learning</h4><p>初始情况是空的<br>因为可以看到所有的帧，然后偷偷看一下某个端口收到的帧是从哪里来的，然后记住想到这里去要从哪个端口走。</p>
<h4 id="Dynamic-topologies-动态拓扑"><a href="#Dynamic-topologies-动态拓扑" class="headerlink" title="Dynamic topologies 动态拓扑"></a>Dynamic topologies 动态拓扑</h4><p>无论最初的hash表有没有建立，都会记录arrival time<br>如果长时间（一般是20min）左右，没有更新，那么就把这东西给删了。</p>
<blockquote>
<p>交换机的站表满了之后，整个网上的数据就处于一个扩散的状态，这也是黑客攻击的一种手段。<br>俩个构造station table 的例子<br><img src="https://api2.mubu.com/v3/document_image/50525ea3-4613-4e02-8d29-4f06d1e3d5fd-16175743.jpg" alt="例子"><br><img src="https://api2.mubu.com/v3/document_image/5cf3f19a-060a-490a-99a3-d56cabbb0888-16175743.jpg" alt="例子"></p>
</blockquote>
<h3 id="spanning-tree-生成树的网桥"><a href="#spanning-tree-生成树的网桥" class="headerlink" title="spanning tree 生成树的网桥"></a>spanning tree 生成树的网桥</h3><p>贵。<br>上面的结构没有环路，生成树网桥是为了解决环路问题的。<br>关于环路的问题：<br>有时候，为了增加可靠性，会多家几条路径<br>这个就导致了拓扑结构中出现环路<br>协议：802.1d: Constructing the Spanning Tree<br>过程：（了解即可）</p>
<ul>
<li>Bridge periodically multicast a message out all of its ports, this message is not forwarded, it includes:<ul>
<li>an ID based on its MAC address</li>
<li>ID of the root it  believe to be</li>
<li>the distance to root</li>
</ul>
</li>
<li>Chose the bridge with the lowest ID to be the root, after enough messages exchanged, all bridges will agree on the root</li>
<li>Remembers the shortest path to root, if there are multiple equivalent paths, the path via bridge with lowest ID is chosen</li>
<li>Turn off ports that are not part of the shortest path</li>
<li>Algorithm continues to run during normal operation to automatically detect topology changes and update the tree</li>
</ul>
<p>Dynamic Topologies</p>
<ul>
<li>BPDU (Bridge Protocol Data Unit)<br>Bridge periodically multicast a message (MAC 01:80:c2:00:00:00) out all of its ports, this message is not forwarded, it includes:<br>an ID based on its MAC address<br>ID of the root it  believe to be<br>the distance to root</li>
<li>Root Bridge of Whole Net<br>Chose the bridge with lowest ID to be the root, after enough messages exchanged, all bridges will agree on the root</li>
<li>Root Port of Every Bridge<br>Remembers the shortest path to root, if there are multiple equivalent paths, the path via bridge with lowest ID is chosen</li>
<li>Algorithm continues to run during normal operation to automatically detect topology changes and update the tree</li>
</ul>
<h3 id="几个设备"><a href="#几个设备" class="headerlink" title="几个设备"></a>几个设备</h3><ol>
<li>物理层：<ol>
<li>repeaters</li>
<li>Hub（纯物理层，长得像switch，将一个设备的输入接口和其他设备的输出接口接起来）</li>
</ol>
</li>
<li>数据链路层<ol>
<li>bridges</li>
<li>Switches（提及一个3层交换机，但不懂）</li>
</ol>
</li>
<li>网络层<ol>
<li>Routers</li>
<li>Gateways（网关）</li>
</ol>
</li>
</ol>
<p><img src="https://api2.mubu.com/v3/document_image/54276143-0987-40c4-857c-ba52f417f484-16175743.jpg" alt="几个设备"><br>(a)不同层对应的设备<br>(b)frames，packet and headers<br><img src="https://api2.mubu.com/v3/document_image/d62cc695-8518-4578-bc8f-85c70fd596db-16175743.jpg" alt="hub，bridge，switch"><br>从左到右：hub，bridge，switch<br>bridge和switch：<br>几个微秒就可以构造出来站表<br>因为速率可能不同，还得有buffer<br>cut-through switch：直通式的交换机（拿到目的地址之后直接就开始转发）</p>
<h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p>人事部，财务部，研发部的设备通过VLan划分开，不允许互相通信<br><img src="https://api2.mubu.com/v3/document_image/69387a3e-a977-4a97-8926-da5df6b88d87-16175743.jpg" alt="长这样"><br>为啥整VLAN捏？</p>
<ol>
<li>广播风暴<ol>
<li>当LAN规模比较大的时候，广播帧太多的时候，所有的设备都需要处理</li>
<li>机器们就残废了</li>
</ol>
</li>
<li>安全问题<ol>
<li>一些部门有不想让别的部门知道的信息<br><img src="https://api2.mubu.com/v3/document_image/0082b05a-9203-4354-a146-19dd170df9f1-16175743.jpg" alt="VLAN"><br>(a)是总线链接的，所以A收发的时候BCD也能听到<br>(b)是交换机型，可以做到仅同组听到</li>
</ol>
</li>
</ol>
<p>VLAN ID</p>
<ol>
<li>用端口号（most方便most常见）</li>
<li>用MAC地址</li>
<li>根据第三层的协议</li>
</ol>
<p><img src="https://api2.mubu.com/v3/document_image/6190f69b-1689-45bd-b4e7-51b3d3e31e87-16175743.jpg" alt="802.1Q"><br>VLAN protocol ID (16 bits): 0x8100<br>Pri (3 bits)<br>CFI (1 bit)<br>VLAN Identifier (12 Bits)<br>802.1Q Max frame length: 1522 bytes</p>
<h2 id="WordTable"><a href="#WordTable" class="headerlink" title="WordTable"></a>WordTable</h2><blockquote>
<p>capicity<br> overlap 重叠，重复<br> garble 混淆，模糊<br> idle 空的<br> carrier sense 载波监听<br> arbitrary 随意的，任意的<br> Vulnerable  adj.易受伤的, 脆弱的, 敏感的<br> Throughout 吞吐量&#x3D;利用率*带宽<br> Beason （啥呀这是草）<br> fragment 碎片<br> promiscuous 混杂的<br> crippled 残废的<br> legacy 遗产，遗留之物。legacy end domain 传统域，翻译为传统的<br> exclude vt. 排除；排斥；拒绝接纳；逐出<br> reserved adj. 保留的，预订的；缄默的，冷淡的；包租的</p>
</blockquote>
<!-- 课听到MAC(6)的一小时多了，不想听了，下次补上（ -->
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记-数据链路层1</title>
    <url>/2022/03/30/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0_%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%821/</url>
    <content><![CDATA[<p>开头👴先抄一个gzc的思维导图：<br><img src="https://api2.mubu.com/v3/document_image/f9fae159-374d-41e5-99cf-6bee7b25ccc9-16175743.jpg" alt="思维导图"></p>
<h2 id="3-1数据链路层的设计问题"><a href="#3-1数据链路层的设计问题" class="headerlink" title="3.1数据链路层的设计问题"></a>3.1数据链路层的设计问题</h2><h3 id="3-1-1提供给网络层的服务"><a href="#3-1-1提供给网络层的服务" class="headerlink" title="3.1.1提供给网络层的服务"></a>3.1.1提供给网络层的服务</h3><ol>
<li><p>数据链路层的功能</p>
<ol>
<li>向网络层提供一个定义良好的服务接口。</li>
<li>处理传输错误。</li>
<li>调节数据流,确保慢速的接收方不会被快速的发送方淹没。</li>
</ol>
</li>
<li><p>提供给网络层的服务</p>
<ol>
<li><p>Unacknowledged connectionless service.<br> Most LANs局域网 use unacknowledged connectionless service </p>
</li>
<li><p>Acknowledged connectionless无连接的，也就是不用事先建立通路 service.<br>  This service is useful over unreliable channels, such as wireless  systems。给一个ACK，有确认的服务</p>
</li>
<li><p>Acknowledged connection-oriented service</p>
<pre><code>- Connection establishment
- Timer
- Sequence number 若ACKnumber丢了，防止重复
</code></pre>
</li>
</ol>
</li>
</ol>
<p>当使用面向连接的服务时，数据传输必须经过三个不同的阶段。在第一个阶段,要建立连接，双方初始化各种变量和计数器，这些变量和计数器记录了哪些帧已经接收到，哪些帧还没有收到。在第二个阶段，才真正传输一个或者多个数据帧。在第三个也是最后一个阶段中，连接被释放，所有的变量、缓冲区以及其他用于维护该连接的资源也随之被释放。</p>
<h3 id="3-1-2成帧Framing"><a href="#3-1-2成帧Framing" class="headerlink" title="3.1.2成帧Framing"></a>3.1.2成帧Framing</h3><h4 id="字符计数"><a href="#字符计数" class="headerlink" title="字符计数"></a>字符计数</h4><p><img src="https://api2.mubu.com/v3/document_image/8ed3423d-ef66-42da-aea0-416c2fee6873-16175743.jpg" alt="字符计数"><br>一旦出错：运气不好的话所有的帧都不能正确识别</p>
<h4 id="字符填充法（byte-stuffing）"><a href="#字符填充法（byte-stuffing）" class="headerlink" title="字符填充法（byte stuffing）"></a>字符填充法（byte stuffing）</h4><p><img src="https://api2.mubu.com/v3/document_image/9d9674ff-e6e8-46a2-ae6c-1851829cbd44-16175743.jpg" alt="字符填充法"></p>
<p>帧标志出错了：每两个帧之间至少有一个帧标志，仅影响当前帧。<br>问题：发送的信息含有很多控制字符，需要转译的字符大大增加<br><strong>开销：overhead</strong>，跟需要发送的数据相比，额外添加的转义字符所占的比例，比如全是需要转译的字符的信息，overhead就是100%。</p>
<h4 id="比特填充（bit-stuffing）"><a href="#比特填充（bit-stuffing）" class="headerlink" title="比特填充（bit stuffing）"></a>比特填充（bit stuffing）</h4><p>每个帧的开头结尾都是一个special bit pattern, 01111110 ，也就是16进制的7EH，当数据内容出现连续的1时，每遇到五个1添加一个0（硬件不管这5个1后面是0还是1），接收方做相反的工作。另外在<br><img src="https://api2.mubu.com/v3/document_image/c7e3cce3-443d-4224-b633-bc6f9cefff4b-16175743.jpg" alt="bit stuffing"><br>(a) The original data.<br>(b) The data as they appear on the line.<br>(c) The data as they are stored in receiver’s memory after destuffing.<br>就是每隔五个1插入一个0</p>
<h4 id="物理层编码违例"><a href="#物理层编码违例" class="headerlink" title="物理层编码违例"></a>物理层编码违例</h4><p>Physical layer coding violation （n. 违反, 冒犯, 侵害）<br>对于曼彻斯特Manchester编码，两个跳变表示一个bit，所以当出现长高电平，常低电平，就属于物理层违例了，可以作为帧的边界。</p>
<h3 id="3-1-3差错控制（ERROR-control）"><a href="#3-1-3差错控制（ERROR-control）" class="headerlink" title="3.1.3差错控制（ERROR control）"></a>3.1.3差错控制（ERROR control）</h3><p>可靠的传输：不能少，不能多，顺序不能错</p>
<h3 id="3-1-4流量控制"><a href="#3-1-4流量控制" class="headerlink" title="3.1.4流量控制"></a>3.1.4流量控制</h3><h4 id="两种流量控制"><a href="#两种流量控制" class="headerlink" title="两种流量控制"></a>两种流量控制</h4><ol>
<li>基于反馈信息的流量控制 feedback</li>
<li>基于速率的流量控制（主要是网络层，一种内嵌的机制，浅显的理解是限制速率）rate-based</li>
</ol>
<h4 id="流量控制协议"><a href="#流量控制协议" class="headerlink" title="流量控制协议"></a>流量控制协议</h4><ol>
<li>停等 Stop Aan Wait</li>
<li>滑动窗口 Sliding Window</li>
</ol>
<h2 id="3-2差错检验和纠正"><a href="#3-2差错检验和纠正" class="headerlink" title="3.2差错检验和纠正"></a>3.2差错检验和纠正</h2><ol>
<li><p>错误分类</p>
<ul>
<li>lost frames：一个数据帧完全没能传过去，常常是因为噪音或者掉队</li>
<li>damaged frames：一些bit错了</li>
</ul>
</li>
<li><p>差错检测</p>
<ol>
<li>奇偶校验码(parity):检测单比特错误</li>
<li>Cyclic Redundancy Check:CRC</li>
<li>Atuomatic Repeat reQuest:ARQ</li>
</ol>
</li>
<li><p>差错纠正</p>
<ul>
<li>前向纠错（forward error correction）FEC</li>
</ul>
</li>
</ol>
<h3 id="纠错码"><a href="#纠错码" class="headerlink" title="纠错码"></a>纠错码</h3><hr>
<blockquote>
<p>补充：海明距离Hamming<br>   两个编码异或之后为1的位数<br>   检测到d个errors，需要distance为d+1的编码<br>   纠正d个errors，需要distance为2d+1的编码<br>   这里的距离指的是码表上任意两个编码之间的hamming距离，取最小。对于已知的检错方法，要确定能够检测出几个error应该考虑最坏的情况。</p>
</blockquote>
<h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><p>一个公式：<br>$m+r+1 \le 2^r$<br>m:数据位数<br>r：所需的校验位<br>由该式可以解出需要的最少校验位</p>
<p>海明码的构造：<br><img src="https://api2.mubu.com/v3/document_image/164890187785875d5.jpg" alt="海明码"><br><font size=1>为什么这个人字这么难看啊吐…大概是自己也知道不会再看第二遍了吧…（orz）</font></p>
<p>海明码的作用：<br>可以校验一位差错，并纠正。<br>假如第5位发生了错误，那么第1和4位的校验位会出错，计算1+4可得第5位出错，取反即可纠正。而如果是校验位发生了错误，那么只有那一个校验位错了，就可以知道是校验位出错了。（所有这些都是建立在仅仅发生一个bit的错误上的）<br><img src="https://api2.mubu.com/v3/document_image/1158e3b6-3b70-4032-ae21-3c36c36602e7-16175743.jpg" alt="示例"></p>
<p>如果发生了多位差错呢？<br>correct burst errors：<br>这里👴没懂具体咋搞的，回头机缘巧合懂了再来补文字解释（🕊🕊🕊咕咕咕）<br><img src="https://api2.mubu.com/v3/document_image/c126bef4-a95d-473b-bcbe-27208a333a10-16175743.jpg" alt="correct burst errors："></p>
<p>其他的一些纠错码：<br>卷积码（convolutional code）<br>里德所罗门码（Reed-Solomon code）<br>低密度奇偶校验码（Low-Density Parity Check codes）</p>
<h3 id="检错码"><a href="#检错码" class="headerlink" title="检错码"></a>检错码</h3><p>关于用检错码划算还是用纠错码划算的问题：<br>gzc给了一个Example<br> (<strong>single-bit error</strong>)</p>
<ul>
<li>比特错误率 BER&#x3D;10-6, 1Block&#x3D;1000bits, Data&#x3D;1M bits，也就是说传1M（$10^6$）的数据，每1000bits分一个块块er，然后一共有1000个块块er。</li>
<li>The overhead（开销）<ul>
<li>检错码Error detection + retransmission: 2001 bits （1000+1001）多的那个1是重传的时候的奇偶校验位啦（</li>
<li>纠错码Hamming code : 10,000 bits(1000块*10位校验位)</li>
</ul>
</li>
</ul>
<p>一道👴不理解的题<br>Suppose that data are transmitted in blocks of sizes 1000 bits. What is the maximum error rate under which error detection and retransmission mechanism (1 parity bit per block) is better than using Hamming code? Assume that bit errors are independent of one another and no bit error occurs during retransmission.<br><a href="https://api2.mubu.com/v3/document_image/5bbff850-5b07-4bc4-b927-def84152dbb8-16175743.jpg"></a></p>
<h4 id="奇偶校验码Parity"><a href="#奇偶校验码Parity" class="headerlink" title="奇偶校验码Parity"></a>奇偶校验码Parity</h4><p>略</p>
<h4 id="校验和Checksums"><a href="#校验和Checksums" class="headerlink" title="校验和Checksums"></a>校验和Checksums</h4><p>gzc说从网上抄了段代码给👴们👀👀</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Word <span class="title">Cksum</span><span class="params">(Word *Buf, Word Num_Words)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    Dword Sum;</span><br><span class="line">  	    <span class="keyword">for</span>  ( Sum=<span class="number">0</span>; Num_Words&gt;<span class="number">0</span>;  Num_Words--)</span><br><span class="line">	         Sum+=*Buf++;</span><br><span class="line">	    Sum = ( Sum &gt;&gt; <span class="number">16</span> ) + ( Sum &amp; <span class="number">0xffff</span> ); </span><br><span class="line">	    Sum += Sum &gt;&gt; <span class="number">16</span>;</span><br><span class="line">	    <span class="keyword">return</span> ~Sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="CRC循环冗余校验"><a href="#CRC循环冗余校验" class="headerlink" title="CRC循环冗余校验"></a><mark>CRC循环冗余校验</mark></h4><p><font size=1>这玩意儿是个重点</font><br>名字：Ploynomial code多项式编码，也就是CRC<br>计算CRC：<br>Frame:要传输的数据帧<br>Generator:生成多项式，可以和二进制串一一对应，（一般第一位是1）如$x^4+x+1$对应串10011，<strong>最高幂次r&#x3D;4，对应r+1&#x3D;5位二进制串</strong>，从低位开始写不容易出错。<br>在计算过程中的法则是模2加法，也就是异或运算，在该运算中，加减等价。<br>计算过程：</p>
<ol>
<li>把Frame左移r位，也就是$\times2^r$</li>
<li>用（1）得到是数模二除Generator（注意这个过程所有的加和减也都是异或运算）</li>
<li>除到（1）得到的数的最后一位得到余数，用（1）中数-余数，但是这里也是模二减，相当于异或“+”，且不产生进位er。</li>
<li>如果最终得到的余数不是刚好r位:就直接当数加上去的，详见例2.</li>
<li>然后算完之后就看gcz说的power，👴就发现，加上余数之后恰好整除Generator</li>
</ol>
<p>一个例子1：<br><img src="https://api2.mubu.com/v3/document_image/66a3abff-51ac-47b2-bdf7-145961822f15-16175743.jpg" alt="例子"><br>例子2：<br><img src="https://api2.mubu.com/v3/document_image/08fdf2e9-eb53-46b8-8baf-2fd57268ceb0-16175743.jpg" alt="例子2"></p>
<p>the power of CRC</p>
<ul>
<li>若不出现差错：收到T(X)</li>
<li>若出现了一些差错：收到E(X)，由于模二加法，0-&gt;1和1-&gt;0都可以用“+”表示</li>
<li>计算[T(X)+E(X)]&#x2F;G(X) &#x3D; E(X)&#x2F;G(X)，所以在E(X)&#x2F;G(X)&#x3D;&#x3D;0的时候，差错不能被检查出来</li>
<li>由此推论：<ol>
<li>添加了r bit的冗余信息的码，一定能检测出$\le r$bit的差错，因为rbit冗余信息意味着最高幂次为r，也就是说G(X)有r+1位。</li>
<li>若让（x+1）是G(X)的一个因子（factor），则所有的奇数位都可以检测出来，<font size=1>这玩意儿可以证，但根据速通理论的高质高效原则，👴忍住了，没去看怎么证。</font></li>
<li>若触发差错的bits长度为（r+1），则检测不出来的概率为$\cfrac{1}{2^{r-1}}$，因为出错长度为r+1个bit,则第一个和最后一个一定是错了也就是E(X)的第一位和最后一位都是1，而剩下的中间r-1位不知道是0（没错）还是1（错了）。</li>
<li>而若触发差错的bits长度更长的时候，触发差错的可能就是$\cfrac{1}{2^r}$</li>
</ol>
</li>
</ul>
<p>生成多项式：</p>
<blockquote>
<ul>
<li>CRC-16<br>$x^{16}+x^{15}+x^2+1$</li>
<li>CRC-CCITT  (HDLC)<br>$x^{16}+x^{12}+x^5+1$</li>
<li>CRC-32 (IEEE802)<br>$x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x^{1}+1$</li>
</ul>
</blockquote>
<h2 id="3-3基本-elementary-数据链路层协议"><a href="#3-3基本-elementary-数据链路层协议" class="headerlink" title="3.3基本(elementary)数据链路层协议"></a>3.3基本(elementary)数据链路层协议</h2><p>几种单工协议：<br>An Unrestricted Simplex Protocol <strong>乌托邦</strong>，Unrestricted没有限制的<br>A Simplex Stop-and-Wait Protocol <strong>停等协议</strong><br>A Simplex Protocol for a Noisy Channel <strong>噪音</strong></p>
<h3 id="Protocol-1-乌托邦Utopia"><a href="#Protocol-1-乌托邦Utopia" class="headerlink" title="Protocol 1: 乌托邦Utopia"></a>Protocol 1: 乌托邦Utopia</h3><p>无差错的channel，完美的接收者，源源不断的发送<br><img src="https://api2.mubu.com/v3/document_image/f2466881-7f1b-498d-b4d2-da1a258399da-16175743.jpg" alt="utopia"></p>
<h3 id="Protocol-2-停等协议"><a href="#Protocol-2-停等协议" class="headerlink" title="Protocol 2:停等协议"></a>Protocol 2:停等协议</h3><p><strong>Stop-and-Wait Protocol for a Error-free Channel</strong><br>考虑flow control，仍然是完美的信道<br><img src="https://api2.mubu.com/v3/document_image/631de808-d162-41ae-a8d0-d198cddf5c7a-16175743.jpg" alt="flow control"><br>↑对于短距离的通信完全是没有问题的，效率很高，远距离就不行了</p>
<h3 id="Protocol-3-有噪音的"><a href="#Protocol-3-有噪音的" class="headerlink" title="Protocol 3:有噪音的"></a>Protocol 3:有噪音的</h3><p><strong>A Simplex Protocol for a Noisy Channel</strong><br><img src="https://api2.mubu.com/v3/document_image/b7928813-66a6-4f48-8c86-023db3689df9-16175743.jpg" alt="Noisy"><br>ACK:<strong>ack</strong>nowledgement character命令正确应答<br>NAK：<strong>n</strong>agative a<strong>ck</strong>nowladge否定应答<br>前3种情况都没有问题，但是第4种，ACK丢了，就可能导致重复发送，这就引入了序列号的使用。<br>此外，一个晚到的ACK也可能导致发送重复的数据</p>
<h4 id="Sequence-Number"><a href="#Sequence-Number" class="headerlink" title="Sequence Number"></a>Sequence Number</h4><p>对于数据链路层的<strong>停等协议，一个bit（0&#x2F;1）就足够了</strong>，可以做到判断是新的还是旧的帧<br>对于传输层，1bit就不够了，需要较大的编号空间使得在编号回卷时，保证同编号的旧帧不可能被缓冲在网络中，如：TFTP<br>protocol3：</p>
<ul>
<li>sender 伪代码<br>课本上的代码见<a href="https://api2.mubu.com/v3/document_image/bb4f22d1-ddb4-42de-b363-789775f057f3-16175743.jpg">这里</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">从网络层获取一个分组放入buffer</span><br><span class="line">发送buffer中的数据，新启动定时器</span><br><span class="line">label1:</span><br><span class="line"><span class="built_in">wait_for_event</span>()</span><br><span class="line"><span class="keyword">switch</span> (event) &#123;</span><br><span class="line"><span class="keyword">case</span> 收到了坏帧(校验和错):</span><br><span class="line">     重发缓冲在buffer里的数据，重新启动定时器</span><br><span class="line">     <span class="comment">//这里的&quot;重新&quot;和&quot;新&quot;都是指从头开始启动计时器</span></span><br><span class="line"><span class="keyword">case</span> 定时器超时：</span><br><span class="line">     重发缓冲在buffer里的数据，新启动定时器</span><br><span class="line"><span class="keyword">case</span> 收到校验和正确的帧：</span><br><span class="line">     <span class="keyword">if</span>（ack序号正确） &#123;</span><br><span class="line">        关闭旧定时器</span><br><span class="line">        从网络层获取下一个分组放入buffer</span><br><span class="line">        发送buffer中的数据，新启动定时器</span><br><span class="line">     &#125; <span class="keyword">else</span> </span><br><span class="line">         重发缓冲在buffer里的数据，重新启动定时器</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> label1</span><br></pre></td></tr></table></figure>

<p>简化版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">从网络层获取一个分组放入<span class="function">buffer</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">   发送buffer中的数据，启动定时器</span><br><span class="line">   <span class="built_in">wait_for_event</span>()</span><br><span class="line">   <span class="keyword">if</span> (收到校验和正确的帧) &#123;</span><br><span class="line">      <span class="keyword">if</span>（ack序号正确） &#123;</span><br><span class="line">         关闭旧定时器</span><br><span class="line">         从网络层获取下一个分组放入buffer</span><br><span class="line">         &#125; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>receiver伪代码<br>课本上的代码见<a href="https://api2.mubu.com/v3/document_image/fa67061a-f013-4c8f-9c3f-9fea1dff167d-16175743.jpg">这里</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">frame_expected=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="built_in">wait_for_event</span>()</span><br><span class="line">   <span class="keyword">switch</span>(event) &#123;</span><br><span class="line">   <span class="keyword">case</span> 坏帧：</span><br><span class="line">      do_nothing</span><br><span class="line">   <span class="keyword">case</span> 收到校验和正确的数据帧:</span><br><span class="line">      <span class="keyword">if</span>（序号==frame_expected） &#123;</span><br><span class="line">         向网络层上交分组</span><br><span class="line">         回ACK（序号为frame_expected)</span><br><span class="line">         <span class="built_in">inc</span>(frame_expected)</span><br><span class="line">      &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">         回ACK（序号为frame_expected<span class="number">-1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计时器Timer"><a href="#计时器Timer" class="headerlink" title="计时器Timer"></a>计时器Timer</h4><p>gzc说计时器的间隔是个比较精细的活儿，短了可能收不到，然后每个帧都得发俩遍，间隔长了效率低。实际上设计的比较保守（因为错误实在比较少），但是自己做的实验里面就整个比较合适的值就完了（500ms差不多就完了，这世间卫星都跑到了）。<br><font size=1>👴居然听懂了</font></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记-数据链路层2</title>
    <url>/2022/04/06/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0_%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%822/</url>
    <content><![CDATA[<p>上一个太长了，再分一个</p>
<h2 id="3-4滑动窗口协议"><a href="#3-4滑动窗口协议" class="headerlink" title="3.4滑动窗口协议"></a>3.4滑动窗口协议</h2><p>英文是：<br><strong>Sliding Window</strong></p>
<h3 id="捎带应答Piggy-backing"><a href="#捎带应答Piggy-backing" class="headerlink" title="捎带应答Piggy backing"></a>捎带应答Piggy backing</h3><p><font size=1>查了一下piggy的意思是贪心的，🐷🐷风评被害</font><br>就是说俩边不停的来回发，（全双工），就可以把ACK信息放在sck field里面，跟着另一方的回复发回去。</p>
<h3 id="发送-x2F-接收窗口Sending-window-amp-Receiving-window"><a href="#发送-x2F-接收窗口Sending-window-amp-Receiving-window" class="headerlink" title="发送&#x2F;接收窗口Sending window &amp; Receiving window"></a>发送&#x2F;接收窗口Sending window &amp; Receiving window</h3><p>发送窗口维护一组序号，一个时间对应一组可以发送的序号<br>接收窗口同理，维护的是一组可以接受的信号。接收窗口大于1的时候，落在接收窗口的帧不能马上接受，需要把没按顺序到达的帧先存起来。</p>
<p>几种协议：（由简到繁，由最简单的调整参数就可以依次实现）</p>
<ul>
<li>A <strong>One-Bit</strong> Sliding Window Protocol 实际上就是停等协议</li>
<li>A Protocol Using <strong>Go Back N</strong>  GBN协议</li>
<li>A Protocol Using <strong>Selective Repeat</strong> SR协议</li>
</ul>
<h3 id="单bit的滑动窗口协议"><a href="#单bit的滑动窗口协议" class="headerlink" title="单bit的滑动窗口协议"></a>单bit的滑动窗口协议</h3><p><strong>Protocol 4</strong><br>发送窗口&#x3D;&#x3D;接收窗口<br><img src="https://api2.mubu.com/v3/document_image/88477f43-1e79-488e-8992-db2a956bad4a-16175743.jpg" alt="单bit"><br>A sliding window of size 1, with a 3-bit sequence number.<br>窗口关闭的意思是没有帧在发送<br>(a) 初始状态<br>(b) 第一个帧发送完成<br>(c) 第一个帧已经被接收<br>(d) 第一个ACK被接收</p>
<p>课本上的代码在<a href="https://api2.mubu.com/v3/document_image/9d4c339e-0bfa-4e7d-9f5e-d9b655f187a5-16175743.jpg">这里1</a>以及<a href="https://api2.mubu.com/v3/document_image/b9392d86-a6db-4331-968c-4a485dca220f-16175743.jpg">这里2</a><br><font size=1>gzc说实际工程里的发送方的序号是期望收到的序号，但是课本上不是，whatever，👴不懂</font></p>
<ul>
<li>关于line utilization（线路利用）<br>👴自己的理解大概就是<font color=blue><br>$\frac{发送端在发送消息的时间}{消息到达并收到ACK的时间}$</font><br>其中<br><font size=2 color=blue>消息到达并收到ACK的时间&#x3D;发送消息的时间+传播(propagation)延迟$\times2$</font></li>
<li>单bit滑动窗口协议的问题就在于<u>线路利用率太低了</u></li>
</ul>
<h3 id="Go-Back-N-协议"><a href="#Go-Back-N-协议" class="headerlink" title="Go Back N 协议"></a>Go Back N 协议</h3><p><strong>Protocol 5</strong><br><img src="https://api2.mubu.com/v3/document_image/70054526-d907-4673-b4b6-1088c625507a-16175743.jpg"></p>
<h3 id="SR协议Selective-Repeat-x2F-Reject"><a href="#SR协议Selective-Repeat-x2F-Reject" class="headerlink" title="SR协议Selective Repeat&#x2F;Reject"></a>SR协议Selective Repeat&#x2F;Reject</h3><p><strong>Protocol 6</strong></p>
<h4 id="关于滑动窗口的数量"><a href="#关于滑动窗口的数量" class="headerlink" title="关于滑动窗口的数量"></a>关于滑动窗口的数量</h4><p>Ws：sender window<br>Wr: reciver window<br>他们的数量关系满足以下式子：</p>
<blockquote>
<p>Ws+Wr &lt;&#x3D;2n<br> Ws&gt;&#x3D;Wr<br>可以推出：<br> Ws,Wr&lt;&#x3D; 2n -1</p>
</blockquote>
<p>课本上的代码在<a href="https://api2.mubu.com/v3/document_image/596a271d-196c-44b1-acbc-ca15be42618d-16175743.jpg">这里1</a>,<a href="https://api2.mubu.com/v3/document_image/89628c93-471f-411e-923b-7df2be7b36bc-16175743.jpg">这里2</a>,<a href="https://api2.mubu.com/v3/document_image/7a115cd0-ad06-4e6b-8d04-d797d631eeee-16175743.jpg">这里3</a>以及<a href="https://api2.mubu.com/v3/document_image/d601ad65-c489-47e6-8273-f64e9c9ba542-16175743.jpg">这里4</a></p>
<h4 id="关于line-utilization（gzc的official理解）"><a href="#关于line-utilization（gzc的official理解）" class="headerlink" title="关于line utilization（gzc的official理解）"></a>关于line utilization（gzc的official理解）</h4><p>当sender只有一个窗口时，也就是单bit的滑动窗口时，示意图如下。（分为a，b两种情况，从上往下为时间推进方向）<br><img src="https://api2.mubu.com/v3/document_image/6679fb30-043e-4701-8fef-a1b044dfd208-16175743.jpg" alt="official理解"></p>
<p>$\alpha&#x3D;\cfrac{t_p}{t_f}$ ，  $t_p$即propagation time，传输时延，$t_f$是发送时延。<br>这里的$\alpha$其实就是sender和reciver之间可以放得下几个Frame。</p>
<p>当sender有W个窗口的时候就是这么个状态<br><img src="https://api2.mubu.com/v3/document_image/9b174992-5855-4a4e-b9e7-57f4c0ea5def-16175743.jpg" alt="W个窗口"><br>常见介质中的信号传播速度<br><img src="https://api2.mubu.com/v3/document_image/750a9a07-002d-4976-aa20-024e882846e0-16175743.jpg"></p>
<blockquote>
<p>throughput:吞吐量&#x3D;利用率*带宽</p>
</blockquote>
<h2 id="3-5数据链路层协议实例"><a href="#3-5数据链路层协议实例" class="headerlink" title="3.5数据链路层协议实例"></a>3.5数据链路层协议实例</h2>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>软工笔记</title>
    <url>/2023/02/22/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8Bnotes/</url>
    <content><![CDATA[<p>开个坑，期末复习用。<br>参考 <a href="https://blog.xqmmcqs.com/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">这位</a> 和 <a href="https://bakanetwork.github.io/ComputerArchitecture/#/%E6%9E%81%E9%99%90%E5%A4%8D%E4%B9%A0eXtremeReviewing.md">这位</a> 的笔记，并做了补充。</p>
<h2 id="第一章-软件工程概述"><a href="#第一章-软件工程概述" class="headerlink" title="第一章 软件工程概述"></a>第一章 软件工程概述</h2><blockquote>
<p>软件的定义<br>软件的发展和软件危机<br>软件工程的概念</p>
</blockquote>
<p>程序的定义：程序&#x3D;算法+数据结构。</p>
<p>软件的定义： <mark>软件是包括程序、数据及其相关文档的完整集合。</mark> 程序和数据是构造软件的基础，文档是软件质量的保证，也是保证软件更新及生命周期长短的必需品。</p>
<p><strong>软件危机</strong>：计算机软件在开发和维护过程中遇到一系列严重问题，导致软件行业的信任危机。具体表现在：</p>
<ol>
<li>软件的开发成本难以估算，无法制定合理的开发计划。</li>
<li>用户的需求无法确切表达。</li>
<li>软件质量存在问题。</li>
<li>软件的可维护性差。</li>
<li>缺乏文档资料。</li>
</ol>
<p>产生软件危机的原因：</p>
<ul>
<li>软件系统本身的复杂性。</li>
<li>软件开发的方法和技术不合理不成熟。</li>
</ul>
<p>软件工程定义：运用工程化原则和方法，组织软件开发解决软件危机。</p>
<p>软件工程的<strong>三要素</strong>：<mark>方法、工具、过程</mark>。方法提供了“如何做”的技术、工具提供了自动或半自动的软件支撑环境、过程将方法和工具综合起来以达到合理及时地进行计算机软件开发的目的。</p>
<p>软件工程的<strong>目标</strong>：在<strong>给定成本和时间</strong>的前提下，开发出满足用户需求且具有<mark>正确性、可用性</mark>等因素的软件产品。</p>
<p>软件工程<strong>项目三个基本目标</strong>：合理的进度、有限的经费、一定的质量。（和上条类似）</p>
<p>软件工程的终极目标：摆脱手工生产软件的状况，逐步实现软件研制和维护的自动化。</p>
<p>软件工程知识体系指南<br>SWEBOK（Guide to SoftWare Engineering Body of Knowledge）</p>
<p><img src="https://api2.mubu.com/v3/document_image/338ef7d0-4ea9-4fac-b164-5481d7ad0c84-16175743.jpg" alt="1"></p>
<h2 id="第二章-生命周期模型"><a href="#第二章-生命周期模型" class="headerlink" title="第二章 生命周期模型"></a>第二章 生命周期模型</h2><p>points:</p>
<blockquote>
<p>软件生命周期概念<br>传统软件生命周期模型<br>新型软件生命周期模型</p>
</blockquote>
<p>软件工程项目三个基本目标：合理的进度、有限的经费、一定的质量。</p>
<p>戴明环：<strong>PDCA——Plan，Do，Check，Action</strong>。(美国质量管理专家戴明博士针对工程项目的指令目标提出的)</p>
<p><strong>软件工程过程</strong>是为了获得软件产品，在软件工具的支持下由软件工程师完成的一系列软件工程活动。主要活动有：</p>
<ul>
<li>软件规格说明：规定软件功能及其使用限制。</li>
<li>软件开发：产生满足规格说明的软件。</li>
<li>软件确认：通过有效性验证以保证软件能够满足客户要求。</li>
<li>软件演进：为了满足客户变更要求，软件在使用过程中不断地改进。</li>
</ul>
<h3 id="软件生命周期概念"><a href="#软件生命周期概念" class="headerlink" title="软件生命周期概念"></a>软件生命周期概念</h3><p>软件产品从考虑其概念开始，到该产品不再使用为止的整个时期。包括<strong>概念阶段、分析与设计阶段、构造阶段、移交和运行阶段</strong>等不同时期。</p>
<p>软件生命周期六个基本步骤：PDDDCA<br>(相当于戴明环PDCA的细分)</p>
<ul>
<li><strong>制定计划 P</strong><br><font size =2>确定总目标，给出各方面的要求，可行性研究，预估可用资源，提交审查</font></li>
<li><strong>需求分析 D</strong><br><font size =2>详细进行需求分析，初步编写说明书和用户手册</font></li>
<li><strong>设计 D</strong><br><font size =2>概要设计、详细设计</font></li>
<li><strong>程序编码 D</strong><br><font size =2>就是写代码给过程</font></li>
<li><strong>软件测试 C</strong><br><font size =2>单元测试、组装测试</font></li>
<li><strong>运行维护 A</strong><br><font size =2>改正性维护，适应性维护，完善性维护。<br>软件维护是更加复杂的软件开发活动。</font></li>
</ul>
<p>软件过程模型：从一个特定角度提出的对软件过程的概括描述，是对软件开发过程的抽象，包括构成软件过程的各种<strong>活动(Activity)<strong>、</strong>软件工件(Artifacts)<strong>、</strong>参与角色(Actors&#x2F;Roles)</strong> 等。</p>
<p>软件生命周期模型：一个框架，描述软件需求定义直至软件经过使用后废弃为止，跨越整个生命期的软件开发、运行、维护所实施的全部<strong>过程、活动、任务</strong>。同时描述生命周期不同阶段产生的<strong>软件工件，明确活动的执行角色</strong>等。</p>
<h3 id="传统软件生命周期模型"><a href="#传统软件生命周期模型" class="headerlink" title="传统软件生命周期模型"></a>传统软件生命周期模型</h3><p>传统模型种类：瀑布模型、演化模型、增量模型、喷泉模型、V&amp;W 模型、螺旋模型、构件组装模型、快速应用开发模型、原型方法。</p>
<h4 id="瀑布模型-Water-Fall-Model"><a href="#瀑布模型-Water-Fall-Model" class="headerlink" title="瀑布模型 Water Fall Model"></a>瀑布模型 Water Fall Model</h4><p><strong>是所有其他软件生命周期模型的基础，最经典。</strong><br>1970年提出的，属于是软件危机的关键时期。<br><img src="https://api2.mubu.com/v3/document_image/2eec8cce-b4f6-4bc3-8d69-a2986079fc79-16175743.jpg" alt="waterfall"></p>
<p><img src="https://api2.mubu.com/v3/document_image/7c061528-7e92-42d8-aab8-24ab33ba4df6-16175743.jpg" alt="backroll"></p>
<ul>
<li>特征<ul>
<li>文档驱动，本阶段的工作对象来自于上一阶段活动的输出文档。</li>
<li>每个阶段要产生本阶段的输出——软件文件</li>
<li>每个阶段结束都有评审，方便出现问题立即解决。</li>
</ul>
</li>
<li>优点<ul>
<li>降低开发复杂度、提高透明性可管理性。</li>
<li><mark>推迟了软件实现，强调必须先分析和设计。</mark></li>
<li>对本阶段活动执行情况进行评审，以文档评审等手段指导整个开发过程，保证了错误不会留到下一个周期。</li>
</ul>
</li>
<li>缺点<ul>
<li>缺乏灵活性，无法解决需求不明或不准确的问题。</li>
<li>风险控制能力较弱。</li>
<li>文档过多时，增加工作量。且文档的完成情况并不能完全反映实际项目情况，导致错误结论。</li>
</ul>
</li>
</ul>
<h4 id="演化模型-Evolutional-Model"><a href="#演化模型-Evolutional-Model" class="headerlink" title="演化模型 Evolutional Model"></a>演化模型 Evolutional Model</h4><p><img src="https://api2.mubu.com/v3/document_image/a4e081e5-94ec-4d25-9f46-a7781364fd41-16175743.jpg" alt="yanhua"></p>
<ul>
<li>提倡两次开发（Do Twice）：第一次得到试验性的原型产品，探索可行性，明确需求。第二次在此基础上开发成品。</li>
</ul>
<blockquote>
<p>相对于瀑布模型而言,演化模型的一个明显优点就是可以处理需求不明确的软件项目，对于探索式的演化模型,能够在开发过程中间逐步向用户展示软件半成品,降低系统的开发风险。<br>另外,演化模型将用户的参与始终贯穿在开发过程中,使最终的软件系统能够真实地实现用户需求,又保障系统质量。</p>
</blockquote>
<ul>
<li><p>(1)<strong>探索式</strong>演化模型：其目标是与用户一起工作,共同探索系统需求,直到最后交付系统。</p>
</li>
<li><p>(2)<strong>抛弃式</strong>演化模型：通过实现一个或多个系统原型理解和明确用户需求,然后给出系统一个较好的需求定义。</p>
</li>
<li><p>优点：<br>明确用户需求、提高系统质量、降低开发风险。</p>
</li>
<li><p>缺点：</p>
<ul>
<li>难于管理、结构较差、技术不成熟。</li>
<li>可能会抛弃瀑布模型的文档控制优点。</li>
<li>缺乏设计，可能导致软件系统结构较差。</li>
</ul>
</li>
<li><p>适用范围：需求不清楚、中小型系统、开发周期短。</p>
</li>
</ul>
<h4 id="增量模型-Incremental-Model"><a href="#增量模型-Incremental-Model" class="headerlink" title="增量模型 Incremental Model"></a>增量模型 Incremental Model</h4><ul>
<li>首先对系统最核心或最清晰的需求进行分析、设计、实现、测试。再按优先级逐步对后续的需求进行上述开发工作。<strong>结合了演化和瀑布模型的优点。</strong><br><img src="https://api2.mubu.com/v3/document_image/2d117c6c-eef1-4e14-9f71-01b34cbc348f-16175743.jpg" alt="incremental"></li>
</ul>
<blockquote>
<p>在增量模型中,客户大概或模糊地提出系统须提供的服务或功能,即给出系统的需求框架,以及这些服务或功能的重要作用,从而可以确定系统需求实现的优先级。<br>为了避免多个增量集成时导致不一致的系统体系结构,增量模型在获取系统框架需求后,针对核心需求及系统的性能要求确定系统的体系结构,并以此体系结构指导增量的集成,保证在整个开发过程中体系结构稳定。</p>
</blockquote>
<ul>
<li>优点：<ul>
<li>第一次增量实现系统核心功能，增强客户使用系统的信心。</li>
<li><u>项目总体失败风险较低,因为先开发核心功能</u>，即使某一次增量失败，核心功能还是能用。</li>
<li>最高优先级的功能先开发，得到最多测试，<u>保障可靠性</u>。</li>
<li>增量在同一体系指导下进行集成，提高稳定性和可维护性。</li>
</ul>
</li>
<li>缺点：<ul>
<li>难以选择增量粒度。</li>
<li>难以确定所有需求。</li>
</ul>
</li>
</ul>
<h4 id="喷泉模型（迭代模型）Fountain-Model"><a href="#喷泉模型（迭代模型）Fountain-Model" class="headerlink" title="喷泉模型（迭代模型）Fountain Model"></a>喷泉模型（迭代模型）Fountain Model</h4><p>高情商：各个开发阶段没有特定次序要求，可以并行进行，可以随时补充遗漏的需求（低情商：想到什么做什么，瞎 JB 写）。(比较灵活，用的不多)<br>优点：提高开发效率、缩短开发周期。<br>缺点：难于管理。<br>适用于：需求不明晰。</p>
<h4 id="V-amp-W模型"><a href="#V-amp-W模型" class="headerlink" title="V&amp;W模型"></a>V&amp;W模型</h4><p>V模型在瀑布模型基础上改进，把测试活动提前，使得模型能够驾驭风险。后来Evolutif公司在V模型的基础上提出了W模型。</p>
<p><img src="https://api2.mubu.com/v3/document_image/8e964947-070a-4187-812b-4855c4c8635d-16175743.jpg" alt="v&amp;w"></p>
<p>V模型的左半部分就是在测试阶段之前的瀑布模型，即V模型的开发阶段，右半部分是测试阶段。V模型明确地划分测试的级别,并将其与开发阶段的活动对应。</p>
<p><img src="https://api2.mubu.com/v3/document_image/4b3c2f3d-2380-4a6a-b5f8-e86aeb86556f-16175743.jpg" alt="WW"></p>
<p>W模型强调：测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求和设计同样需要测试，即测试与开发是同步进行的。（相当于测试的时间提前了，并且贯穿整个软件的生命周期）<br>由于W模型扩展测试的内容：增加确认和验证活动，所以它有利于尽早地全面发现问题。</p>
<h4 id="螺旋模型-Spiral-Model"><a href="#螺旋模型-Spiral-Model" class="headerlink" title="螺旋模型 Spiral Model"></a>螺旋模型 Spiral Model</h4><p><img src="https://api2.mubu.com/v3/document_image/dfb95e35-8a21-448c-bf25-e5a778cbf75d-16175743.jpg" alt="luoxuan"></p>
<ul>
<li>针对大型软件开发项目的特点而提出来的。</li>
<li>分为<strong>四个象限</strong>螺旋上升：风险分析、制定计划、实施工程、客户评价——进入下一回路。</li>
<li>适用于：开发周期长、风险高的大型软件。</li>
</ul>
<p>构件组装模型：</p>
<ul>
<li><p>模块化思想，使用复用构件库的组件搭建系统。</p>
</li>
<li><p>优点：</p>
<ul>
<li>软件复用、提高效率。</li>
<li>允许多项目同时开发，降低费用、提高可维护性。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>缺乏通用构建组装标准风险较大。</li>
<li>构建可重用性与系统高效性不易协调。</li>
<li>过分依赖构件，构件质量影响产品质量。</li>
</ul>
</li>
</ul>
<h4 id="构件组装模型"><a href="#构件组装模型" class="headerlink" title="构件组装模型"></a>构件组装模型</h4><p><img src="https://api2.mubu.com/v3/document_image/a1f1766a-7dc6-4553-8e93-702aa973b0d1-16175743.jpg" alt="goujian"></p>
<ul>
<li><p>模块化思想，使用复用构件库的组件搭建系统。</p>
</li>
<li><p>优点：</p>
<ul>
<li>软件复用、提高效率。</li>
<li>允许多项目同时开发，降低费用、提高可维护性。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>缺乏通用构建组装标准，风险较大。</li>
<li>构建可重用性与系统高效性不易协调。</li>
<li>过分依赖构件，构件质量影响最终产品质量。</li>
</ul>
</li>
</ul>
<h4 id="快速应用开发模型（RAD）"><a href="#快速应用开发模型（RAD）" class="headerlink" title="快速应用开发模型（RAD）"></a>快速应用开发模型（RAD）</h4><p>英文是 Rapid Application Development</p>
<p><img src="https://api2.mubu.com/v3/document_image/a3bd5c9f-cc02-4282-b5ba-cb3cd2a64345-16175743.jpg" alt="RAD"></p>
<ul>
<li>开发周期 60-90 天(很短)，分小组同步进行软件各部分开发。</li>
<li>缺点：时间短，需要强沟通配合。不适合所有应用。</li>
<li>适用于：信息管理系统的开发，对于其他系统不太适合。</li>
</ul>
<h4 id="原型方法-Prototyping-Method"><a href="#原型方法-Prototyping-Method" class="headerlink" title="原型方法 Prototyping Method"></a>原型方法 Prototyping Method</h4><p>原型指的是 模拟某种最终产品的原始模型。<br>用户通过使用原型系统提出修改意见。<br>和增量好像也没什么区别<br><strong>主要用于明确需求</strong>，<u>也可以用于软件开发的其他阶段</u>。（划线部分也是它与增量模型和演化模型的区别）</p>
<p>由于运用原型的目的和方式不同,在使用原型时可采取以下两种不同的策略。</p>
<ol>
<li><strong>废弃策略</strong>:先构造一个功能简单而且性能要求不高的原型系统,针对用户使用这个原型系统后的评价和反馈,反复进行分析和改进,形成比较好的设计思想,据此设计出较完整,准确、一致、可靠的最终系统。系统构造完成后,原来的原型系统废弃不用。探索型和实验型原型属于这种策略。</li>
<li><strong>追加策略</strong>:先构造一个功能简单而且性能要求不高的原型系统,作为最终系统的核心,然后通过不断地扩充修改,逐步追加新要求,最后发展成为最终系统。它对应进化型原型。</li>
</ol>
<!-- ![2](https://api2.mubu.com/v3/document_image/16775692935997df0.jpg) -->
<p>原型方法的优点</p>
<ul>
<li><p>原型提供了用户与开发人员良好的沟通手段，易于被人们接受：</p>
<ul>
<li>原型方法有助于快速理解用户对于需求的真实想法 ；</li>
<li>可以容易地确定系统的性能，确认各项主要系统服务的可应用性，确认系统设计的可行性，确认系统作为产品的结果 ；</li>
<li>软件原型的最终版本，有的可以原封不动地成为产品，有的略加修改就可以成为最终系统的一个组成部分，这样有利于建成最终系统。</li>
</ul>
</li>
<li><p>原型法的适用范围和局限性：</p>
<ul>
<li>大型系统如不经过系统分析得到系统的整体划分，而直接用原型来模拟是很困难的。</li>
<li>对于大量运算的、逻辑性较强的程序模块，原型方法很难构造出该模块的原型来供人评价。</li>
<li>对于原有应用的业务流程、信息流程混乱的情况，原型构造与使用有一定的困难。</li>
</ul>
</li>
<li><p>原型方法存在的问题：</p>
<ul>
<li>文档容易被忽略。</li>
<li>建立原型的许多工作会被浪费掉 。</li>
<li>项目难以规划和管理。</li>
</ul>
</li>
</ul>
<h3 id="新型软件生命周期模型"><a href="#新型软件生命周期模型" class="headerlink" title="新型软件生命周期模型"></a>新型软件生命周期模型</h3><p>RUP（Rational Unified Process）</p>
<ul>
<li>软件生命周期分解为 4 各阶段：初始阶段（Inception）、细化阶段（Elaboration）、构造阶段（Construction）和交付阶段（Transition）。每个阶段结束于一个<strong>重要的里程碑</strong>。在阶段结尾评估是否满足阶段目标，评估通过允许项目进入下一阶段。<ul>
<li>初始阶段：软件目标里程碑。</li>
<li>细化阶段：体系结构里程碑。</li>
<li>构造阶段：运行能力里程碑。</li>
<li>移交阶段：产品发布里程碑。</li>
</ul>
</li>
<li>特点<ul>
<li>用例驱动</li>
<li>软件体系结构为核心</li>
<li>应用迭代及增量的新型软件生命周期模型。</li>
</ul>
</li>
</ul>
<p>适应性开发：<br>小步骤，快速反馈和调整</p>
<blockquote>
<p>RUP既是一种软件生命周期模型，又是一种支持面向对象软件开发的工具，它将软件开发过程要素和软件工件要素整合在统一的框架中 。</p>
</blockquote>
<p>敏捷及极限编程</p>
<blockquote>
<p>敏捷建模（Agile Modeling，AM）是由Scott W. Ambler从许多的软件开发过程实践中归纳总结出来的一些敏捷建模价值观、原则和实践等组成的，它是快速软件开发的一种<strong>思想代表</strong>，具体的应用有极限编程、SCRUM、水晶、净室开发等。<br><img src="https://api2.mubu.com/v3/document_image/c0000416-1155-417d-97bf-13f610dc1132-16175743.jpg" alt="AM"></p>
</blockquote>
<ul>
<li>XP 极限编程(eXtreme Programming)：基于敏捷建模思想，也是瀑布模型演化而来。</li>
<li>XP 强调用户满意，开发人员可以对需求的变化作出快速的反应。</li>
</ul>
<h2 id="第三章-软件需求分析"><a href="#第三章-软件需求分析" class="headerlink" title="第三章 软件需求分析"></a>第三章 软件需求分析</h2><blockquote>
<p>需求分析的对象、任务、目标<br>数据、功能、行为建模<br>需求类别</p>
</blockquote>
<h3 id="需求分析的对象、任务、目标"><a href="#需求分析的对象、任务、目标" class="headerlink" title="需求分析的对象、任务、目标"></a>需求分析的对象、任务、目标</h3><p>需求分析的<strong>必要性</strong></p>
<p>需求分析是一项必须的软件工程活动。它在系统需求分析和软件设计之间起到<strong>桥梁</strong>的作用：</p>
<ul>
<li>它使得软件开发人员在系统分析的基础上深入描述软件的功能和性能、指明软件和其他系统元素的接口，建立软件必须满足的约束条件。</li>
<li>它允许软件开发人员对<strong>关键问题</strong>进行<strong>细化</strong>，并<strong>构建</strong>相应的<strong>分析模型</strong>：数据、功能和行为模型。</li>
<li>分析模型成为设计模型的基础，需求规格说明书也为软件测试人员和用户提供了软件质量评估的依据。</li>
<li>它能准确表达用户对系统的各项要求。</li>
</ul>
<p>分析模型</p>
<ul>
<li>数据模型</li>
<li>功能模型</li>
<li>行为模型</li>
</ul>
<p>需求分析的对象：<strong>用户要求。</strong></p>
<p><mark>需求分析的<strong>任务</strong></mark></p>
<ol>
<li>准确地定义新系统的目标</li>
<li>回答系统“做什么”的问题</li>
<li>并<mark><strong>编写需求规格说明书</strong></mark>（结果）</li>
</ol>
<p><mark>需求分析的<strong>目标</strong></mark>：借助于当前 <strong>（业务）系统的逻辑模型</strong> 导出<strong>目标系统的逻辑模型</strong> ，解决目标系统的“做什么”的问题。</p>
<p><img src="https://api2.mubu.com/v3/document_image/de9860e5-fa95-43c3-8587-11b5d8b8d370-16175743.jpg" alt="2"></p>
<p>需求分析的操作性原则：</p>
<ul>
<li>表示和理解问题的<strong>信息域</strong>（数据）。</li>
<li>定义软件<strong>功能</strong>。</li>
<li>表示软件<strong>行为</strong>。（作为外部事件的结果，或者理解为功能存在的理由）</li>
</ul>
<p>需求分析的⼯程化原则:</p>
<ol>
<li>首先要正确地理解问题，再建⽴分析模型。</li>
<li>记录每个需求的起源及原因，保证需求的可回溯性。</li>
<li>开发⼀个⼈机交互过程的原型。</li>
<li>给需求赋予优先级：紧张的开发时间要求尽量避免⼀次性实现每个软件需求，应采⽤迭代增量的开发模型。</li>
<li>努力删除歧义性：因为⼤多数需求以⾃然语⾔描述，存在歧义性的可能性，正式的技术评审是发现并删除歧义性的⼀种有效⽅法。</li>
</ol>
<p><font color=iceblue>需求规格说明书</font>的内容：需求分析模型。（描述系统需要做什么，而非如何做系统）</p>
<ul>
<li>给出当前系统及目标系统的逻辑视图，以及当前系统的物理视图。</li>
<li>逻辑模型给出软件<strong>要达到的功能和处理数据之间的关系</strong> ，而非实现细节。</li>
<li>物理模型给出<strong>业务环境中的业务实体和业务处理流程</strong> ，是<strong>抽象出当前系统逻辑模型的基础</strong>。(领域模型，类图)</li>
</ul>
<p>常用的建模分析方法有：SA（面向数据流的结构化分析方法）、JSD（面向数据结构的 Jackson 方法）、OOA（面向对象的分析方法）等。</p>
<h3 id="数据、功能、行为建模"><a href="#数据、功能、行为建模" class="headerlink" title="数据、功能、行为建模"></a>数据、功能、行为建模</h3><ul>
<li>数据模型<ul>
<li>信息和内容关系、信息流、信息结构。（类图，ER图）</li>
</ul>
</li>
<li>功能模型<ul>
<li>对进入软件的信息和数据进行变换的模块，必须至少完成“<strong>输入、处理、输出</strong>”三个功能。（用例图）</li>
</ul>
</li>
<li>行为模型<ul>
<li>大多数软件对来自外界的事件做出反应。行为模型创建了软件状态的表示，以及导致软件状态变化的事件的表示（状态机）。（活动图，状态转移图，petri图）</li>
</ul>
</li>
</ul>
<h3 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h3><hr>
<ul>
<li>需求开发<ul>
<li>需求获取</li>
<li>需求分析</li>
<li>需求定义</li>
</ul>
</li>
<li>需求管理<ul>
<li>需求确认</li>
<li>需求跟踪</li>
<li>需求变更控制</li>
</ul>
</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>需求获取</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>目的</td>
<td>清楚地理解所要解决的问题，完整地获取用户的需求，并提出这些需求实现条件，以及需求应达到的标准。</td>
</tr>
<tr>
<td>对象</td>
<td>1. 用户：使用软件的人员<br>2. 客户：购买软件的人员</td>
</tr>
<tr>
<td>难点</td>
<td>1. 用户无法清楚地表达需求<br>2. 需求的理解问题<br>3. 用户经常变更需求</td>
</tr>
</tbody></table>
<p>需求获取的流程<br><img src="https://api2.mubu.com/v3/document_image/85dbf0fd-d9f7-4ff7-9682-087e7a4e1483-16175743.jpg" alt="2"></p>
<blockquote>
<p>用户需求说明书与<font color=iceblue>软件需求规格说明书</font>的区别：<br>前者主要采用自然语言来表达用户需求，后者采用规范的建模语言表示。<br><strong>后者是前者的细化，更多地采用计算机语言和图形符号来刻画需求。</strong><br><mark>软件需求规格说明书是软件系统设计的直接依据。</mark><br><strong>两者之间可能并不存在⼀⼀影射关系</strong> ：因为软件开发商会根据产品发展战略、企业当前状况适当地调整软件需求，例如⽤户需求可能被分配到软件的数个版本中；也存在由于技术条件的限制，删减⼀些⽆法实现的、成本太⾼的需求；也存在提供更先进的技术来丰富软件需求；最后，软件开发⼈员应当依据《软件需求规格说明书》来开发当前产品。</p>
</blockquote>
<p>需求类别</p>
<p><strong>功能需求</strong>：列举出所开发软甲你在功能上应做什么（最主要需求）。</p>
<p><strong>性能需求</strong>：给出所开发软件的技术性能指标。系统的实时性和其他时间要求（响应时间、处理时间、消息传送时间等）、资源配置要求、精确度、数据处理量等其他要求。</p>
<p><strong>环境需求</strong>：软件系统运行时所处环境的要求。① 硬件方面，采用什么机型、有什么外部设备、数据通信接口等。② 软件方面，采用什么支操作系统、数据库管理系统等。③ 使用方面，需要使用部门在制度上、人员技术水平上具备什么样的条件等。</p>
<p>其他需求类别：</p>
<ul>
<li>可靠性需求：软件的有效性和数据完整性。</li>
<li>安全保密需求。</li>
<li>用户界面需求。</li>
<li>资源使用需求：指所开发软件运行时所需的数据、软件、内存空间等各项资源。以及软件开发时的人力物力需求。</li>
<li>软件成本消耗与开发进度需求：软件项目立项之后，根据合同规定，对软件开发的进度和步骤费用提出要求，作为开发管理依据。</li>
<li>预估将来系统可能达到的目标：在开发过程中对系统将来可能的扩充与修改做准备。</li>
</ul>
<p>需求的分析与综合</p>
<p>需求获取之后就需要对比较复杂的需求进行建模分析，进而逐步细化所有的软件功能，找出系统各元素之间的联系、接口特性和设计上的限制，分析它们是否满⾜功能要求，是否合理。</p>
<p>需求定义</p>
<p><img src="https://api2.mubu.com/v3/document_image/0e38f3ae-3c49-4c1e-9241-8e51ad453ec2-16175743.jpg" alt="需求定义"></p>
<h2 id="第四章-面向对象分析"><a href="#第四章-面向对象分析" class="headerlink" title="第四章 面向对象分析"></a>第四章 面向对象分析</h2><blockquote>
<p>UML<br>面向对象分析模型<br>    1. 领域建模<br>    2. 用例建模</p>
</blockquote>
<ol>
<li>领域建模<ol>
<li>领域模型的定义和表示</li>
<li>业务背景：概念类及关系，类图</li>
<li>业务流程：活动图(没讲)</li>
</ol>
</li>
<li>用例建模<ol>
<li>⽤例图</li>
<li>⽤例说明</li>
<li>系统顺序图</li>
<li>操作契约</li>
</ol>
</li>
</ol>
<h3 id="UML概念及画法"><a href="#UML概念及画法" class="headerlink" title="UML概念及画法"></a>UML概念及画法</h3><p>UML（Unified Modeling Language）：面向对象的统一建模语言。</p>
<ul>
<li>不是一种可视化的程序设计语言，而是—种可视化的建模语言;</li>
<li>不是工具或知识库的规格说明，而是一种建模语言规格说明，是一种表示的标准;</li>
<li>不是过程，也不是方法，但允许任何一种过程和方法使用它。</li>
</ul>
<p>4+1 视图：从不同视角为系统架构建模，形成系统的不同视图。分别为：</p>
<ul>
<li>用例视图Use Case View（用户模型视图、场景视图）：强调从用户角度看到的或需要的系统功能。</li>
<li>逻辑视图Logical view（结构模型视图、静态视图）：展现系统的静态或结构组成及特征。</li>
<li>进程视图Process View（行为模型视图、过程视图、协作视图、动态视图）：描述设计的并发和同步等特性，关注系统非功能性需求。</li>
<li>构件视图Component View（实现模型视图、开发视图）：关注代码的静态组织与管理。</li>
<li>部署视图Deployment View（环境模型视图、物理视图）：描述硬件的拓扑结构以及软件和硬件的映射问题，关注系统非功能性需求（性能、可靠性等）。<br><img src="https://api2.mubu.com/v3/document_image/1b6cde9d-8b76-4f23-b95c-739c2cd5da71-16175743.jpg" alt="2"></li>
</ul>
<p>每一种 UML的视图都是由一个或多个图(Diagram)组成的,一个图就是系统架构在某个侧面的表示,所有的图组成系统的完整视图。UML 规范提供下述9种基本的图形元素：</p>
<ul>
<li><strong>用例图 Use Case Diagram：从用户的角度描述系统的功能</strong>。</li>
<li><strong>类图 Class Diagram：描述系统的静态结构（类及其相互关系）</strong>。</li>
<li>对象图：描述系统在某个时刻的静态结构（对象及其相互关系）。</li>
<li><strong>顺序图 Sequence Diagram：按时间顺序描述系统元素间的交互</strong>。</li>
<li><strong>协作图 Collaboration Diagram：按照时间空间的顺序描述系统元素间的交互和他们之间的关系</strong>。</li>
<li>状态图 State Diagram：描述系统元素（对象）的状态条件和响应。</li>
<li>活动图 Activity Diagram：描述了系统元素之间的活动。</li>
<li>构件图 Componet Diagram：描述了实现系统的元素（类或包）组织。</li>
<li>部署图 Deployment Diagram：描述了环境元素的配置并把实现系统的元素映射到配置上。</li>
</ul>
<p>UML 视图与图的关系：</p>
<ul>
<li><mark>用例视图——用例图和活动图。</mark></li>
<li><mark>逻辑视图——类图、对象图、顺序图&#x2F;协作图。</mark></li>
<li>进程试图——状态图、活动图。</li>
<li>构件视图——构件图。</li>
<li>部署视图——部署图。</li>
</ul>
<h4 id="UML类图的画法"><a href="#UML类图的画法" class="headerlink" title="UML类图的画法"></a>UML类图的画法</h4><h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><h5 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h5><p><img src="https://api2.mubu.com/v3/document_image/a4f9f78c-bcd3-4142-b74a-d76f0187fb97-16175743.jpg" alt="2"></p>
<h6 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h6><p>当发现一个类“须知道”另一个类并使用它的对象时,这两个对象之间存在依赖关系。</p>
<blockquote>
<p>注意:此时声明两个类之间存在依赖关系时,仅仅说明它们在对象的级别上存在关系,而非对象的内部属性和操作,因此依赖关系是类之间关系最薄弱的环节。UML规范中用带有箭头的虚线表示依赖关系,并且特别注意两个概念类之间谁依赖谁。</p>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/74763d62-6fb8-43ae-8c06-47a005ed46bb-16175743.jpg" alt="2"></p>
<h6 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h6><p>当一个类的属性声明另一个类的对象或者定义另一个类的对象引用时﹐说明这两个类之间存在关联关系。</p>
<p><img src="https://api2.mubu.com/v3/document_image/babe96c8-3538-4477-a518-e328a8cca58c-16175743.jpg" alt="2"></p>
<h6 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h6><p>当一个类A(整体类)拥有另一个类B(部分类),<strong>同时其他的类C也可分享类B</strong>,即类B不完全被类A所拥有时,它们之间存在聚合关系。</p>
<p><img src="https://api2.mubu.com/v3/document_image/4d1ccd95-23c8-48cd-bd6f-0c88811d52d7-16175743.jpg" alt="2"><br><img src="https://api2.mubu.com/v3/document_image/193b9306-ea6f-4201-981c-370fbfae2677-16175743.jpg" alt="2"></p>
<h6 id="类的组合关系"><a href="#类的组合关系" class="headerlink" title="类的组合关系"></a>类的组合关系</h6><p>当一个类A(整体类)完全拥有另一个类B(部分类),<strong>且其他任何类都不能分享类B时</strong>，它们之间存在组合关系。当整体类消失时,部分类也不会存在。</p>
<h6 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h6><p>当一个类(父类)是另外一个类或一些类(子类)的类型时,它们之间存在继承或者泛化关系。</p>
<p><img src="https://api2.mubu.com/v3/document_image/e3a010cc-3a53-485e-b456-0e38ebaa7cbb-16175743.jpg" alt="2"></p>
<h6 id="关联类"><a href="#关联类" class="headerlink" title="关联类"></a>关联类</h6><p>在关联建模中,存在一些情况下,需要其他类,因为它包含关于关联有价值的信息。对于这种情况,使用关联类来绑定这些基本关联。关联类和一般类一样表示。不同的是,主类和关联类之间用一条相交的点线连接。</p>
<p><img src="https://api2.mubu.com/v3/document_image/db09d3cc-7b60-4dde-9be6-590703d246ff-16175743.jpg" alt="2"></p>
<h3 id="面向对象的需求分析建模"><a href="#面向对象的需求分析建模" class="headerlink" title="面向对象的需求分析建模"></a>面向对象的需求分析建模</h3><p><img src="https://api2.mubu.com/v3/document_image/f2be816c-c1f8-452e-8691-1dd10c09dd7a-16175743.jpg" alt="2"></p>
<h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><p>领域模型：领域内概念类或对象的抽象可视化表示（将客观世界中的事物可视化抽象化）。主要用于概括地描述业务背景和重要的业务流程，通过类图和活动图展示。</p>
<ul>
<li>业务背景：描述概念类之间的关系，表示成能够代表业务知识结构的类图。</li>
<li>业务流程：由角色及其执行的活动构成。由活动图描述。</li>
</ul>
<p>创建领域模型的步骤：</p>
<ol>
<li>找出当前需求中的候选概念类。</li>
<li>在领域模型中描述这些概念类。用问题域中的词汇对概念类命名，将与当前需求无关的概念类排除。</li>
<li>在概念类之间添加必要的关联来记录关系。用关联、继承、组合&#x2F;聚合表示。</li>
<li>在概念类中添加用来实现需求必要的属性。</li>
</ol>
<p>识别概念类或属性：</p>
<ul>
<li>属性一般是可以赋值的（如数字、文本），而概念类不可以。</li>
<li>如果对一个名词是概念类还是属性不确定，将其作为概念类处理。</li>
<li>不存在名词到类的映射机制，因为自然语言具有二义性。</li>
</ul>
<p>领域模型中的关联可分为两种：“需要知道”型和“只需理解”型关联，着重考虑前者。</p>
<ul>
<li>“<mark>须</mark>要知道”型关联：需要将概念之间的关系信息保持一段时间的关联。领域模型中需要着重考虑。</li>
<li>“只需理解”型关联：有助于增强对领域中关键概念的理解的关联.</li>
</ul>
<p>寻找关联时要遵循下述指导原则：</p>
<ul>
<li>将注意力集中在须要知道型关联。</li>
<li>识别概念类比识别关联更重要，因此领域模型创建过程中应该更加注重概念类的识别。</li>
<li>太多的关联不仅不能有效地表示领域模型，反而容易使领域模型变得混乱。</li>
<li>避免显示冗余或导出关联。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/7c34822e-95d8-42b9-9340-c31696d59ebe-16175743.jpg" alt="2"></p>
<h3 id="用例模型"><a href="#用例模型" class="headerlink" title="用例模型"></a>用例模型</h3><p>用例模型是“目标系统”的逻辑模型，定义了目标系统“做什么”的需求。由四部分组成：<br>以用例为核心从使用者的角度描述和解释待构建系统的功能需求</p>
<ul>
<li>用例图</li>
<li>用例说明</li>
<li>系统顺序图 SSD</li>
<li>操作契约 Operation Contract</li>
</ul>
<p>创建用例模型的步骤：</p>
<ol>
<li>确定<strong>问题域</strong>的分析范围;</li>
<li>确定该范围内可能出现的<strong>角色</strong>；</li>
<li>根据业务背景或者领域模型，确定每个角色需要的<strong>用例</strong>，并形成<strong>用例图</strong>；</li>
<li>基于确定的用例，整理成规范的<strong>用例描述文本</strong>；</li>
<li>在可能的情况下，将多个角色的用例图整合成一个相对<strong>完整的用例图</strong>；</li>
<li>针对每个用例，结合相应的用例描述，确定系统顺序图中角色与系统之间的<strong>交互</strong>，绘制基于用例的<strong>系统顺序图</strong>；</li>
<li>基于每个系统顺序图，确定<strong>每个事件交互</strong>经过系统处理后应该返回给角色的声明性结果，即<strong>操作契约</strong>；</li>
</ol>
<p>用例图：由三个基本元素组成。</p>
<ul>
<li>Actor：称为角色或参与者，使用系统的对象（不一定是人）。</li>
<li>Usecase：用例，描述角色如何使用系统功能实现需求目标的一组成功场景和一系列失败场景的集合。</li>
<li>Association：角色和用例之间的关系、用例和子用例之间的关系。</li>
</ul>
<p>用例之间的关系：</p>
<ul>
<li>包含：一部分行为经常会出现在多个用例中，为了避免重复，可以创建一个子功能级别的用例，并让其他的用例包含它。（比如取款包含身份验证和有效性验证两个子用例）</li>
<li>扩展：（多个）基本用例中的某些场景存在相同的条件判断的情况，可以将其抽取出来作为基本用例的子用例；</li>
</ul>
<p>用例图示例</p>
<h3 id="系统顺序图-SSD"><a href="#系统顺序图-SSD" class="headerlink" title="系统顺序图 SSD"></a>系统顺序图 SSD</h3><p>确定角色与系统之间的交互关系，以代码风格命名。包含：</p>
<ul>
<li>角色。</li>
<li>代表软件系统的对象，一般使用 system 或系统命名。</li>
<li>角色与 system 之间的交互信息，简称消息或操作。</li>
</ul>
<h3 id="操作契约"><a href="#操作契约" class="headerlink" title="操作契约"></a>操作契约</h3><p>为系统操作定义。领域模型中业务对象接收到系统事件后，执行必须的业务处理时各业务对象的状态以及系统操作执行的结果。</p>
<h2 id="第五章-结构化需求分析方法"><a href="#第五章-结构化需求分析方法" class="headerlink" title="第五章 结构化需求分析方法"></a>第五章 结构化需求分析方法</h2><blockquote>
<p>结构化分析模型的组成<br>  数据建模(ER)<br>  功能建模(数据流图)<br>  行为建模(结构化动态分析：状态迁移图、时序图、Petri⽹等)<br>  数据字典<br>软件需求规格说明书（领域+用例）</p>
</blockquote>
<p>需求分析的分析模型必须达到三个主要⽬标：</p>
<ul>
<li>描述客户的需求；</li>
<li>建⽴创建软件设计的基础；</li>
<li>定义在软件完成后可以被确认的⼀组需求。</li>
</ul>
<p>结构化分析模型的组成：如图<br><img src="https://api2.mubu.com/v3/document_image/0de3a094-5efc-48c7-9fa8-728ef3981f10-16175743.jpg" alt="moxing"></p>
<p>数据建模：</p>
<p>概念性数据模型基于实体-关系（ER）法，也称为实体关系模型。描述了从用户角度看到的数据，反映用户现实环境，但与软件系统中的实现方法无关。<br>数据对象描述：描述了数据对象实体的名称及其所有属性。<br>数据对象的基数：一对一、一对多、多对多。</p>
<p>功能建模</p>
<p>当数据或信息“流”过计算机系统时将会被系统的功能所处理、加⼯或变换后再将处理或变换后的数据从系统输出。基于计算机的系统可被表示为数据流图的基本结构。</p>
<p>数据流图有四种基本元素</p>
<p><img src="https://api2.mubu.com/v3/document_image/80cd0f1f-6a3a-43ec-b906-6f395d46d303-16175743.jpg" alt="4"></p>
<p><mark>数据流图的例子：医院就诊管理系统例子</mark><br><img src="https://api2.mubu.com/v3/document_image/66148b55-dd92-4184-9cec-b430feee43b6-16175743.jpg" alt="题目"><br><img src="https://api2.mubu.com/v3/document_image/8d71cf63-8a3c-484a-afc9-01ed1c7c9e70-16175743.jpg" alt="0"><br>第⼀层数据流图:<br>⽬标是要确定该层具有多少个子加工，以及子加工之间新增的数据流<br>解释顶层数据流图中每⼀条数据流从外部实体流⼊到系统级的加工之<br>后，这些数据流是如何被接收和处理的。<br><img src="https://api2.mubu.com/v3/document_image/6f5c1d92-3be5-4240-8ea9-eab1ecd3d036-16175743.jpg" alt="1"></p>
<ul>
<li>子加工的分析：尽可能将系统分解为多个⼦系统，降低问题域的复杂程度，经分析得到：挂号处理⼦系统、问诊处理⼦系统等；</li>
<li>子加工之间有⽆新增数据流：（示例）两个可能的解决⽅案</li>
</ul>
<p>第⼆层数据流图<br><img src="https://api2.mubu.com/v3/document_image/501ef61d-893a-438d-a4c0-f07c957feb27-16175743.jpg" alt="2"></p>
<ul>
<li>确定⼦系统内部具体的业务功能。</li>
<li>解释每⼀个数据流进⼊到加⼯后，系统内是否还存在⼀些加⼯：接收数据流、分解数据流、转换数据流、处理数据流直到存储必要的数据信息进⼊数据⽂件存储，并产⽣需求规定的数据数据流。</li>
</ul>
<p><mark>检查和修改数据流图的原则</mark></p>
<ul>
<li>数据流图上所有图形符号只限于前述四种基本图形元素，且必须包括前述四种基本元素，缺⼀不可。</li>
<li>数据流图的主图上的数据流必须封闭在外部实体之间，外部实体可以不⽌⼀个。</li>
<li>每个加⼯⾄少有⼀个输⼊数据流和⼀个输出数据流。</li>
<li>在数据流图中，需按层给加⼯框编号，表明该加⼯处在哪⼀层，以及上下层的⽗图与⼦图的对应关系。</li>
<li>任何⼀个数据流⼦图必须与它上⼀层的⼀个加⼯对应，两者的输⼊数据流和输出数据流必须⼀致。即⽗图与⼦图的平衡，表明在细化过程中输⼊与输出不能有丢失和强加。</li>
<li>图上每个元素都必须有名字。表明数据流和数据⽂件是什么数据，加⼯做什么事情。</li>
</ul>
]]></content>
      <categories>
        <category>笔记 - 软件工程</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>计网笔记_网络层</title>
    <url>/2022/05/17/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0_%E7%BD%91%E7%BB%9C%E5%B1%821/</url>
    <content><![CDATA[<h2 id="5-1网络层设计问题"><a href="#5-1网络层设计问题" class="headerlink" title="5.1网络层设计问题"></a>5.1网络层设计问题</h2><h2 id="5-2路由算法"><a href="#5-2路由算法" class="headerlink" title="5.2路由算法"></a>5.2路由算法</h2><h3 id="路由算法的职责"><a href="#路由算法的职责" class="headerlink" title="路由算法的职责"></a>路由算法的职责</h3><ol>
<li>负责决定一个到来的包应该被传输到哪条输出线路<br>如果子网内部使用数据报文，自从最好的路由上次被改变之后，对于每个数据包这个决定必须重新做。<br>如果子网用的是虚拟电路，路由决定会被做出仅当一个新的虚拟电路被建立之后。在这之后，数据包只是follow之前已经被建立的路由</li>
<li>转发&amp;路由</li>
</ol>
<h3 id="路由算法的目标"><a href="#路由算法的目标" class="headerlink" title="路由算法的目标"></a>路由算法的目标</h3><ol>
<li>正确</li>
<li>简单</li>
<li>健壮性</li>
<li>稳定性（抖动的问题）</li>
<li>公平性</li>
<li>最优性<ol>
<li>最小化包时延</li>
<li>最大化网络通量</li>
</ol>
</li>
</ol>
<h3 id="路由算法的分类"><a href="#路由算法的分类" class="headerlink" title="路由算法的分类"></a>路由算法的分类</h3><ol>
<li>static（静态的）<br>路由选择不会根据当前的拓扑和流量改变<br>线路断了也不会改变<br>就是路由器启动的时候下载到路由器里面的<blockquote>
<p>拓扑的变化：<br> 加&#x2F;减一条线路，</p>
</blockquote>
</li>
<li>adaptive 适应性的<br>随着 拓扑结构的变化，通常也包括traffic的变化 改变路由。<br>由于考虑traffic比较复杂，所以现在学的一般只考虑拓扑结构的变化。<br>拓扑结构的变化就是指的这个图上任何一个节点或者边发生变化，其他节点都能感受到。</li>
</ol>
<h3 id="最优化原则"><a href="#最优化原则" class="headerlink" title="最优化原则"></a>最优化原则</h3><p><img src="https://api2.mubu.com/v3/document_image/1f996d7b-76c8-4be2-8767-de89bb4c465e-16175743.jpg" alt="最优化"><br>如果J在I-&gt;K的最短路径上，显然，J-&gt;K的最短路径也是同样的route</p>
<h3 id="sink-tree"><a href="#sink-tree" class="headerlink" title="sink tree"></a>sink tree</h3><p>从所有的源到某个特定的的目的地的最优化的路由形成了一个根节点是目的地的树。<br>不含任何loop，所以每个包会被在有限跳内传输<br>routing 算法的目标：</p>
<ul>
<li>针对所有的router发现并使用sink tree</li>
<li>不用的router针对现有的拓扑结构可能有不同的理解，或者掌握的信息不一样<br><img src="https://api2.mubu.com/v3/document_image/56b996e5-cf09-4bd7-802c-f43c1b4ec12c-16175743.jpg" alt="sinktree"></li>
</ul>
<h3 id="最短路径路由（Shortest-Path-Router）"><a href="#最短路径路由（Shortest-Path-Router）" class="headerlink" title="最短路径路由（Shortest Path Router）"></a>最短路径路由（Shortest Path Router）</h3><ol>
<li>建立一个有向带权图</li>
<li>权值的方法：<ol>
<li>几跳就是几</li>
<li>地理上的千米距离</li>
<li>排队和传输时延，决定于时间</li>
<li>一个关于距离，带宽，平均traffic，交流开销，等等的函数</li>
</ol>
</li>
<li>Dijkstra算法（已知拓扑，计算是容易的，难的是构造拓扑）</li>
</ol>
<h3 id="Flooding-路由算法"><a href="#Flooding-路由算法" class="headerlink" title="Flooding 路由算法"></a>Flooding 路由算法</h3><ol>
<li>不需要网络拓扑信息</li>
<li>每个路由器将收到的包发往除了输入端口之外的所有线路</li>
</ol>
<p>可能遇到的问题：<br>产生超级超级多的包</p>
<p>措施：</p>
<ol>
<li>每个包的头有一个hop counter，每转发一次，计数器减一，计数器减小到0的时候，就discard</li>
<li>源在每个包里面放一个sequence number，每个router记录收到的最大的seq，来判断那些包已经收到过了</li>
<li>选择性的flooding<ol>
<li>每个router记录收到的数据item，在数据库里面</li>
<li>每个item有一个版本号</li>
<li>只有新的data item才会被flooded</li>
</ol>
</li>
</ol>
<p>特征：</p>
<ol>
<li>所有可能的路线都会被尝试<ol>
<li>非常滴鲁棒，适合用于部队内部通信这样的。</li>
</ol>
</li>
<li>至少一个包会采用最小</li>
<li>所有的节点都会被访问到</li>
</ol>
<h3 id="Distance-Vector-Routing：DV算法"><a href="#Distance-Vector-Routing：DV算法" class="headerlink" title="Distance Vector Routing：DV算法"></a>Distance Vector Routing：DV算法</h3><p>又叫贝尔曼·福特算法</p>
<ol>
<li>每个router维护一个表<ol>
<li>到每个目的地的已知最好的距离<ol>
<li>这里的distance可能是<strong>hops</strong>的数目，时延ms，etc.</li>
</ol>
</li>
<li>使用哪条line</li>
</ol>
</li>
<li>这个表会不断的通过跟邻居交换信息来update<ol>
<li>发送routing信息（distance，destination）<ol>
<li>周期性的发送</li>
<li>当表改变的时候</li>
</ol>
</li>
<li>接受routing信息<ol>
<li>如果收到了一个更好的route，就更新</li>
<li>refresh已经存在的routes（有个时戳，对应下面那个times out）</li>
</ol>
</li>
<li>如果某个item times out 了，就删除这一项</li>
</ol>
</li>
</ol>
<p>例子1：<br><img src="https://api2.mubu.com/v3/document_image/1832a33b-d231-44c8-9aa1-6664c35a5c61-16175743.jpg" alt="E1"></p>
<p>A I H K四列都是J收到的的邻居发的distance vector  </p>
<p>下面那个大括号是J到几个邻居的最新距离。<br>假如要计算J到D的距离<br>那就是看D-&gt;X-&gt;J的最短距离，X是J的几个邻居<br>X&#x3D;A:40+8<br>X&#x3D;I:27+10<br>X&#x3D;H:8+12<br>X&#x3D;K:24+6  </p>
<p>例子2：</p>
<blockquote>
<p>有时候无穷大认为是16</p>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/38282183-0872-4cf3-8343-e3beca5c7b8d-16175743.jpg" alt="E2"><br><img src="https://api2.mubu.com/v3/document_image/9b1baf0a-f80f-42b1-b12d-648ffea3f545-16175743.jpg" alt="E2-1"><br><img src="https://api2.mubu.com/v3/document_image/8e32db72-e676-4442-8949-f49f359f580b-16175743.jpg" alt="E2-2"><br><img src="https://api2.mubu.com/v3/document_image/779adf84-9aa6-4b69-80ed-5d9822fcac7c-16175743.jpg" alt="E2-3"><br><img src="https://api2.mubu.com/v3/document_image/02571fad-26d6-4173-87e7-1c531eb533f7-16175743.jpg" alt="E2-4"><br><img src="https://api2.mubu.com/v3/document_image/786d8b13-9f8e-4c40-81d0-b414ec279794-16175743.jpg" alt="E2-5"></p>
<p>可以发现，当网络规模不是特别大的时候，路由算法会收敛，也就是会稳定下来。</p>
<p>一个问题：<br>Count-to-infinity<br>计数到无穷<br><img src="https://api2.mubu.com/v3/document_image/70eca855-4644-45dd-966b-ef781afc9919-16175743.jpg" alt="cti"><br>（a）是正常的时候，从无到收敛的过程<br>（b）是稳定之后，A出现故障的时候，由于A故障了，所以B只能从C得到到A的距离，然后依次这样，一直扩散扩散，形成环路，而实际上A已经不能到达了。直到到达无穷（16）的时候，会认为不可达了。通过这个例子可以知道网络的规模不能太大。</p>
<p>另一个关于这个问题的说明：<br>初始：<br><img src="https://api2.mubu.com/v3/document_image/c9b4128c-4f24-422d-9d0c-98114a727f4e-16175743.jpg" alt="初始"><br>若干时间之后：<br><img src="https://api2.mubu.com/v3/document_image/cb4d204a-3e51-42b6-b6da-4bcbc184d1fb-16175743.jpg" alt="若干时间之后："></p>
<p>RIP:set infinity to 16<br>这个RIP是routing information protocol</p>
<p>可能出现的其他情况：<br><img src="https://api2.mubu.com/v3/document_image/1ccfc686-a470-4b0d-83f1-2442d4cfaf1f-16175743.jpg" alt="其他"></p>
<p>一个09考研的例子  没题目，好像是让写出路由<br><img src="https://api2.mubu.com/v3/document_image/925c7b0c-6669-45b8-a1c4-7872519d00ac-16175743.jpg" alt="例"></p>
<ul>
<li>diatance vector routing<ul>
<li>RIP协议</li>
<li>CIsco EIGRP协议</li>
</ul>
</li>
<li>一些问题：<ul>
<li>当X告诉Y它有一条路，Y不知道自己是不是在这条路里面</li>
<li>通过rumor构建路由</li>
</ul>
</li>
<li>Path Vector Routing PV算法</li>
</ul>
<h3 id="Link-State-Routing-：LS算法"><a href="#Link-State-Routing-：LS算法" class="headerlink" title="Link State Routing ：LS算法"></a>Link State Routing ：LS算法</h3><p>中文名叫 链路状态路由选择算法<br>LS算法：<br>每个路由器都要干下面这些事儿：</p>
<ol>
<li>发现它的neighbors，学到他们的网络地址，就是通过打招呼找到的。（A跟B说hi~这样）</li>
<li>按照统一的度量标准设置到自己邻居的distance或者cost</li>
<li>建立一个链路状态数据包(LSP:Link-state Packet)，显示它“学”到的所有信息</li>
<li>把这个包发给<strong>所有的</strong>路由器，用flooding扩散</li>
<li>计算到除自己以外每个router的距离</li>
</ol>
<h4 id="从邻居那里学一些信息"><a href="#从邻居那里学一些信息" class="headerlink" title="从邻居那里学一些信息"></a>从邻居那里学一些信息</h4><ol>
<li>HELLO包<br>广播网络broadcast network：使用广播报文<br>不是广播网络的：发unicast HELLO</li>
<li>邻居发一个reply告诉它自己是谁<br>Names (Route IDs) must be globally unique</li>
<li>简化拓扑<br>When two or more routers are connected by a LAN or other multi-access network</li>
</ol>
<h4 id="Artificial-Node"><a href="#Artificial-Node" class="headerlink" title="Artificial Node"></a>Artificial Node</h4><p>伪节点<br><img src="https://api2.mubu.com/v3/document_image/abf96ed0-62dd-4e68-bdcf-132664724d3d-16175743.jpg" alt="wjd"><br>这个N可以是A也可以是C，也可以是F，任选一个。假如选了A，那么A内部就可以有两个邻接矩阵。</p>
<h4 id="设置-Link-Cost"><a href="#设置-Link-Cost" class="headerlink" title="设置 Link Cost"></a>设置 Link Cost</h4><ul>
<li>The cost to each of its neighbors</li>
<li>The cost to reach neighbors can be set automatically</li>
<li>Configured by the network operator</li>
<li>Make the cost inversely proportional to the bandwidth of the link</li>
</ul>
<h4 id="构造链路状态数据包"><a href="#构造链路状态数据包" class="headerlink" title="构造链路状态数据包"></a>构造链路状态数据包</h4><p><img src="https://api2.mubu.com/v3/document_image/1a39d0fd-bbfa-4b21-9a32-9325e5f98aff-16175743.jpg" alt="LSP"></p>
<p>啥时候构造 LSP：</p>
<ol>
<li>周期性的构造</li>
<li>当“大事情”发生的时候构造一下<br>就比如是一个line或者neighbor going down了&#x2F;come back up了，或者显著的改变性质了</li>
</ol>
<h4 id="分发LSP"><a href="#分发LSP" class="headerlink" title="分发LSP"></a>分发LSP</h4><p>懒得翻译了<br><img src="https://api2.mubu.com/v3/document_image/ae9dc435-cb6a-4395-9893-9529dbad3971-16175743.jpg" alt="distribute"></p>
<h4 id="关于LSP"><a href="#关于LSP" class="headerlink" title="关于LSP"></a>关于LSP</h4><ul>
<li>sequence number<ul>
<li>新的LSP：向所有人转发</li>
<li>复制的LSP：discard</li>
<li>小于目前收到的最大的序列号：认为是废旧的</li>
<li>如果一个router down（关掉）了，然后又restart（重启）了，（这样可能导致版本低了）就拒绝（旧版本的）</li>
<li>如果序号wrap（回绕）了，具体的协议中是2^32次方个数，基本上用不完，可能需要100多年才能回绕</li>
<li>受损：因为是可靠传输，所以会重传</li>
</ul>
</li>
<li>age<ul>
<li>指的是LSP的存活时间</li>
<li>应用状态&#x2F;解决的问题<ul>
<li>如果路由器关了</li>
<li>如果路由器改变了它的routerid</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="LSP-flooding-算法的精巧-x2F-改进之处"><a href="#LSP-flooding-算法的精巧-x2F-改进之处" class="headerlink" title="LSP flooding 算法的精巧&#x2F;改进之处"></a>LSP flooding 算法的精巧&#x2F;改进之处</h4><p><img src="https://api2.mubu.com/v3/document_image/b97927b2-7246-4bae-9508-50b4d74362a0-16175743.jpg" alt="sdf"></p>
<h4 id="计算新的Route"><a href="#计算新的Route" class="headerlink" title="计算新的Route"></a>计算新的Route</h4><p>当一个router收集到了一整套的LSP，它就可以建立整个图了<br>然后运行迪杰斯特拉算法，算最短路径<br>计算结果就被扔到routing table里面  </p>
<p>一个例子</p>
<!-- 还没抄过来（ -->
<p><img src="https://api2.mubu.com/v3/document_image/a96a5f6b-ec04-405f-ae8a-53ac8967b566-16175743.jpg" alt="图1"><br><img src="https://api2.mubu.com/v3/document_image/2e9fdd3c-9238-434c-a947-ee2a75110d28-16175743.jpg" alt="图2"></p>
<h4 id="LSR的例子"><a href="#LSR的例子" class="headerlink" title="LSR的例子"></a>LSR的例子</h4><p>了解即可<br><img src="https://api2.mubu.com/v3/document_image/3dcbe875-82ec-458a-9270-0b2b43cbc0c6-16175743.jpg" alt="例子"></p>
<h3 id="Hierarchical-Routing-分层次的路由"><a href="#Hierarchical-Routing-分层次的路由" class="headerlink" title="Hierarchical Routing 分层次的路由"></a>Hierarchical Routing 分层次的路由</h3><p>简化路由表的例子：<br><img src="https://api2.mubu.com/v3/document_image/13296af2-2cea-4809-8140-bb2ed03a6062-16175743.jpg" alt="简化路由表"><br>就是把几个离得近的路由器划分成一个小组，然后抽象成原本的一个点</p>
<h2 id="5-3-Congestion-Control-算法"><a href="#5-3-Congestion-Control-算法" class="headerlink" title="5.3 Congestion Control 算法"></a>5.3 Congestion Control 算法</h2><p>congestion：拥塞<br>出现拥塞的原因：太多的traffic被提供，网络性能剧烈下降<br><img src="https://api2.mubu.com/v3/document_image/4da34490-29fa-4712-a50a-04b3e19d3a3a-16175743.jpg" alt="yongsai"><br>次要因素：突发流量与缓冲队列(太长&#x2F;太短)<br>慢CPU忙于维护操作，转发操作太慢导致线路容量浪费<br>弄很长的内存可行吗？不能完全解决了，因为排的队比较长，时间太长，超时了，数据就无效了。</p>
<h3 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h3><p>拥塞控制是一个<strong>全局的问题</strong><br>流量控制是<strong>2个站点之间的</strong>问题，是通过一些反馈信息减缓发送端的发送速度，从而使发送端的速度与接收端的接收或者处理速度相适配。</p>
<h3 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h3><p><img src="https://api2.mubu.com/v3/document_image/d37a41af-0644-44c7-b3d9-b8cfb6a777e3-16175743.jpg" alt="approach"></p>
<p>从左往右：<br>网络供给增加<br>流量感知路由<br>许可证的控制<br>流量的限制&#x2F;调节<br>Load shedding 甩负荷</p>
<h3 id="Traffic-aware-Routing"><a href="#Traffic-aware-Routing" class="headerlink" title="Traffic-aware Routing"></a>Traffic-aware Routing</h3><p>有一些危险：<br>routing 表可能会剧烈的震荡，当两部分之间有两条类似的线路时</p>
<h3 id="Admission-Control-准入控制"><a href="#Admission-Control-准入控制" class="headerlink" title="Admission Control 准入控制"></a>Admission Control 准入控制</h3><p>在<strong>虚电路</strong>中广泛被使用<br>如果网络拥塞了，就不让建立新的虚电路<br>traffic的描述：通过rate和shape来描述<br>shape有两种：leaky bucket，token bucket  </p>
<h3 id="Traffic-Throttling-流量限制"><a href="#Traffic-Throttling-流量限制" class="headerlink" title="Traffic Throttling 流量限制"></a>Traffic Throttling 流量限制</h3><!-- 9：01 ppt66页-->
<p>当即将发生拥塞的时候，网络告诉sender节流。<br>（有趣的是这里的“网络”指的是路由器，能“告诉”的只有路由器了）  </p>
<ul>
<li>路由器需要决定什么时候拥塞正在迫近，理想情况下是在拥塞到来之前就判定</li>
<li>一般根据下面这些来判定：<ul>
<li>输出线路的利用率</li>
<li>队列的长度</li>
<li>现在丢包的数量</li>
<li>算平均值的方法：<br> EWMA：Exponentially Weighted Moving Average<br> $$d_{new}&#x3D;\alpha d_{old}+(1-\alpha)s$$<br> 上式中,s是当前的量，阿尔法是一个系数，一般取0.8</li>
</ul>
</li>
<li>路由器需要<strong>周期性的</strong>向导致拥塞的sender发送反馈信息<ul>
<li>Choke packets</li>
<li>ECN</li>
<li>Hop-by-Hop backpressure</li>
</ul>
</li>
</ul>
<h4 id="Choke-packets-抑制分组"><a href="#Choke-packets-抑制分组" class="headerlink" title="Choke packets 抑制分组"></a>Choke packets 抑制分组</h4><p>路由器选择一个在拥塞线路上发送的分组（拥塞分组），然后<strong>给源</strong>发送一个choke packet<br>（internet source quech message），让源端降速的一个消息</p>
<h4 id="ECN（Explicit-Congestion-Notification）"><a href="#ECN（Explicit-Congestion-Notification）" class="headerlink" title="ECN（Explicit Congestion Notification）"></a>ECN（Explicit Congestion Notification）</h4><p>显式的拥塞通知<br>（其实上面那个也算显式的）</p>
<ul>
<li>路由器对每个packet加tag，来标记它<strong>沿途有</strong>拥塞</li>
<li>当网络传输这个packet的时候，destination可以发现这个标记的拥塞，然后在回复的时候告诉sender（有另外一个可以打tag的bit位，reply的时候给打上）</li>
<li>sender就像之前一样，节流了。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/5df7da5e-9fa5-48a0-a6dc-3c7c92fc74e0-16175743.jpg" alt="图示"></p>
<h4 id="隐式的拥塞通知"><a href="#隐式的拥塞通知" class="headerlink" title="隐式的拥塞通知"></a>隐式的拥塞通知</h4><p>当一个包经过了拥塞，就丢掉它，这样sender就会超时，而且本身网络的错误是比较少的，这样sender就会节流。</p>
<h4 id="Hop-by-Hop-Choke-Packets"><a href="#Hop-by-Hop-Choke-Packets" class="headerlink" title="Hop-by-Hop Choke Packets"></a>Hop-by-Hop Choke Packets</h4><p>没听</p>
<p>问题：<br>解决：  </p>
<p>它可以很快的把流量降下来</p>
<h3 id="Loading-Shedding"><a href="#Loading-Shedding" class="headerlink" title="Loading Shedding"></a>Loading Shedding</h3><p>当router已经满了，就扔掉它们</p>
<p>Polices：</p>
<ul>
<li>Wine&amp;Milk<ul>
<li>对应File transfer和multimedia</li>
</ul>
</li>
<li>需要senders的配合</li>
<li>包的优先级<ul>
<li>视频压缩算法，重要的包打上tag，尽量保重点</li>
<li>允许主机超过协议说好的带宽，但是超出的部分标上比较低的优先级</li>
</ul>
</li>
</ul>
<p>RED（random early detection）<br>随机早期检测</p>
<ul>
<li>在网络情况没有变成没有希望的时候就开始扔包</li>
<li>router如何让source知道出现了问题呢？<ul>
<li>发一个choke包</li>
<li>丢掉选出来的包</li>
</ul>
</li>
<li>sources 降低发送速率</li>
</ul>
<p>ECN&amp;RED</p>
<ul>
<li>RED 在剩余缓存空间到达临界值（不一定满）的时候就开始扔包，而ECN只在路由器的buffer满了的时候才会丢包。</li>
<li>ECN 是通常更愿意选择的, 它显示的产生一个拥塞信号 rather than as a loss; 当主机不能接收显示的信号时，RED 就派上用场了。</li>
</ul>
<h2 id="5-4-QOS"><a href="#5-4-QOS" class="headerlink" title="5.4 QOS"></a>5.4 QOS</h2><ul>
<li>Reliability</li>
<li>Delay</li>
<li>Jitter 抖动</li>
<li>Bandwidth</li>
</ul>
<p>一些应用对上述几个标准的要求：<br><img src="https://api2.mubu.com/v3/document_image/da6848db-edd8-4cf5-b0c7-e44057adaef5-16175743.jpg" alt="需求"></p>
<h3 id="Traffic-Shaping"><a href="#Traffic-Shaping" class="headerlink" title="Traffic Shaping"></a>Traffic Shaping</h3><p>需要解决的问题：<br>主机发送的数据包是不规律的，对网络不友好，可能产生拥塞  </p>
<p>SLA:服务等级的约定（Service Level Agreement）<br>Between the user and the subnet</p>
<ul>
<li>The user: traffic shaping reduces congestion and helps carrier live up to its promise</li>
<li>The carrier: traffic policing<br>(CAR: Committed Access Rate)</li>
</ul>
<p>Traffic shaping：</p>
<ul>
<li>Regulate the average rate and burstiness of data transmission, smooth out the traffic</li>
</ul>
<p>Traffic Policing：</p>
<ul>
<li>Monitoring a traffic flow</li>
<li>Packets in excess of the agreed pattern might be dropped or marked as having lower priority</li>
</ul>
<h3 id="The-Bucket-Algorithm"><a href="#The-Bucket-Algorithm" class="headerlink" title="The Bucket Algorithm"></a>The Bucket Algorithm</h3><p><img src="https://api2.mubu.com/v3/document_image/03268813-0970-46e7-ae2b-a30b2c687aeb-16175743.jpg" alt="桶"></p>
<h4 id="leaky-bucket"><a href="#leaky-bucket" class="headerlink" title="leaky bucket"></a>leaky bucket</h4><p>桶里面攒的是数据，固定速率，<strong>平缓</strong>的发送，减少拥塞的机会。</p>
<h4 id="token-bucket"><a href="#token-bucket" class="headerlink" title="token bucket"></a>token bucket</h4><p>桶里面攒的不是数据，而是一堆<strong>令牌</strong>。相当于是有段时间没发送，然后攒了一堆令牌，然后突然有大量数据一下来了，就可以一下子发挺多。</p>
<p>token bucket algorithm</p>
<p><img src="https://api2.mubu.com/v3/document_image/8015024c-8d10-4347-a49b-f8efa474b6c2-16175743.jpg" alt="几张图"><br>这个图里面，每行是一组。<br>最后一组，令牌桶的容量是0，所以就相当于是漏桶。</p>
<p>几个关键参数：</p>
<p>S：burst length ，单位是sec，突发时间<br>B：，单位是byte，令牌桶的容量<br>R：，byte&#x2F;sec，令牌到达的速度  </p>
<p>最大的output速度：M ，单位是byte&#x2F;sec</p>
<p>$$<br>   B+RS&#x3D;MS<br>$$<br>$$<br>   S&#x3D;B&#x2F;(M-R)<br>$$</p>
<p>举个例子：<br><img src="https://api2.mubu.com/v3/document_image/cb3bfe9f-3804-4aae-9f14-b97affcc1a9a-16175743.jpg" alt="例子"></p>
<p>另一个例子：</p>
<p>突发速率为10Mbps的一台主机通过一个令牌桶进行流量调整。令牌桶的令牌到达速率为2Mbps，令牌桶的初始容量为8Mb。请问该主机以10Mbps速率可以传输多长时间？</p>
<p>相当于求S<br>$$<br>   S&#x3D;B&#x2F;(M-R)&#x3D;1*8Mbits&#x2F;(10-2)&#x3D;1s<br>$$</p>
<h4 id="Packet-Scheduling-分组调度"><a href="#Packet-Scheduling-分组调度" class="headerlink" title="Packet Scheduling  分组调度"></a>Packet Scheduling  分组调度</h4><p>简单了解即可\</p>
<p>算法：</p>
<ul>
<li>FIFO，（FCFS），tail drop 先来先服务（out）</li>
<li>RED，讲过，随机早期检测，隐式的拥塞控制，扔包。</li>
<li>FQ:fair queue，公平队列</li>
</ul>
<p>Round-robin Fair Queueing</p>
<p><a href="https://api2.mubu.com/v3/document_image/bc9b9f80-9e04-41f0-95e4-1365c363a956-16175743.jpg">循环调度</a><br>就轮着拿包，问题在于数据包的大小不一样，包小的就吃亏了。</p>
<p>WFQ: Weighted Fair Queueing</p>
<p><a href="https://api2.mubu.com/v3/document_image/ab416ed4-692e-410c-9c9c-27a10444e99d-16175743.jpg">WFQ</a></p>
<p>还有一种叫PQ：优先级队列<br>优先级高的先发送。</p>
<h2 id="5-5-Internetworking"><a href="#5-5-Internetworking" class="headerlink" title="5.5 Internetworking"></a>5.5 Internetworking</h2><h3 id="网络不同在哪？"><a href="#网络不同在哪？" class="headerlink" title="网络不同在哪？"></a>网络不同在哪？</h3><p><img src="https://api2.mubu.com/v3/document_image/388f7267-9836-4e76-88b9-3bdae17dd795-16175743.jpg" alt="differ"></p>
<p>不同的网络进行互联：</p>
<ol>
<li>用一种设备，转换一种网络到另一种网络，适用于网络种类比较少的情况</li>
<li>在不同网络的上面加一个层次，在这一层进行转换，是目前ip网络选择的方案<br>俩人弄的这个，搞到了图灵奖：Vinton Cerf, Robert Kahn 1974, Turing Award 2004</li>
</ol>
<h3 id="不同网络是如何进行互联的呢？"><a href="#不同网络是如何进行互联的呢？" class="headerlink" title="不同网络是如何进行互联的呢？"></a>不同网络是如何进行互联的呢？</h3><p><img src="https://api2.mubu.com/v3/document_image/4a8a2b46-e403-481b-9df4-3053128597b6-16175743.jpg" alt="图片"></p>
<p>网桥&amp;路由器</p>
<h3 id="Tunneling隧道"><a href="#Tunneling隧道" class="headerlink" title="Tunneling隧道"></a>Tunneling隧道</h3><p><img src="https://api2.mubu.com/v3/document_image/0a08d72e-f114-44cb-b22f-1b02ad0c32f6-16175743.jpg" alt="tunneling"><br>vpn就是这个道理。</p>
<h3 id="互联网络的路由"><a href="#互联网络的路由" class="headerlink" title="互联网络的路由"></a>互联网络的路由</h3><p>路由器看作顶点，网络看作路由。<br>内部网关协议 LS,DV<br>外部网关协议 PV</p>
<h3 id="MTU-最大传输单元"><a href="#MTU-最大传输单元" class="headerlink" title="MTU 最大传输单元"></a>MTU 最大传输单元</h3><p>maximum transmission unit</p>
<p><img src="https://api2.mubu.com/v3/document_image/f79652c4-50fe-44da-8727-213094823a7f-16175743.jpg" alt="数据包分段"></p>
<p>MTU是一个<strong>网络内部</strong>允许（用户）传输的最大尺寸  </p>
<p>Fragmentation 分片</p>
<p>来了个大的数据包我就切成小的碎片。</p>
<ol>
<li>透明<strong>transparent</strong>分片，网络里的透明就是看不见的意思，简单来说，透明分片就是进入一个网络的时候切片，出去的时候再组装回去。<br>但透明分片太复杂了，因为每次都得这么倒腾一回，而且每个数据包都必须到达同一个路由器出口。<br>Recombination occurs at the exit gateway (ATM)</li>
<li>非透明<strong>nontransparent</strong>分片，避免在任何一个路由器上重新组合。每个小分段都被当做一个完整的数据包来对待，只有到了目标主机才进行组合。<br>Recombination occurs only at the destination host (IP)<br>但是这个的问题在于，任何一个碎片丢了，目的端主机就装不回去了。</li>
</ol>
<p>IP协议是这么干的<br><img src="https://api2.mubu.com/v3/document_image/ff4ef6ff-885e-4c17-9760-7be8a054293e-16175743.jpg" alt="IP 分组命名"><br>头的中间那个东西是一个序号标识，就代表我这一个分段里，对应到原始包里，第一个字节前面有多少字节，拿（b）举例，I字节前面有8个字节，所以写8.</p>
<h4 id="path-MTU-discovering的策略"><a href="#path-MTU-discovering的策略" class="headerlink" title="path MTU discovering的策略"></a>path MTU discovering的策略</h4><p>就是不断尝试，找到这一条路由能发送的最大的MTU，就是向下兼容，找到最小的口。<br><img src="https://api2.mubu.com/v3/document_image/69e1313a-a225-4d94-a438-d665e72ac930-16175743.jpg" alt="path"></p>
<h2 id="5-6-The-Network-Layer-in-the-Internet"><a href="#5-6-The-Network-Layer-in-the-Internet" class="headerlink" title="5.6 The Network Layer in the Internet"></a>5.6 The Network Layer in the Internet</h2><p>其实就是ip<br>这里谈的就是<a href="#%E7%BD%91%E7%BB%9C%E4%B8%8D%E5%90%8C%E5%9C%A8%E5%93%AA%EF%BC%9F">不同网络进行互联</a>里面的第二个</p>
<h3 id="10大通用设计原则（RFC文档）"><a href="#10大通用设计原则（RFC文档）" class="headerlink" title="10大通用设计原则（RFC文档）"></a>10大通用设计原则（RFC文档）</h3><p>由重要到不重要<br><img src="https://api2.mubu.com/v3/document_image/0c103f9e-0077-4b76-9e77-2f34f06336c3-16175743.jpg" alt="原则"></p>
<h3 id="IPV4协议"><a href="#IPV4协议" class="headerlink" title="IPV4协议"></a>IPV4协议</h3><p><mark>（各个字段的作用&#x2F;含义是要掌握的）</mark></p>
<p><img src="https://api2.mubu.com/v3/document_image/28d88ffa-961e-4848-bd87-89f72c438a34-16175743.jpg" alt="字段"></p>
<p><a href="https://api2.mubu.com/v3/document_image/1653290130860975a.jpg">图片1</a></p>
<p><a href="https://api2.mubu.com/v3/document_image/7b21e493-d5e7-4a54-9235-3283a7ed1e39-16175743.jpg">图片2</a></p>
<p>下面是一些option的功能：<br><img src="https://api2.mubu.com/v3/document_image/60a00c2e-65d7-44b2-90dd-d3d38764009b-16175743.jpg" alt="一些option"></p>
<h3 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h3><p><img src="https://api2.mubu.com/v3/document_image/b02ef65c-9295-469e-87d0-6a163a5baa76-16175743.jpg" alt="dizhi"></p>
<p>地址分为5类，其中ABC三种是给用户设备用的，其余的是特定的地址，不是给用户用的。<br>A B C:unioncast，<br>D：分组转发，multicast<br>E: broadcast  </p>
<p>一些特殊的地址：<br><img src="https://api2.mubu.com/v3/document_image/c391e25c-6d9d-4ec6-a2ee-6be453d5e3ef-16175743.jpg" alt="special"></p>
<p>全0：本机地址，我不知道我自己的地址，就全写0，一段时间之后，网上的服务器会给分配一个地址<br>network 全0：本网络的地址<br>全1：<strong>本地网络</strong>的广播<br>network+全1：<strong>远程的某个网络</strong>的广播<br>127+其他的任何东西：比如127.0.0.1，指的是本机的地址。<br>查看本地的ip路由表：netstat -rn<br>还有一共ipconfig 忘了是干啥的了。<br><strong>本地的计算机还是有路由表的</strong>。</p>
<h4 id="prefix-前缀"><a href="#prefix-前缀" class="headerlink" title="prefix:前缀"></a>prefix:前缀</h4><p>两种表示方法，表示网络号的位数</p>
<ol>
<li>128.208.0.0&#x2F;24 (prefix length)<br>代表前24位是网络号</li>
<li>128.208.0.0&#x2F;255.255.255.0 (netmask)这个东西就叫掩码<br>也代表前24位是网络号，具体实现是做与运算<br><img src="https://api2.mubu.com/v3/document_image/e9ab6305-179a-4223-bf8b-e5a56a6b8e16-16175743.jpg" alt="tup "></li>
</ol>
<p>两种方法的对应关系：<br><img src="https://api2.mubu.com/v3/document_image/c64b92f1-7672-47cf-ac59-31551f51cfa9-16175743.jpg" alt="关系"></p>
<h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>有点像指令地址的划分，但又不是平均分的。<br>它是先一分为2，然后把其中一份再一分为2…..这样，根据$log_2(需要的地址数目)向上取整$，来决定怎么划分。<br>就是一个学校有一个网络号，然后拿出几个bit来标记分给不同的院系来使用。<br><img src="https://api2.mubu.com/v3/document_image/6b64d790-7ed2-46a2-b312-2473c2000476-16175743.jpg" alt="这样的"></p>
<p><img src="https://api2.mubu.com/v3/document_image/3cfc998d-0a82-4d16-bf43-0377207fbfec-16175743.jpg" alt="一个例子"></p>
<p>就有点像切西瓜这样，先切一半，然后对其中一半再切。<br>由于全0全1基本不用，所以一般可用地址的数目要-2。<br>比如 8位，$2^8$个不同的数，但是只有$2^8-2$个有效地址。<br>然后可用的地址范围，拿这道题里面的LAN1来说，写1~95是不对的，因为划分范围是7位数的地址，满足大于95，它不一定是连续的，可以这一个用了，下一个不用这样，地址范围是$2^7-2$，然后写可用范围就是</p>
<p>$$<br>   192.168.1.1~192.168.1.126<br>$$</p>
<h4 id="CIDR——无类域间路由（子网划分的逆）"><a href="#CIDR——无类域间路由（子网划分的逆）" class="headerlink" title="CIDR——无类域间路由（子网划分的逆）"></a>CIDR——无类域间路由（子网划分的逆）</h4><p>Route aggregation：路由聚合</p>
<p>多条路由汇聚成一条路由，跟子网划分是完全相反的一个过程。使得路由表长度减少。</p>
<p>而且还比子网划分要简单，就找出来这几个路由的前面多少位是一样的就行了（</p>
<p><img src="https://api2.mubu.com/v3/document_image/d286b872-4f74-4321-a90b-5ae139cce7bf-16175743.jpg" alt="聚合"></p>
<p>但是一个问题是，右边的那几个地址没完全用完，如果不幸出现了下图状况：</p>
<p><img src="https://api2.mubu.com/v3/document_image/821de0b4-2ab4-4747-9b64-55b16c4dc506-16175743.jpg" alt="状况"></p>
<p>就本来应该去san francisco 的就被发到lodon去了。<br>所以路由器匹配的一个基本原则就是<font color=red>“Longest matching prefix routing”</font>最长前缀匹配原则。</p>
<h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>一个array包括[IP address, netmask, outgoing line, Next hop]</p>
<p>扫描路由表：</p>
<ol>
<li>netmask 掩码和目的地址做与运算，然后到表里匹配。</li>
<li>很可能多个都匹配，原则是最长匹配（longest mask）</li>
</ol>
<p>09年一个题<br><img src="https://api2.mubu.com/v3/document_image/47634218-05fb-4475-a67d-a1fb3917824b-16175743.jpg" alt="09年一个题"></p>
<p>根据已知路由表进行路由选择：</p>
<p><img src="https://api2.mubu.com/v3/document_image/79b358f5-fe0d-4082-8ba5-74821d3c3da7-16175743.jpg" alt="route选择"></p>
<h2 id="NAT-Network-address-translation"><a href="#NAT-Network-address-translation" class="headerlink" title="NAT(Network address translation)"></a>NAT(Network address translation)</h2><p>是为了解决ip地址不够用的速战速决的一个临时方法。<br><img src="https://api2.mubu.com/v3/document_image/a078a0c3-e306-4e19-a1c2-2825627247e5-16175743.jpg" alt="nat"><br><img src="https://api2.mubu.com/v3/document_image/a72a44f2-47f8-4492-89a6-45fd94fcc32f-16175743.jpg" alt="nat2"></p>
<h2 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h2><p>128位地址，换算成16字节，可以说是永远用不完了。<br>IPV6的固定头：<br><img src="https://api2.mubu.com/v3/document_image/27efd199-d436-4582-923c-987f0cb77fa0-16175743.jpg" alt="ipv6头"><br><img src="https://api2.mubu.com/v3/document_image/53dd55cf-ad4a-4d45-9329-4ef1112ca503-16175743.jpg" alt="头"><br><img src="https://api2.mubu.com/v3/document_image/9039cc76-2ef8-4701-bd80-1027aa81a849-16175743.jpg" alt="解释"></p>
<p>没有checksum字段了。没有protocol字段了。<br><img src="https://api2.mubu.com/v3/document_image/20074302-05da-4145-8c74-0e28b8cdf64a-16175743.jpg" alt=" "><br>虽然头部精简了很多，但是地址太长了。<br>IPV6还有扩展头，ppt134<br><img src="https://api2.mubu.com/v3/document_image/0c153a46-407e-42c9-bba0-f097b30a8243-16175743.jpg" alt="这样"></p>
<p>IPV6的地址：<br>IPV4是点分16进制，IPV6叫冒分16进制表示法，两个字节一组，分8组。<br><img src="https://api2.mubu.com/v3/document_image/6aa3c2ea-4013-4c3a-9403-18319c9b0003-16175743.jpg" alt="j"><br>下面是3种简化的表示方法。<br>最后那个是v4地址转换成v6地址的方法，前面全0</p>
<h2 id="Internet-控制协议"><a href="#Internet-控制协议" class="headerlink" title="Internet 控制协议"></a>Internet 控制协议</h2><h3 id="ICMP-Internet-Control-Message-Protocol"><a href="#ICMP-Internet-Control-Message-Protocol" class="headerlink" title="ICMP (Internet Control Message Protocol)"></a>ICMP (Internet Control Message Protocol)</h3><p>互联网控制消息协议<br>封装在IP packet里面<br>当路由器处理一个数据报出现了意外，可以通过ICMP向源端报告有关事件<br><img src="https://api2.mubu.com/v3/document_image/8089eea0-c411-4589-92d1-39a33fd3aeb8-16175743.jpg" alt="1"></p>
<p>这里的回显ECHO和回显应答其实就是ping。所以ping是通过ICMP工作的。</p>
<p>关于Trace route<br><img src="https://api2.mubu.com/v3/document_image/abce1be7-0bb5-4de3-9d8d-1f240fd860e0-16175743.jpg" alt=" "></p>
<h3 id="ARP-Address-Resolution-Protocol"><a href="#ARP-Address-Resolution-Protocol" class="headerlink" title="ARP Address Resolution Protocol"></a>ARP Address Resolution Protocol</h3><p>地址解析协议<br>需要ARP的原因：<br><img src="https://api2.mubu.com/v3/document_image/4249195d-368f-41c1-9a72-3a3fcd60947c-16175743.jpg" alt=" "><br><img src="https://api2.mubu.com/v3/document_image/f5e07ad5-bee0-47ad-a1fa-537acda58cc6-16175743.jpg" alt=" "><br>路由表，直接交付与间接交付<br><img src="https://api2.mubu.com/v3/document_image/8f880e18-934d-44f5-b105-3e95b9d3a568-16175743.jpg" alt=" "><br>这里是IPi是ip地址，Ei是mac地址<br><img src="https://api2.mubu.com/v3/document_image/4249195d-368f-41c1-9a72-3a3fcd60947c-16175743.jpg" alt=" "><br><img src="https://api2.mubu.com/v3/document_image/f5e07ad5-bee0-47ad-a1fa-537acda58cc6-16175743.jpg" alt=" "></p>
<p>一个形象的例子：<br><img src="https://api2.mubu.com/v3/document_image/07bb0e82-b88b-4daa-b258-8a5f8c90d867-16175743.jpg" alt=" "></p>
<p>一些优化：</p>
<p>找到目的地址之后还会放在缓存里保存一段时间。设置超时时间或者让每台新加入的机器广播他的映射关系。<br><img src="https://api2.mubu.com/v3/document_image/00b95e76-e204-46e2-8c2a-764cff369ea0-16175743.jpg" alt=" "></p>
<p>ARP 代理：<br><img src="https://api2.mubu.com/v3/document_image/0bdb802d-a7b2-47a3-9d6b-b9d318e188c6-16175743.jpg" alt=" "><br>这个是为了解决早期一些机器的网络掩码不能改变，导致的问题</p>
<h3 id="DHCP-Dynamic-Host-Configuration-Protocol"><a href="#DHCP-Dynamic-Host-Configuration-Protocol" class="headerlink" title="DHCP (Dynamic Host Configuration Protocol)"></a>DHCP (Dynamic Host Configuration Protocol)</h3><p>动态主机配置协议</p>
<p>差不多是完成主机配置初始化这样一个工作，然后是自动完成的。<br><img src="https://api2.mubu.com/v3/document_image/30e67667-1f96-445d-9989-6d911d14d8e9-16175743.jpg" alt=" "><br>关键词：计算机初始接入网络没有IP地址，广播DISCOVER 报文，DHCP 转播助手(relay agent) ，DHCP服务器，IP租赁</p>
<h2 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF (Open Shortest Path First)"></a>OSPF (Open Shortest Path First)</h2><p>开放最短路径优先，是一个普遍使用的 域内路由算法&#x2F;内部网关路由协议 （interior gateway protocol），开放指的是开源。<br><img src="https://api2.mubu.com/v3/document_image/fbf276a7-4c13-4c5b-a85e-18335637e893-16175743.jpg" alt=" "><br>AS（autonomous system）独立网络&#x2F;自治系统</p>
<p>这个图上的(a)给出的就是一个AS<br><img src="https://api2.mubu.com/v3/document_image/ab361f2a-2394-4bbc-9c6a-50279c14186f-16175743.jpg" alt=" "></p>
<p>这个图中LAN是虚拟的节点，是从周边的三个路由器中抽象出来的。<br>工作方式：<br><img src="https://api2.mubu.com/v3/document_image/e4de1067-f5cb-4e4a-a411-6c3c56e15ce5-16175743.jpg" alt=" "></p>
<p>由于OSPF对于规模比较大的网络效率极低，所以需要对区域进行划分。<br><img src="https://api2.mubu.com/v3/document_image/38e72c93-d6f5-4edf-9894-7b034f6afc09-16175743.jpg" alt=" "></p>
<p>OSPF Routers<br><img src="https://api2.mubu.com/v3/document_image/9ec2ad49-1d73-4364-8386-3ee80fc4ad8e-16175743.jpg" alt=" "></p>
<p>5 Types of OSPF Messages</p>
<p>OSPF是使用IP报文承载传送的，IP是不可靠的，尽力而为的报文，丢了就丢了，所以OSPF需要自己确认。RIP（路由信息协议，好像是那个会计数到无穷的）采用的是UDP数据，是不可靠的。<br><img src="https://api2.mubu.com/v3/document_image/8ab8781b-bc60-4246-9eef-d384fa1cdaf5-16175743.jpg" alt=" "><br><img src="https://api2.mubu.com/v3/document_image/199cdcda-15ba-4c32-835d-ac40e73029fe-16175743.jpg" alt=" "></p>
<h2 id="BGP-Border-Gateway-Protocol"><a href="#BGP-Border-Gateway-Protocol" class="headerlink" title="BGP (Border Gateway Protocol)"></a>BGP (Border Gateway Protocol)</h2><p>边界网关协议，是一种外部网关路由协议，或者说是域间路由算法<br>底层是TCP connection  </p>
<p><img src="https://api2.mubu.com/v3/document_image/64253129-478e-489c-a862-1aa532c7dc04-16175743.jpg" alt=" "><br><img src="https://api2.mubu.com/v3/document_image/3dc13f1c-4fb4-4f21-a230-b38fd817604a-16175743.jpg" alt=" "></p>
<h2 id="word-table"><a href="#word-table" class="headerlink" title="word table"></a>word table</h2><blockquote>
<p>Datagram n.【电脑】数据电报<br> optimality 最优性<br> optimal 最理想的，最佳的<br> adaptive a.适应的，适合的<br> estimate 估计，估价，判断，看法<br> datagram 数据报文<br> anew 重新，再<br> virtual circuits 虚拟电路<br> contradict v.矛盾，抵触<br> metric 公制的，米制的，度量标准<br> artificial adj. 人造的, 人工的, 假的<br> duplicate n. 完全一样的东西, 复制品adj. 完全一样的, 复制的<br> obsolete adj. 老式的；废弃的<br> router down：路由器关闭了，再重启可能造成版本低<br> Refinements n. 精致, 高尚, 精巧<br> <strong>Hierarchical</strong> adj. 分等级的，分层次的<br> Congestion 拥挤，拥塞<br> preventive adj. 预防的,防止的<br> reactive adj. 反应的<br> leaky adj. 漏的；有漏洞的<br> imminent adj. 迫近的；即将来临的<br> throttle 节流n&amp;v<br> utilization n. 利用<br> jitter 抖动<br> Round-robin 循环调度<br> flat 平坦的，平的<br> prefix 前缀<br> circumstances 情况，条件<br> out of order 次序颠倒，无次序的<br> hypothesis 假说，假设<br> hierarchy n. 等级制度<br> clusters 丛，簇<br> vicinity 临近，附近<br> consecutive a.连续的<br> aggregate vt. 总计达…vt. &amp; vi. (使)聚集<br> <mark>NIC</mark> 网卡 Network Interface Card<br> <mark>ISP</mark>一般指网络业务提供商 Internet Service Provider</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>交换原理三、四章</title>
    <url>/2023/03/22/%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86notes2/</url>
    <content><![CDATA[<h2 id="chapter3-电话交换"><a href="#chapter3-电话交换" class="headerlink" title="chapter3-电话交换"></a>chapter3-电话交换</h2><p>侧音：打电话时候能听到自己的声音</p>
<p>脉冲拨号方式：三个参数</p>
<ul>
<li>脉冲速度：表示拨号盘每秒钟发生的脉冲个数</li>
<li>脉冲断续比：在一个脉冲周期里，断开电流时间和接通点六世纪之比</li>
<li>位间隔：&gt;&#x3D;350ms</li>
</ul>
<p>DTMF拨号方式：<br>拨号集成器发出的是双音频指令</p>
<h3 id="3-2程控数字交换机的结构"><a href="#3-2程控数字交换机的结构" class="headerlink" title="3.2程控数字交换机的结构"></a>3.2程控数字交换机的结构</h3><p><img src="https://api2.mubu.com/v3/document_image/352a3dc4-5876-4609-8cd2-525c5c16fd2c-16175743.jpg" alt="2"></p>
<p><img src="https://api2.mubu.com/v3/document_image/01a50489-ea3e-4400-8052-a1715f707401-16175743.jpg" alt="2"></p>
<p>结构树：</p>
<p>数字程控电话交换系统</p>
<ul>
<li>话路子系统<ul>
<li>接口设备<ul>
<li>模拟用户电路 BORSCHT</li>
<li>数字中继器 <font size=1>码型变换，帧同步，再定时，时钟提取，信令插入</font></li>
<li>信令设备<font size=1>音信号发生器，DTMF接收器</font></li>
</ul>
</li>
<li>交换网络TST</li>
</ul>
</li>
<li>控制子系统<ul>
<li>CPU与存储器</li>
<li>外部设备</li>
<li>远程端口</li>
</ul>
</li>
</ul>
<h3 id="3-3接口设备"><a href="#3-3接口设备" class="headerlink" title="3.3接口设备"></a>3.3接口设备</h3><h4 id="数字程控交换机的接口类型"><a href="#数字程控交换机的接口类型" class="headerlink" title="数字程控交换机的接口类型"></a>数字程控交换机的接口类型</h4><h4 id="用户电路"><a href="#用户电路" class="headerlink" title="用户电路"></a>用户电路</h4><p>用户电路功能：BORSCHT</p>
<ul>
<li>B馈电（Battery feeding）：向用户提供直流馈电电流，电压-48V。<br>电容：通交阻直<br>电感：通直阻交</li>
<li>O过压保护（Overvoltage protection）：二极管用于钳制电压，无论外线电压高于或低于内线，都会由二极管钳制内线为-48V，R 为热敏电阻，可自行烧毁。</li>
<li>R振铃控制（Ringing control）：控制是否向用户线发送 25Hz 铃流信号。</li>
<li>S监视（Supervision）：监视用户环路的通断状态，通过电阻的直流压降得知用户是否摘机。</li>
<li>C编译码和滤波（CODEC&amp;filters）：模拟话音信号与 64Kbps 数字话音信号转换。对模拟信号进行编码、对数字信号进行解码；为避免混叠失真、50Hz 干扰、3400Hz 以上频率分量，进行滤波。</li>
<li>H混合电路（Hybrid circuit）：在用户话机的 2 线双向信号和 PCM 的 4 线单向信号之间进行 2&#x2F;4 转换。（发生在编码之前和译码之后）</li>
<li>T测试（Test）：控制是否进行内外线的故障检测。</li>
</ul>
<blockquote>
<p>用户摘机：<br>BOSC<br>其他功能：<br>主叫号码显示<br>极性倒转<br>计费脉冲发送</p>
</blockquote>
<h4 id="中继电路"><a href="#中继电路" class="headerlink" title="中继电路"></a>中继电路</h4><p>中继电路是交换机和中继线的接口设备,也叫做中继器。<br>交换机的中继电路有数字中继电路和模拟中继电路。本节重点介绍数字中继电路。</p>
<p>数字中继电路是连接局间数字中继线的接口设备,用于与数字交换局或远端用户模块相连。</p>
<p>数字中继电路</p>
<ol>
<li>码型变换<br>由于PCM线上使用的传输码型与交换网络内部的码型不同,码型变换的任务就是在接收和发送方向完成这两种码型的相互转换。</li>
<li>帧同步<br>数字中继线上的PCM信号是以帧方式传输的<br>其帧格式为：<br><img src="https://api2.mubu.com/v3/document_image/9aae7a70-1b0e-497c-9703-d820b9bd5762-16175743.jpg" alt="frame"><br>帧同步就是从接收的数据流中搜索并识别到帧同步码,以确定一帧的开始,使接收端的帧结构排列和发送端的完全一致,从而保证数字信息的正确接收。帧同步码0011011在PCM偶帧的 TS0中。</li>
<li>复帧同步<br>如果数字中继线上采用的是随路信令(中国No.1信令),则除了帧同步外,还要有复帧同步。<br>PCM的1个复帧由16个帧组成。复帧同步是使接收端与发送端的复帧结构排列完全一致。在随路信令方式中,各话路的线路信令在一个复帧的TS中的固定位置传送,如果复帧不同步,线路信令就会错路。复帧同步就是为了保证各路线路信令不错路。<br>复帧同步码在F(复帧的第1个帧)的TS,的高4个比特中传送,码字为0000。</li>
<li>时钟提取<br>从输人的数据流中提取时钟信号,以便与远端的交换机保持同步。</li>
<li>提取和插入信号<br>提取和插入的信号主要包括帧同步信号、复帧同步信号和告警信息的插入与提取</li>
<li>帧定位（再定时）</li>
</ol>
<p>数字音频信号</p>
<p>交换机——&gt;用户和其他交换局:拨号音、回铃音、MFC信号<br>用户——&gt;交换机：DTMF信号,MFC信号<br>交换机——&gt;交换机：当局间采用中国No.1信令时,交换机到交换机之间发送和接收的是局间多频互控(MFC)信号。</p>
<p>用户向交换机发送的信号主要是被叫号码,它包括两种形式</p>
<ol>
<li>直流脉冲</li>
<li>双音多频(DT-MF)</li>
</ol>
<p>直流脉冲一般采用软件收号,也叫做软收号,DTMF采用DTMF收号器来接收。</p>
<p>通过上述分析可知,交换机应具备音频信号接口,既能产生单音频和双音频的信号,也应能接收双音频的信号。无论是信号音还是DTMF和 MFC信号,都是音频模拟信号。</p>
<p>单音频信号产生的基本原理:<br>按照PCM编码原理,将信号按125 us间隔进行抽样(也就是8kHz的抽样频率),然后进行量化和编码,得到各抽样点的PCM信号值,按照顺序将其放到ROM中,在需要的时候按序读出。<br><img src="https://api2.mubu.com/v3/document_image/0b2720bb-67e0-40ac-a42a-aac37c36a289-16175743.jpg" alt="dan"></p>
<h3 id="3-4话路建立"><a href="#3-4话路建立" class="headerlink" title="3.4话路建立"></a>3.4话路建立</h3><h4 id="复用器与分路器"><a href="#复用器与分路器" class="headerlink" title="复用器与分路器"></a>复用器与分路器</h4><blockquote>
<p>关于为什么要有复用器和分路器：<br>PCM信号传输采用串行码,即一个时隙的8位码在一条线路上串行传输,而T接线器的话音存储器字长一般为8位,其写入和读出是以字长为单位进行的,即8位码并行同时写入或读出。数字程控交换系统的交换网络–般由T接线器或T和S接线器组合构成的,因此当话音信号进入交换网络交换时,先要将串行码转换为并行码,这个过程叫做串并变换;</p>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/a2bdbb88-147a-454c-acaa-6a473a2a339d-16175743.jpg" alt="3"></p>
<p>若进入每个复用器的PCM线路数为4，且每条PCM线路速率为2048kbit&#x2F;s<br>则①点速率为2048 kbit&#x2F;s,传输信号为串行码;<br>②点速率为256 kbit&#x2F;s,传输信号为8位并行码;这个是用2048&#x2F;8得到的，它速率看的是一条线上的速率，经过串并变换之后，一条线变成了同时前进的8条线，速率变为原本的1&#x2F;8.<br>③点速率为1024 kbit&#x2F;s,传输信号为8位并行码。这是用256*4得到的，因为原本是四路8位并行线路，复用合成一路了，不过还是8位并行，</p>
<p><img src="https://api2.mubu.com/v3/document_image/2010a491-f9c4-4127-9368-af9e55333b01-16175743.jpg" alt="1dian"><br><img src="https://api2.mubu.com/v3/document_image/d5097361-c14c-4bc5-993a-89fa6efe42cb-16175743.jpg" alt="2dian"><br><img src="https://api2.mubu.com/v3/document_image/32bb88a3-6064-4707-9925-8becda211fcd-16175743.jpg" alt="3dian"></p>
<h4 id="话路建立-细"><a href="#话路建立-细" class="headerlink" title="话路建立( 细)"></a>话路建立( 细)</h4><p>&lt;这块儿是重点&gt;<br><img src="https://api2.mubu.com/v3/document_image/14cf252d-72a4-4bdb-981f-97aa21e992c7-16175743.jpg" alt="2"><br><img src="https://api2.mubu.com/v3/document_image/c61bb621-118c-4f2e-b321-ead144ec3611-16175743.jpg" alt="p1"><br><img src="https://api2.mubu.com/v3/document_image/a7071137-31d6-4ef8-9f05-e7b32eb2bed3-16175743.jpg" alt="p2"></p>
<p>关于：</p>
<ol>
<li>TS8-&gt;TS16:2*8+0</li>
<li>TS20和TS52的关系：52&#x3D;20+64&#x2F;2</li>
<li>TS20为什么要换到TS10：5*2+0&#x3D;10</li>
<li>进入T交换器的PCM是64路：两个32路复用</li>
</ol>
<h3 id="3-5控制子系统"><a href="#3-5控制子系统" class="headerlink" title="3.5控制子系统"></a>3.5控制子系统</h3><h4 id="程控交换机对控制系统的基本要求"><a href="#程控交换机对控制系统的基本要求" class="headerlink" title="程控交换机对控制系统的基本要求"></a>程控交换机对控制系统的基本要求</h4><ol>
<li>呼叫转移能力</li>
<li>高可靠性</li>
</ol>
<p>系统开销&#x3D;固有开销+非固有开销</p>
<p>$t&#x3D;a+bN$<br>t:系统开销<br>a:固有开销<br>b:交换机控制系统处理一次呼叫的非固有开销（avg）<br>N:单位时间内处理的呼叫次数（呼叫处理能力，BHCA）</p>
<blockquote>
<p>通常用最大忙时试呼次数(BHCA: maximum number of busy hour call attempts)来表示程控交换机的呼叫处理能力,即在单位时间内控制系统能够处理的呼叫次数。</p>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/4a71ddf2-4076-40a2-bc47-29c679df6519-16175743.jpg" alt="bhca"></p>
<p>如果在一个有效的时间间隔周期内(不包含峰值瞬间),出现在交换设备上的试呼次数,即话务负荷超过了交换机控制系统的设计处理能力时,则称该交换设备运行在过负荷状态。</p>
<h4 id="控制系统（概念掌握）"><a href="#控制系统（概念掌握）" class="headerlink" title="控制系统（概念掌握）"></a>控制系统（概念掌握）</h4><p>控制方式</p>
<ol>
<li>集中控制<br>集中控制是指处理机可以对交换系统内的所有功能及资源实施统一控制。该控制系统可以由多个处理机构成,每一个处理机均可控制整个系统的正常运作。<br><img src="https://api2.mubu.com/v3/document_image/ea856ef2-ccb8-4197-87fe-ee8cce22259f-16175743.jpg" alt="2"><ul>
<li>处理机直接控制所有功能的完成和资源的使用，因此控制关系简单，处理机间通信接口简单。</li>
<li>单个处理机上的应用软件复杂、庞大。</li>
<li>一旦处理机系统故障，整个控制系统失效。可靠性较低。</li>
</ul>
</li>
<li>分散控制<br>分散控制是指对交换机所有功能的完成和资源使用的控制由多个处理机分担完成的,即每个处理机只完成交换机的部分功能及控制部分资源。<br><img src="https://api2.mubu.com/v3/document_image/a980733d-e112-47bf-a9e5-086eb6dac110-16175743.jpg" alt="2"><ol>
<li>全分散控制<br>各个处理机之间独立工作，分别完成不同功能并对不同资源实施控制。<ul>
<li>处理机之间不分等级，不存在控制与被控制关系。</li>
<li>每台处理机只完成部分功能，要求各处理机协调配合完成整个系统功能，通信接口复杂。</li>
<li>每台处理机应用软件只完成该处理机承担的功能，较为简单。</li>
<li>可靠性较高。</li>
<li>系统具有良好的扩充能力。</li>
</ul>
</li>
<li>分级分散控制<br>控制系统由多个处理机构成，分别完成不同功能并对不同资源实施控制。<ul>
<li>处理机之间分等级，高级别处理机控制低级别处理机。</li>
<li>处理机之间通信接口较为集中，控制方式复杂，但比全分散简单。</li>
<li>各处理机上应用软件复杂程度适中。</li>
<li>控制系统的可靠性适中。<br> <img src="https://api2.mubu.com/v3/document_image/575d0c8d-6d72-473d-b5e8-a5509e399095-16175743.jpg" alt="2"></li>
</ul>
</li>
</ol>
</li>
</ol>
<p>多处理机之间的工作分担方式：</p>
<ul>
<li>功能分担：多个处理机分别完成同一话务的不同功能（A 处理机和 B 处理机）。</li>
<li>负荷（话务）分担：多个处理机各自完成一部分话务功能（A 处理机和 A 处理机）。</li>
</ul>
<p>多处理机的可靠性（冗余方式）：</p>
<ul>
<li>双机冗余配置：两套处理机系统，一个主用、一个备用。<ul>
<li>同步方式：主备用机同步工作，同时执行指令并比较结果。</li>
<li>互助方式：主备用机负荷均分，分别承担一半话务负荷。一台机器故障，负荷全部转移到另一台机器上。</li>
<li>主备用方式：主机在线运行，备用机处于待机状态。（冷备用：不保存动态呼叫数据，故障切换时直接呼损。热备用：保存动态呼叫数据，故障切换时不会呼损。一般采用热备用。）</li>
</ul>
</li>
<li>N+m 备份：N 个处理机在线运行，m 个处理机处于备用状态。</li>
</ul>
<h3 id="3-6程控交换软件技术"><a href="#3-6程控交换软件技术" class="headerlink" title="3.6程控交换软件技术"></a>3.6程控交换软件技术</h3><p>SDL</p>
<p><img src="https://api2.mubu.com/v3/document_image/16800621880734dbc.jpg" alt="1"></p>
<p><img src="https://api2.mubu.com/v3/document_image/887223f6-1170-48d0-b650-efd4f187aba9-16175743.jpg" alt="sdl"></p>
<h2 id="chapter4-分组交换"><a href="#chapter4-分组交换" class="headerlink" title="chapter4-分组交换"></a>chapter4-分组交换</h2><h3 id="5-1-分组交换技术的产生与发展"><a href="#5-1-分组交换技术的产生与发展" class="headerlink" title="5.1 分组交换技术的产生与发展"></a>5.1 分组交换技术的产生与发展</h3><h3 id="5-2分组交换的基本原理"><a href="#5-2分组交换的基本原理" class="headerlink" title="5.2分组交换的基本原理"></a>5.2分组交换的基本原理</h3><p>5.2.1 分组传送方式<br>5.2.2分组的形成<br>5.2.3 分组交换方式<br>5.2.4路由选择<br>5.2.5流量控制</p>
<h3 id="5-3-分组交换协议——X-25协议"><a href="#5-3-分组交换协议——X-25协议" class="headerlink" title="5.3 分组交换协议——X.25协议"></a>5.3 分组交换协议——X.25协议</h3><p>5.3.1 分组交换协议5.3.2 X.25物理层<br>5.3.3X.25数据链路层——LAPB<br>5.3.4 X.25分组层</p>
<h3 id="5-4分组交换机"><a href="#5-4分组交换机" class="headerlink" title="5.4分组交换机"></a>5.4分组交换机</h3><p>5.4.1 分组交换机的基本结构<br>5.4.2分组交换机的性能指标<br>5.4.3 DPN-100分组交换机</p>
<h3 id="5-5-分组交换网"><a href="#5-5-分组交换网" class="headerlink" title="5.5 分组交换网"></a>5.5 分组交换网</h3><p>5.5.1分组交换网的构成<br>5.5.2 分组交换网的工作原理<br>5.5.3 中国公用分组交换<br>5.5.4网络编号——X.1215.5.5网间互连</p>
<h3 id="5-6帧中继"><a href="#5-6帧中继" class="headerlink" title="5.6帧中继"></a>5.6帧中继</h3><p>5.6.1帧中继技术的发展与应用<br>5.6.2帧中继技术的特点<br>5.6.3 帧中继协议<br>5.6.4帧中继交换机小结</p>
]]></content>
      <categories>
        <category>笔记 - 交换原理</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>交换原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux笔记</title>
    <url>/2023/02/23/Linux/</url>
    <content><![CDATA[<p>大致是跟着老师上课的顺序写的，用于上课摸鱼时安慰一下自己QwQ</p>
<h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><h3 id="1-1-Linux发展过程"><a href="#1-1-Linux发展过程" class="headerlink" title="1.1 Linux发展过程"></a>1.1 Linux发展过程</h3><p>略，课件里的八卦部分可以抽空看</p>
<h3 id="1-2系统登录与退出"><a href="#1-2系统登录与退出" class="headerlink" title="1.2系统登录与退出"></a>1.2系统登录与退出</h3><h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><p>称为tty是因为电传打字机 teletypewriter</p>
<p>历史：</p>
<ol>
<li>typewriter</li>
<li>teletypewriter 简称tty</li>
<li>字符终端，就带屏幕的那种</li>
</ol>
<p>组成：</p>
<ol>
<li>键盘</li>
<li>显示屏</li>
<li>接口RS232串行通信接口（用于主机与终端的连接）</li>
</ol>
<h4 id="行律"><a href="#行律" class="headerlink" title="行律"></a>行律</h4><p>（是之前不知道的东西耶）</p>
<p>line discipline，缓存、回显、编辑（比如backspace）、转换换行符\n为\r\n、<br>行律的调整：<br>stty</p>
<ul>
<li>stty erase ^H 另^H可以擦除一个字符，起到backspace的功能</li>
<li>stty -a 显示行律的所有控制信息</li>
</ul>
<h4 id="终端转义序列"><a href="#终端转义序列" class="headerlink" title="终端转义序列"></a>终端转义序列</h4><p>转义字符：ESC ASCII码是1B，十进制的16+11&#x3D;27</p>
<p>&#x3D;&#x3D;主机给重点方向发数据&#x3D;&#x3D;转义序列的功能：</p>
<ol>
<li>控制光标位置、字符颜色、大小</li>
<li>选择终端的字符集</li>
<li>控制终端上的打印机、刷卡机、磁条器、密码键盘</li>
</ol>
<p><img src="https://api2.mubu.com/v3/document_image/fd57507b-f87f-448d-ae64-1ff72ea4a572-16175743.jpg" alt="0"></p>
<h4 id="主机和终端之间的流量控制问题"><a href="#主机和终端之间的流量控制问题" class="headerlink" title="主机和终端之间的流量控制问题"></a>主机和终端之间的流量控制问题</h4><p>两种流控方式</p>
<ol>
<li>硬件<br>RS232接口的CTS信号线 Clear to send</li>
<li>软件<br>流控字符 Xon 和 Xoff<br><img src="https://api2.mubu.com/v3/document_image/6cc2142c-45c0-4e69-a5a1-7034b7735bc6-16175743.jpg" alt="1"></li>
</ol>
<h4 id="仿真终端和虚拟终端"><a href="#仿真终端和虚拟终端" class="headerlink" title="仿真终端和虚拟终端"></a>仿真终端和虚拟终端</h4><p>仿真：仿真软件来模拟中端</p>
<p>虚拟：是远程连接的那种，比如xshell</p>
<h4 id="Shell提示符"><a href="#Shell提示符" class="headerlink" title="Shell提示符"></a>Shell提示符</h4><p><img src="https://api2.mubu.com/v3/document_image/d40d4ed9-ba5f-47c6-a474-8e4533f55f20-16175743.jpg" alt="2"></p>
<h4 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h4><p>在关机前必须执行关机命令shutdown,仅特权用户有此权限。</p>
<p>死机：</p>
<ul>
<li>Unix系统稳定，应用程序不该导致死机</li>
<li>死机现象是由于系统内核态程序有问题，常常是一些外设的驱动程序有BUG</li>
</ul>
<h3 id="1-3-使用系统命令"><a href="#1-3-使用系统命令" class="headerlink" title="1.3 使用系统命令"></a>1.3 使用系统命令</h3><ul>
<li><p>man</p>
<ul>
<li>查阅手册</li>
<li>manual</li>
<li>man name</li>
<li>man section name<ul>
<li>1：命令</li>
<li>2：系统调用</li>
<li>3：库函数</li>
<li>5：配置文件</li>
</ul>
</li>
<li>man -k regexp 列出关键字keyword与正则表达式regexp匹配的手册项</li>
</ul>
</li>
<li><p>date</p>
<ul>
<li>date “+%Y-%m-%d %H:%M:%S Day %j”</li>
<li>date “+%s” 秒坐标，常用于计算时间间隔</li>
<li>通过NTP协议校对系统：ntpdate -q 0.pool.ntp.org(查询)</li>
<li>ntpdate 0.pool.ntp.org(设置)</li>
<li>效果：<img src="https://api2.mubu.com/v3/document_image/933a84a9-b863-4d0a-b84c-ec4c889ca9a8-16175743.jpg" alt="1"></li>
</ul>
</li>
<li><p>cal 打印日历</p>
<ul>
<li>cal 2023</li>
<li>cal 10 2023</li>
</ul>
</li>
<li><p>bc 计算器</p>
<ul>
<li>基本的计算器的功能，支持变量函数条件循环等编程功能</li>
<li><strong>可以进行任意精度的计算</strong></li>
<li>缺省为小数点后0位</li>
<li>-l参数是20位</li>
</ul>
</li>
<li><p>passwd 修改口令（密码）</p>
<ul>
<li>root可以直接改</li>
<li>其他用户需要先输入当前口令</li>
<li>修改超级用户的口令需要很谨慎捏</li>
<li>关于口令的存储：<img src="https://api2.mubu.com/v3/document_image/4cde873f-ff30-45ee-95c8-dca743ffa29d-16175743.jpg" alt="2"></li>
</ul>
</li>
<li><p>who 列出当前已经等登录入系统的用户</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/f2ed2e24-cda4-41a7-b163-55f3f89ee2e5-16175743.jpg" alt="3"></li>
</ul>
</li>
<li><p>tty 打印出当前终端的设备文件名</p>
</li>
<li><p>who am i 当前终端上的登录用户</p>
</li>
<li><p>whoami 仅列出当前用户名，脚本程序会用到</p>
</li>
<li><p>uptime 已经开机的时间</p>
<ul>
<li>关于loda average：<img src="https://api2.mubu.com/v3/document_image/e1eec1e6-839d-4dff-b620-665695f4a07a-16175743.jpg" alt="4"></li>
</ul>
</li>
<li><p>top 列出资源占用排名靠前的进程</p>
</li>
<li><p>w命令 列出终端的空闲时间IDLE、JCPU、PCPU、WHAT（）</p>
</li>
<li><p>ps 进程信息的一次性快照 process status</p>
</li>
<li><p>ps -ef 可以打出来很多信息<img src="https://api2.mubu.com/v3/document_image/12c78658-82c8-45d1-a05f-b2e6c0e72da2-16175743.jpg" alt="ppid"><br>PPID是父进程的id</p>
</li>
<li><p>free 检查系统内存使用情况</p>
</li>
<li><p>vmstat 检查系统负载<img src="https://api2.mubu.com/v3/document_image/1ab28fa9-6906-4444-82de-a4fbc93584c6-16175743.jpg" alt="vmstat"></p>
</li>
<li><p>UTF8和GBK</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">echo $LANG</span><br></pre></td></tr></table></figure>

<p><img src="https://api2.mubu.com/v3/document_image/4bec4219-173e-47c0-bd9c-f1b55d4aca5d-16175743.jpg" alt="echo"></p>
</li>
<li><p>iconv 转换文件的编码方式</p>
<ul>
<li>-f from</li>
<li>-t to</li>
<li>ex:<blockquote>
<p>iconv -f gbk -t utf8 inputFile.txt -o outputFile.txt.utf8</p>
</blockquote>
</li>
</ul>
</li>
<li><p>bc 计算器</p>
<ul>
<li>默认精度是小数点后0位</li>
<li>-l 缺省精度位小数点后20位</li>
<li>功能非常复杂和强大<ul>
<li>支持数学函数库、变量、循环等编程功能</li>
<li>可以进行任意精度的计算，可以通过设置scale自行决定小数点位数</li>
</ul>
</li>
</ul>
</li>
<li><p>wall write to all 给所有人都发消息</p>
</li>
</ul>
<h2 id="Chapter2-文本文件及处理工具"><a href="#Chapter2-文本文件及处理工具" class="headerlink" title="Chapter2 文本文件及处理工具"></a>Chapter2 文本文件及处理工具</h2><p>实现ls -l的输出作为sort程序的输入来执行：</p>
<ul>
<li>重定向机制<ul>
<li>ls -l &gt; file.txt</li>
<li>sort &lt; file.txt</li>
</ul>
</li>
<li>管道机制<ul>
<li>ls -l | sort</li>
</ul>
</li>
</ul>
<h3 id="2-2读取文件内容"><a href="#2-2读取文件内容" class="headerlink" title="2.2读取文件内容"></a>2.2读取文件内容</h3><ul>
<li>more&#x2F;less 逐屏显示文件</li>
<li>cat concatenate 串结，文本格式打印 （选项-n：行号）</li>
<li>od octal dump 逐字节打印，默认是octal八进制（-c, -t c, -t x1，-t d1, -t u1选项）</li>
<li>head&#x2F;tail 显示文件的头部或者尾部</li>
<li>tee 三通，将从标准输入stdin得到的数据抄送到标准输出stdout显示，同时存入磁盘文件中</li>
<li>wc 字计数（word count）<ul>
<li>列出文件中一共有多少行，有多少个单词，多少字符</li>
<li>当指定的文件数大于1时，最后还列出一个合计</li>
<li>常用选项-l：只列出行计数</li>
<li><img src="https://api2.mubu.com/v3/document_image/88190d8c-581e-42fe-a25a-d31d6b148b8e-16175743.jpg" alt="2"></li>
</ul>
</li>
<li>sort 对文件内容排序</li>
<li>tr 翻译字符,其实严格来说是替换<img src="https://api2.mubu.com/v3/document_image/43c301ef-3614-47a7-bfa9-e0e67d8626d7-16175743.jpg" alt="2"><br><img src="https://api2.mubu.com/v3/document_image/77f75fa6-ae88-4d39-8f91-bd0675c027d8-16175743.jpg" alt="2"></li>
<li>uniq</li>
</ul>
<h3 id="2-3-正则表达式及应用"><a href="#2-3-正则表达式及应用" class="headerlink" title="2.3 正则表达式及应用"></a>2.3 正则表达式及应用</h3><p>Regular Expressions</p>
<blockquote>
<p>&#x2F;:slice 斜杠<br> :back slice 反斜杠<br> “人”</p>
</blockquote>
<h4 id="单字符正则表达式"><a href="#单字符正则表达式" class="headerlink" title="单字符正则表达式"></a>单字符正则表达式</h4><ul>
<li>非特殊字符，匹配自身</li>
<li>转义字符 ‘ \ ‘<br><mark>\.</mark>  <mark>\*</mark> <mark>\$</mark> <mark>\^</mark> <mark>\[</mark> <mark>\&lt;&#x2F;mark&gt;</li>
<li>圆点 ‘ . ‘ 匹配任意单字符</li>
<li>星号 ‘ * ‘：单字符正则表达式后跟*，匹配此单字符正则表达式的0次或任意多<br>次出现</li>
<li>定义集合<ul>
<li>在<strong>一对方括号之间</strong>的字符为集合的内容:单字符正则表达式[abcd]与a或b,c,d匹配</li>
<li><strong>圆点,星号,反斜线</strong>在方括号内时，代表它们自己::[\*.]可匹配3个单字符</li>
<li>用减号-定义一个区间（要在中间）:如[a-d] [A-Z] [a-zA-Z0-9]</li>
<li>用 ^ 表示补集(要在开头):<strong>[^a-z]</strong> 匹配任一非小写字母，**[^ ][ ]** 匹配任一非中括号字符</li>
</ul>
</li>
<li>锚点： $ 和 ^<ul>
<li>$ 在尾部时有特殊意义，否则与其自身匹配<ul>
<li>123$ 匹配文件中行尾的123，不在行尾的123</li>
</ul>
</li>
<li>^ 在首部时有特殊意义，否则与其自身匹配<ul>
<li>^printf匹配行首的printf字符串，不在行首的printf串不匹配</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="正则表达式扩展"><a href="#正则表达式扩展" class="headerlink" title="正则表达式扩展"></a>正则表达式扩展</h4><p><img src="https://api2.mubu.com/v3/document_image/2512c854-800d-4855-84a3-2f73836db3db-16175743.jpg" alt="2"></p>
<h3 id="文本行筛选"><a href="#文本行筛选" class="headerlink" title="文本行筛选"></a>文本行筛选</h3><h4 id="grep-在文件中查找字符串"><a href="#grep-在文件中查找字符串" class="headerlink" title="grep:在文件中查找字符串"></a>grep:在文件中查找字符串</h4><p>grep（Global regular expression print）</p>
<p>grep 模式 文件名列表</p>
<p>例子：<br><img src="https://api2.mubu.com/v3/document_image/0cd5299c-e6e1-40ee-ac5f-9e3bf1ea46f1-16175743.jpg" alt="2"></p>
<p>选项</p>
<ul>
<li>-n 显示时每行前面显示行号</li>
<li>-v 显示所有不包含模式的行</li>
<li>-i 字母比较时忽略字母的大小写</li>
</ul>
<h4 id="流编辑及正则表达式替换"><a href="#流编辑及正则表达式替换" class="headerlink" title="流编辑及正则表达式替换"></a>流编辑及正则表达式替换</h4><p>sed：流编辑</p>
<ul>
<li>sed ‘命令’ 文件名列表</li>
<li>sed –e ‘命令1’ –e ‘命令2’ –e ‘命令3’ 文件名列表</li>
<li>sed -f 命令文件 文件名列表</li>
</ul>
<p>一对斜线 &#x2F; &#x2F; 之内的部分为正则表达式<br><img src="https://api2.mubu.com/v3/document_image/7d4abf3b-0a17-4574-bf98-af2c5ee52c4c-16175743.jpg" alt="2"></p>
<p><img src="https://api2.mubu.com/v3/document_image/7c4e99bd-af91-4fdf-a592-8152a4124fb2-16175743.jpg" alt="3"></p>
<h4 id="复杂筛选及加工awk"><a href="#复杂筛选及加工awk" class="headerlink" title="复杂筛选及加工awk"></a>复杂筛选及加工awk</h4><p>awk：逐行扫描进行文本处理,是逐行扫描进行文本处理的一门语言，a.w.k分别为该程序的三位设计者姓氏的第一个字母</p>
<ul>
<li>awk ‘程序’ 文件名列表</li>
<li>awk -f 程序文件名 文件名列表</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/c1ea06fe-a4e5-4c0b-98bf-a47062351fd9-16175743.jpg" alt="3"></p>
<p>$数字 指的是第几列。</p>
<h4 id="sed和awk的区别"><a href="#sed和awk的区别" class="headerlink" title="sed和awk的区别"></a>sed和awk的区别</h4><ul>
<li>sed：每次读入一行来处理的，sed 适合简单的文本替换和搜索，sed读取一行，以行作为单位，进行处理。</li>
<li>awk：每次读入一行来处理的（同sed），但awk读取一行，切割成字段，以字段（列）为单位，进行细节处理。</li>
<li>如果文件是格式化的，即由分隔符分为多个域的，优先使用awk。</li>
<li>awk适合对文件的抽取整理，sed适合对文件的编辑。</li>
<li>awk适合按列（域）操作，sed适合按行操作。</li>
</ul>
<h3 id="文件对比"><a href="#文件对比" class="headerlink" title="文件对比"></a>文件对比</h3><ul>
<li>CMP<ul>
<li>cmp命令逐个字节比较两个文件是否完全相同，两个文件完全相同时，不给出任何提示。当两个文件不同时，打印出第一个不同之处。这个命令常用来判断两个文件的内容是否完全一致，无论是ASCII码文件还是二进制格式的程序或数据文件。在Windows中有类似的命令COMP。</li>
</ul>
</li>
<li>diff<ul>
<li>许多读者使用过Windows下类似功能的FC命令(File Comparison)。UNIX用于完成这项功能的命令是diff。无论是Windows的FC命令，还是UNIX的diff命令，都可以逐行比较包括源程序文件在内的任意内容的文本格式文件。Windows的FC命令使用时经常需要&#x2F;N选项，在列出文本文件行时打印行号。</li>
<li>命令diff file1 file2每发现两个文件中的一处不同，就列出一个如何将f1.c转化为f2.c的指令，这些指令有a(Add)，c(Change)和d(Delete)</li>
<li><img src="https://api2.mubu.com/v3/document_image/d2b4adaf-3838-430a-8c83-99acdff1b875-16175743.jpg" alt="diff"></li>
</ul>
</li>
</ul>
<blockquote>
<p>diff -u 的输出格式和git相同，而不是normal格式<br>normal 列出将file1转化为file2的指令</p>
</blockquote>
<h3 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">:set number:每行左边显示行号</span><br><span class="line">:set tabstop=4 制表符位置为4格对齐</span><br></pre></td></tr></table></figure>

<p><strong>命令前加一整数，表示这个命令连续执行多少遍</strong>，这句话针对很多命令都有效，比如5j（光标下移五行）、6ctrl-b（向前翻六页）</p>
<p>编辑命令 i a 等，可以从命令状态转到文本状态</p>
<blockquote>
<p>i是insert a是append</p>
</blockquote>
<p>光标移动：</p>
<ul>
<li>上下左右<ul>
<li>h 光标左移一列</li>
<li>j 光标下移一行</li>
<li>k 光标上移一行</li>
<li>l 光标右移一列</li>
<li>一般可以直接使用键盘上的方向键代替这四个字母</li>
</ul>
</li>
<li>行尾行首<ul>
<li>将光标移至当前行首 ^</li>
<li>将光标移至当前行尾 $</li>
</ul>
</li>
<li>移动一个单词<ul>
<li>移到右一个单词 w</li>
<li>移到左一个单词 b</li>
</ul>
</li>
<li>移到指定的行<ul>
<li><code>:45</code>移动到45行</li>
<li><code>:$</code>将光标置于文件尾</li>
<li><code>:.+10</code> 当前行号+10</li>
<li><code>:$-5</code> 倒数第五行</li>
</ul>
</li>
<li>括号配对<ul>
<li>把光标移到一个花括号(或圆括号，或方括号)上，按%键，则光标自动定位到与它配对的那一个括号</li>
</ul>
</li>
<li><code>x</code>删除当前字符，or<code>5x</code> 删除当前五个字符，这个好像相当于剪切命令，在x之后可以使用p来粘贴刚刚剪切的行。</li>
<li>删除行<ul>
<li>删除当前行的命令 dd</li>
</ul>
</li>
<li>替换光标处字符 r<ul>
<li>将当前光标处开始的三个字符依次替换为abc，则需要按命令rarbrc</li>
</ul>
</li>
<li>取消上一次的编辑操作(undo)<mark> u </mark>。</li>
<li>重复上一次的编辑操作<mark> . </mark>。</li>
</ul>
<p>翻页：</p>
<ul>
<li>Ctrl-b 向后翻页(Backward)</li>
<li>Ctrl-f 向前翻页(Forward)</li>
</ul>
<p>文件操作命令</p>
<ul>
<li>存盘退出:<code>ZZ(大写)</code>&#x3D;&#x3D;<code>wq</code></li>
<li>读入文件xyz.c插入到当前行之下 <code>:r xyz.c&lt;CR&gt;</code></li>
<li>写文件,把第50行至文件尾的内容写到文件file1中 <code>:50,$w file1&lt;CR&gt;</code></li>
</ul>
<p>剪切板</p>
<ul>
<li>删除，并拷贝到剪贴板<ul>
<li><code>:10,50d&lt;CR&gt;</code> 删除第10-50行</li>
<li><code>:1,.d&lt;CR&gt;</code> 删除文件首至当前行的部分</li>
<li><code>:.,$d&lt;CR&gt;</code> 删除当前行到文件尾</li>
</ul>
</li>
<li>不删除，拷贝到剪贴板(yank)</li>
<li>粘贴剪贴板信息（paste）</li>
</ul>
<p>块儿操作</p>
<ul>
<li>复制：<code>:5,10co56&lt;CR&gt;</code>复制第5-10行到第56行之下</li>
<li>移动:<code>:8,34m78&lt;CR&gt;</code>移动第8-34行到第78行之下</li>
</ul>
<p>两行合并(Join) J：当前行下面的行合并到当前行</p>
<p>刷新屏幕显示(load)：Ctrl-l</p>
<p>状态显示 Ctrl-g：在屏幕最下面一行列出正在编辑的文件的名字，总行数，当前行号，文件是否被修改过等信息</p>
<p>模式查找</p>
<ul>
<li>格式 &#x2F;pattern</li>
<li>n 向下查找下一个next</li>
<li>N 向上查找下一个</li>
</ul>
<p>模式替换</p>
<ul>
<li>替换命令：:n1,n2s&#x2F;pattern&#x2F;string&#x2F;g<br>有点像sed的格式</li>
</ul>
<h3 id="文件和目录的管理"><a href="#文件和目录的管理" class="headerlink" title="文件和目录的管理"></a>文件和目录的管理</h3><ul>
<li>ls -F<ul>
<li>若列出的是目录，就在名字后面缀以斜线 &#x2F;</li>
<li>若列出的是可执行文件，就在名字后面缀以星号 *</li>
<li>若列出的是符号连接文件，就在名字后面缀以符号@</li>
<li>若列出的是普通文件，则名字面后无任何标记</li>
</ul>
</li>
<li>ls -l<ul>
<li>第1列：文件属性<ul>
<li>普通文件</li>
<li>b 块设备文件(Block)</li>
<li>d 目录文件(Dir)</li>
<li>c 字符设备文件(Char)</li>
<li>l 符号连接文件(Link)</li>
<li>p 命名管道文件(Pipe)</li>
</ul>
</li>
<li>第2列：文件link数，涉及到此文件的目录项数</li>
<li>第3列，第4列：文件主的名字和组名</li>
<li>第五列，一个代表大小的数字，不同类型的文件这个数字的含义不同</li>
<li>第6列：文件最后一次被修改的日期和时间</li>
<li>第7列：文件名<ul>
<li>对于符号连接文件，附带列出符号连接文件的内容</li>
</ul>
</li>
</ul>
</li>
<li>ls -h （human-readable）</li>
<li>ls -d (directory)<br>对比-d参数的作用：<br><img src="https://api2.mubu.com/v3/document_image/3ca46d32-014d-49b1-a67d-68ea5e211601-16175743.jpg" alt="-d"><br>ls与ls *的区别<br><img src="https://api2.mubu.com/v3/document_image/a8191984-b613-41bf-a42e-32f80f66be7e-16175743.jpg" alt="2"></li>
<li>ls -a 列出文件名首字符为圆点的文件</li>
<li>ls -A (功能与-a相同，除了不列出. 和..)</li>
<li>ls -s (size)列出文件占用的磁盘空间</li>
<li>ls -i (i-node)列出文件的i节点号</li>
</ul>
<h3 id="文件的复制与删除"><a href="#文件的复制与删除" class="headerlink" title="文件的复制与删除"></a>文件的复制与删除</h3><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>命令的两种格式和功能</p>
<ul>
<li>cp file1 file2</li>
<li>cp file1 file2 . dir<br>其中file1，……，filen为文件名，dir为已有目录名<br>第二种格式中： dir必须已经存在并且是一个目录<br>第一种格式中： file2不存在，则创建；file2存在且是文件，则覆盖；<br>file2存在且是目录，则按格式二处理</li>
</ul>
<p>一个有趣的例子，本质还是linux的shell对通配符的处理策略<br><img src="https://api2.mubu.com/v3/document_image/abcd20eb-be74-45ef-8d38-c17d574659a9-16175743.jpg" alt="2"></p>
<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>mv file1 file2<br>mv file1 file2 … filen dir<br>mv dir1 dir2<br>如果mv的最后一个参数是一个已存在的目录,不会对文件进行删改，只会改指针<br>使用mv命令可以将文件和目录改名<br>可以将文件和子目录从一个目录移动到另一个目录<br>mv dir1 dir2 两种执行情况（同文件系统，不同文件系统）<br>同文件系统其实就只是改个名字<br>不同文件系统就没办法了，得读出写入。</p>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>需要注意 rm * .bak （*后空格的错误），这种就把里面的东西都删了,j就算会报错找不到.bat文件，但是除了目录之外的能删的都已经删完了。</p>
<p>-r 递归地(Recursive)删除实参表中的目录，也就是删除一<br>整棵目录树。<br>-i 每删除一个文件前需要操作员确认(Inform)<br>-f 强迫删除(Force)。只读文件也被删除并且无提示，<strong>无操作权限</strong>的文件强制删除也不能删掉</p>
<p>这里又有一个有趣的小例子</p>
<p>已知-i是rm的一个参数，如果目录下存在一个名字叫做-i的文件，想要删除它的时候怎么办呢<br>这个时候就可以用–显式地表示命令行参数列表中选项的结束，分隔选项和处理对象，也适用于其他命令<br><img src="https://api2.mubu.com/v3/document_image/9ca0ed1d-396a-4972-a386-b62a780b5891-16175743.jpg" alt="rm-i"><br><img src="https://api2.mubu.com/v3/document_image/d961ff7d-ecc0-485f-b948-549c090abb3e-16175743.jpg" alt="rm---i"></p>
<h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><p>文件.与..<br>在目录表中确实有两个文件<br>这两个目录项由系统自动创建和删除<br>可以简单的把.理解为当前文件,..理解为上一级文件</p>
<p>env 可以查看环境变量<br>pwd:print working directory<br>cd:change directory<br>cd :无参数的时候，widnows会打印当前工作目录<br>unix会回到用户的主目录</p>
<p><strong>cd是shell的一个内部命令</strong>，硬盘上没有cd这个命令；shell自行完成改变当前进程工<br>作目录的操作。</p>
<p>mkdir<br>选项-p，自动创建路径中不存在的目录。<br>例如：mkdir database&#x2F;2019&#x2F;09&#x2F;04&#x2F;log -p<br>删除目录rmdir<br>例：rmdir sun&#x2F;work.d<br>要求被删除的目录除.与..外无其它文件或目录<br>换句话说，这玩意儿只能删除空目录，里面有东西的目录它一点办法都没有</p>
<p>cp 复制目录<br>cp -r dir1 dir2  递归的复制一个目录<br>选项–v，冗长(verbose)方式<br>复制目录时实时列出正在复制的文件的名字<br>cp命令选项–r，递归地复制一个目录</p>
<p>根据dir2是否存在，执行结果有差异：</p>
<ul>
<li>若dir2不存在，则新建子目录dir2，把dir1下内容拷入dir2下</li>
<li>若dir2已存在，则dir2下新建子目录dir1，把dir1下内容拷入dir2&#x2F;dir1下</li>
</ul>
<p>选项–u，增量拷贝(update)，便于备份目录</p>
<ul>
<li>根据文件的时戳，不拷贝相同的或者过时的版本的文件，以提高速度</li>
<li>dir1和dir2不慎颠倒位置，不会出现灾难性后果</li>
<li>Windows中类似功能的命令XCOPY，选项&#x2F;D可以用来实现增量拷贝(Date)</li>
</ul>
<p>rsync命令，完成远程同步，可以镜像整个目录树<br>rsync用一精巧的算法，将文件分块，在两主机间传播数据块的hash值，据此推出两版本文件之间区别，使得网络只传输文件的增、删、改部分</p>
<h3 id="目录遍历的命令"><a href="#目录遍历的命令" class="headerlink" title="目录遍历的命令"></a>目录遍历的命令</h3><p>find命令从指定的查找范围开始，<strong>递归地</strong>查找子目录，凡满足条件的文件或目录，执行规定的动作<br>find命令有三个参数<br><img src="https://api2.mubu.com/v3/document_image/548d9fd9-ef14-4c16-b77f-b0d124a648ba-16175743.jpg" alt="find"></p>
<p>有关条件的选项</p>
<ul>
<li>-name 需要引号，对通配符的解释由find完成</li>
<li>-type<ul>
<li>f:普通文件</li>
<li>d:目录</li>
<li>l:符号连接文件</li>
<li>c:字符设备文件</li>
<li>b:块设备文件</li>
<li>p:管道文件</li>
</ul>
</li>
<li>-size ±n单位：指定文件大小（大于+，等于，小于-）</li>
<li>以用() –o !等表示多条件的“与”，“或”，“非”</li>
</ul>
<p>有关动作的选项</p>
<ul>
<li>-print 打印查找的文件的路径名</li>
<li>-exec 对查找到的目标执行某一命令 在-exec及随后的分号之间的内容作为一条命令，在这命令的命令参数中，{}代表遍历到的目标文件的路径名</li>
<li>-ok 与-exec类似，只是对查找到符合条件的目标执行一个命令前需要经过操作员确认</li>
</ul>
<h3 id="目录遍历的应用"><a href="#目录遍历的应用" class="headerlink" title="目录遍历的应用"></a>目录遍历的应用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find src -name \*.c -exec grep -n -- --help &#123;&#125; /dev/null \;</span><br></pre></td></tr></table></figure>

<p>在目录src中所有.c文件中查找–help字符串<br>grep的-n选项：打印行号<br>–：grep的命令行选项结束，其后命令行参数为查找对象<br>&#x2F;dev&#x2F;null文件的作用：特殊设备文件，读不出写不入；陪伴{}中的每个文件，构成两个grep的待搜索文件，以打印文件名。</p>
<h3 id="批量处理文件"><a href="#批量处理文件" class="headerlink" title="批量处理文件"></a>批量处理文件</h3><p>上面那个应用的例子，效率低，因为每个命中的对象都需要执行grep命令：创建一个进程，完成任务后进程消亡，然后再创建，再消亡。</p>
<p>xargs</p>
<p>命令xargs可以用来完成这个工作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find src -name \*.c –print | xargs grep -n ----help</span><br></pre></td></tr></table></figure>

<p><strong>xargs命令把标准输入追加到命令参数表后面</strong>，也就是上述grep…的后面，再作为一个命令来执行。</p>
<blockquote>
<p>这个跟管道重定向是不同的，如果是管道重定向的话，它仅仅是把find得到的结果（文件列表）作为一个文件进行输入，grep做的是在这个文件列表中寻找–help，而不会打开文件寻找，作为参数列表就不同了，grep会打开文件列表中的文件去寻找。</p>
</blockquote>
<h3 id="打包与压缩"><a href="#打包与压缩" class="headerlink" title="打包与压缩"></a>打包与压缩</h3><p>打包的例子：tar czvf mytar.zip.gz<br>解压的例子：tar xvf mytar.zip.gz<br>查看压缩包内容：tar tvf mytar.zip.gz</p>
<p>参数详解：</p>
<ul>
<li>f: File。指定设备文件名</li>
<li>z: 采用压缩格式(gzip算法)</li>
<li>j: 采用压缩格式(bzip2算法)</li>
</ul>
<blockquote>
<p>关于两种压缩算法<br>tar cvzf work.tar.gz work<br>(gzip压缩算法，对C程序体积为原来的20%)<br>tar cvjf work.tar.bz2 work<br>(bzip2压缩算法，对C程序17%，执行时间三倍)<br>通常采用gzip的算法，文件名后缀.tar,.tar.gz,.tar.bz2仅仅是惯例，不是系统级强制要求。</p>
</blockquote>
<h2 id="Chapter-3-文件系统管理"><a href="#Chapter-3-文件系统管理" class="headerlink" title="Chapter 3 文件系统管理"></a>Chapter 3 文件系统管理</h2><p>df: 文件系统空闲空间<br>（-h参数：human readable）</p>
<h3 id="文件系统的存储管理"><a href="#文件系统的存储管理" class="headerlink" title="文件系统的存储管理"></a>文件系统的存储管理</h3><p><img src="https://api2.mubu.com/v3/document_image/32ad32ee-4d22-4b07-b463-d4b170cfd3b5-16175743.jpg" alt="zhengti"></p>
<ul>
<li>引导块(0号块)：启动系统，只有根文件系统引导块有效</li>
<li>专用块(1号块)：也叫管理块，或者超级块<ul>
<li>存放文件系统的<strong>管理信息</strong>。如：文件系统的大小，i节点区的大小，空闲空间大小，空闲块链表的头等等</li>
<li>mkfs命令时初始化，df命令读出部分信息，df -i和df</li>
</ul>
</li>
</ul>
<p>i节点：(index node，简记为i-node)</p>
<ul>
<li>由若干块构成，在mkfs命令创建文件系统时确定</li>
<li>每块可容若干个i节点，i节点大小固定（比如64字节）</li>
<li>i节点从1开始编号，根据编号可以索引到磁盘块</li>
<li>每个文件都对应一个i节点</li>
</ul>
<p>i节点包括</p>
<ul>
<li>指向文件存储区数据块的一些索引（index）指针（组成文件的逻辑块与硬盘的物理块之间的映射）</li>
<li>文件类型，属主，组，权限，link数，大小，时戳（<strong>i节点内不含文件名</strong>）</li>
</ul>
<p>文件存储区<br>用于存放文件数据的区域，包括<strong>目录表</strong></p>
<p>linux文件系统最有意思的是<strong>目录表也作为一个文件来管理</strong>，存于“文件<br>存储区”中，有其自己的i节点和数据存储块。</p>
<p>目录和i节点的存储结构如下</p>
<p><img src="https://api2.mubu.com/v3/document_image/eb0e05c8-271f-4c08-b82c-9ec4ab7e9df1-16175743.jpg" alt="i"></p>
<h3 id="软连接和硬链接"><a href="#软连接和硬链接" class="headerlink" title="软连接和硬链接"></a>软连接和硬链接</h3><p>每个目录项指定的“文件名-i节点号”映射关系，叫做1个<strong>硬连接</strong><br>不允许对目录用ln命令建立硬连接<br>一般来说， $目录的link数&#x3D;直属子目录数+2$<br><img src="https://api2.mubu.com/v3/document_image/d7d2b329-28f6-4170-bdc5-faaa25db4fc9-16175743.jpg" alt="yinglianjie"></p>
<p>符号连接也叫软连接 （不同文件系统间连接文件）<br>用特殊文件“符号连接文件”来实现<br>文件中仅包括了一个路径名</p>
<p><img src="https://api2.mubu.com/v3/document_image/848ab5d5-cebe-4ea6-8376-8118fee83e0e-16175743.jpg" alt="软链接"><br>命令stat：读取i节点信息<br>命令ln -s</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s users_on sym.link</span><br></pre></td></tr></table></figure>

<p>一旦建立了符号连接，删除操作删除的是符号连接文件，其它所有操作都将访问符号连接所引用的文件.</p>
<p>符号链接中的相对路径:若符号连接含相对路径名，是相对于符号链接文件<br>的位置(不是相对于调用进程的当前工作目录)</p>
<p><img src="https://api2.mubu.com/v3/document_image/5e9dbd9b-c325-45a0-a309-fd945536cf16-16175743.jpg" alt="location"></p>
<p>软硬连接的区别：是否有独立的i节点</p>
<p>硬连接与符号连接的比较<br>硬连接</p>
<ul>
<li>在数据结构层次上实现</li>
<li>只适用于文件，不适用于目录</li>
<li>不同文件系统之间也不行</li>
<li>硬连接能够完成的功能软连接可以做到</li>
</ul>
<p>符号连接</p>
<ul>
<li>在算法软件上实现</li>
<li>硬连接能够完成的功能软连接都可以做到</li>
<li>适用于目录，也适用于不同的文件系统</li>
<li>同硬连接相比要占用操作系统内核的一部分开销</li>
<li>循环式符号连接，以及处理方法（解析路径时设置符号<br>链接解析计数器）</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p><mark>系统调用与库函数在执行方式上的区别</mark><br>例如：获取进程ID的<font color=blue>getpid()</font>与字符串拷贝函数<font color=green>strcpy()</font><br>CPU的INT指令（<strong>软中断、内核态</strong>）; CALL指令（<strong>子程序调用、用户态</strong>）</p>
<h4 id="整型变量errno"><a href="#整型变量errno" class="headerlink" title="整型变量errno"></a>整型变量errno</h4><p>这个很有意思<br>C标准库定义了errno，系统调用失败后自动填写错误代码，记录失败原因</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>之后，就可以直接使用errno</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errno)</span>;</span><br></pre></td></tr></table></figure>

<p>库函数strerror将数字形式的错误代码转换成一个可阅读的字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>的%m</span><br></pre></td></tr></table></figure>

<p>printf类函数格式字符串中的%m会被替换成上次系统调用失败的错误代码对应的消息（message）</p>
<p>这里有一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">char</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line">fd = open(argv[<span class="number">1</span>], O_WRONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">//这里展示了两种输出错误代码对应的信息的方法</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERROR %d: %m\n&quot;</span>, errno);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERROR [%s]\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line">. . . . . .</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="访问i节点和目录"><a href="#访问i节点和目录" class="headerlink" title="访问i节点和目录"></a>访问i节点和目录</h3><p><strong>stat</strong>得到指定路径名的文件的i节点 （路径名）<br><strong>fstat</strong>得到已打开文件的i节点 （内存中节点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure>

<p>↓结构体stat,写coding作业2的时候会用到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">dev_t</span> st_dev; <span class="comment">/* 存储该文件的块设备的设备号ID，包括主设备号与次设备号*/</span></span><br><span class="line">  <span class="type">ino_t</span> st_ino; <span class="comment">/* inode号 */</span></span><br><span class="line">  <span class="type">mode_t</span> st_mode; <span class="comment">/* 访问权限及文件类型 */</span></span><br><span class="line">  <span class="type">nlink_t</span> st_nlink; <span class="comment">/* link数 */</span></span><br><span class="line">  <span class="type">uid_t</span> st_uid; <span class="comment">/* 文件主ID */</span></span><br><span class="line">  <span class="type">gid_t</span> st_gid; <span class="comment">/* 组ID */</span></span><br><span class="line">  <span class="type">dev_t</span> st_rdev; <span class="comment">/* device ID (if special file) */</span></span><br><span class="line">  <span class="type">off_t</span> st_size; <span class="comment">/* 文件大小（字节数）*/</span></span><br><span class="line">  <span class="type">blksize_t</span> st_blksize; <span class="comment">/* blocksize for filesystem I/O */</span></span><br><span class="line">  <span class="type">blkcnt_t</span> st_blocks; <span class="comment">/* 分配的512字节尺寸块个数 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span> <span class="comment">/* access时间 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span> <span class="comment">/* modification时间 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span> <span class="comment">/* change时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="目录访问的一组库函数"><a href="#目录访问的一组库函数" class="headerlink" title="目录访问的一组库函数"></a>目录访问的一组库函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">char</span> *dirname)</span>;</span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dir)</span>;</span><br></pre></td></tr></table></figure>
<p>opendir打开目录得到句柄,readdir获取一个目录项.<br>用closedir关闭不再使用的目录句柄。</p>
<p>目录访问程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  DIR *dir;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s &lt;dirname&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((dir = opendir(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Open directory \&quot;%s\&quot;: %s (ERROR %d)\n&quot;</span>,</span><br><span class="line">  argv[<span class="number">1</span>], strerror(errno), errno);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, entry-&gt;d_ino, entry-&gt;d_name);</span><br><span class="line">  closedir(dir);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个的运行结果就是把当前目录下一层级的子目录输出出来。</p>
<h2 id="补充1：远程登录服务器"><a href="#补充1：远程登录服务器" class="headerlink" title="补充1：远程登录服务器"></a>补充1：远程登录服务器</h2><h3 id="1-ssh"><a href="#1-ssh" class="headerlink" title="1.ssh"></a>1.ssh</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">ssh [username]@[ipv4地址]</span><br></pre></td></tr></table></figure>

<p>ex:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">ssh jiang@<span class="number">82.156</span>.<span class="number">118.183</span></span><br></pre></td></tr></table></figure>

<p>也可以写一个 dos 批处理程序</p>
<p>就是.bat文件<br>建立一个bupt.bat文件<br>里面的内容是</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">ssh jiang@<span class="number">82.156</span>.<span class="number">118.183</span></span><br><span class="line">&lt;psw&gt;</span><br></pre></td></tr></table></figure>

<p>然后运行命令</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bupt.bat</span><br></pre></td></tr></table></figure>

<p>就可以不用每次都输入密码了</p>
<h3 id="2-git-bash"><a href="#2-git-bash" class="headerlink" title="2.git bash"></a>2.git bash</h3><p>就拿来当cmd用，也是用ssh连的，不再赘述</p>
<h3 id="3-putty"><a href="#3-putty" class="headerlink" title="3.putty"></a>3.putty</h3><p>略，没用过</p>
<h3 id="4-secureCRT"><a href="#4-secureCRT" class="headerlink" title="4.secureCRT"></a>4.secureCRT</h3><p>略，看起来跟笔者常用的xshell差不多。</p>
<h3 id="传输文件的软件"><a href="#传输文件的软件" class="headerlink" title="传输文件的软件"></a>传输文件的软件</h3><ol>
<li>winSCP，图形化的界面，比较舒服</li>
<li>远程连接的窗口有传输文件的专用命令rz sz</li>
</ol>
<h3 id="非对称性加密"><a href="#非对称性加密" class="headerlink" title="非对称性加密"></a>非对称性加密</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>查看和更改配置文件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>不好使的话记得加sudo</p>
<h2 id="补充2：word"><a href="#补充2：word" class="headerlink" title="补充2：word"></a>补充2：word</h2><ul>
<li>SDK softerware Develop Kit 软件开发包</li>
<li>DDK Drive Development Kit 驱动开发包</li>
<li>小于32的ASCII码都是控制字符</li>
</ul>
<h2 id="附录1：关于安装yum"><a href="#附录1：关于安装yum" class="headerlink" title="附录1：关于安装yum"></a>附录1：关于安装yum</h2><p>在ubuntu上安装了yum，执行yum命令就报错：<br>There are no enabled repos. Run “yum repolist all” to see the repos you have. You can enable repos</p>
<p>按照提示输入yum repolist all，啥也没有，百度查了一堆，乱七八糟，都不行。弄了我好久。后来知道为啥了。</p>
<p>就不该安装yum，因为linux系统是Ubuntu。</p>
<p>一般来说Linux系统基本上分两大类:</p>
<p>RedHat系列：Redhat、Centos、F edora等</p>
<p>Debian系列：Debian、Ubuntu等</p>
<p>RedHat系列：</p>
<p>1.常见的安装包格式rpm包、安装rpm包的命令：rpm-参数</p>
<p>2.包管理工具yum</p>
<p>3.支持tar包</p>
<p>Debian系列：</p>
<p>1.常见的安装包格式deb包、安装rpm包的命令：deb-参数</p>
<p>2.包管理工具apt-get</p>
<p>3.支持tar包</p>
<p>所以，也就是说，直接用apt-get就行了，别用yum。</p>
]]></content>
      <categories>
        <category>笔记 - Linux</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>并行计算笔记</title>
    <url>/2023/02/27/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="第一章-并行计算概述"><a href="#第一章-并行计算概述" class="headerlink" title="第一章 并行计算概述"></a>第一章 并行计算概述</h2><h3 id="1-什么是并行计算"><a href="#1-什么是并行计算" class="headerlink" title="1. 什么是并行计算"></a>1. 什么是并行计算</h3><h3 id="2-并行问题与并行计算模型"><a href="#2-并行问题与并行计算模型" class="headerlink" title="2. 并行问题与并行计算模型"></a>2. 并行问题与并行计算模型</h3><p>BSP模型 是整体同步并行计算模型<br>适用用于初学者<br>整体程序分为大的几个同步模块，每个模块里面尝试并行<br>每个模块里面要干的事情就是 局部计算，通信和同步</p>
<blockquote>
<p>补充：编程分为哪三个部分？<br>输入 计算 输出</p>
</blockquote>
<h3 id="并行编程模型"><a href="#并行编程模型" class="headerlink" title="并行编程模型"></a>并行编程模型</h3><ul>
<li>共享存储模型</li>
<li>线程模型</li>
<li>消息传递模型</li>
<li>数据并行模型</li>
</ul>
<h4 id="常见的并行编程模型-x2F-语言"><a href="#常见的并行编程模型-x2F-语言" class="headerlink" title="常见的并行编程模型&#x2F;语言"></a>常见的并行编程模型&#x2F;语言</h4><ul>
<li>消息传递以及MPI</li>
<li>OpenMP</li>
<li>分区全局地址空间（Partitioned Global Address space <strong>PGAS</strong>），是把上面俩的好处结合起来了</li>
</ul>
<h3 id="什么是CUDA"><a href="#什么是CUDA" class="headerlink" title="什么是CUDA"></a>什么是CUDA</h3><p>CUDA: Compute Unified Device Architecture(计算统一设备架构)<br><img src="https://api2.mubu.com/v3/document_image/71835e52-d0ab-44dc-a707-7955e9737816-16175743.jpg" alt="2"><br>大多数的开发者，用的是Cuda Runtime的API<br>CUDA Libraries 又叫CUDAx，是为了满足各行各业的加速需求出现的更简单的封装接口</p>
<h3 id="设计并行处理程序和系统"><a href="#设计并行处理程序和系统" class="headerlink" title="设计并行处理程序和系统"></a>设计并行处理程序和系统</h3><ul>
<li>自动和手动并行</li>
<li>理解问题和陈鼓型</li>
<li>分块分割</li>
<li>通信</li>
<li>同步</li>
<li>数据依赖</li>
<li>负载均衡</li>
<li>粒度</li>
<li>I&#x2F;O</li>
<li>成本</li>
<li>性能分析和优化</li>
</ul>
<h3 id="本机GPU"><a href="#本机GPU" class="headerlink" title="本机GPU"></a>本机GPU</h3><p>NVIDIA GeForce RTX 3060 Laptop GPU<br><a href="https://www.nvidia.com/en-us/geforce/laptops/30-series/#geforce-now">官网详细信息</a></p>
<p><img src="https://api2.mubu.com/v3/document_image/5da16b1d-69c4-4e70-a58a-04bd44e07a13-16175743.jpg" alt="2"></p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="CPU与GPU之间的数据传输"><a href="#CPU与GPU之间的数据传输" class="headerlink" title="CPU与GPU之间的数据传输"></a>CPU与GPU之间的数据传输</h3><p>cudaMalloc<br>该函数从设备内存中分配size字节的空间地址给devPtr。传递的时候要将devPtr的地址传递进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaMalloc</span><span class="params">(<span class="type">void</span> ** devPtr, <span class="type">size_t</span> size)</span>;</span><br><span class="line">返回值有两种可能：cudaSuccess和cudaErrorMemoryAllocation</span><br></pre></td></tr></table></figure>
<p>cudaMallocHost() or cudaHostAlloc()<br>分配主机内存，这些内存是锁页的，可以被设备访问。<br>驱动程序跟踪用这个函数分配的虚拟内存范围，并自动加速对cudaMemcpy*()等函数的调用。<br>用于数据交换，或CPU与GPU之间的通讯。</p>
<blockquote>
<p>用cudaMallocHost()分配过多的内存可能会降低系统性<br>能，因为它减少了系统可用于分页的内存量</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__host__ cudaError_t <span class="title function_">cudaMallocHost</span> <span class="params">( <span class="type">void</span>** ptr, <span class="type">size_t</span> size )</span></span><br><span class="line">__host__ cudaError_t <span class="title function_">cudaHostAlloc</span> <span class="params">( <span class="type">void</span>** pHost, <span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> flags</span></span><br></pre></td></tr></table></figure>

<p><img src="https://api2.mubu.com/v3/document_image/d955605c-553c-43d7-99ed-50222b3d0ee3-16175743.jpg"></p>
<p>cudaMemcpy()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__host__ cudaError_t <span class="title function_">cudaMemcpy</span> <span class="params">( <span class="type">void</span>* dst, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count, cudaMemcpyKind kind )</span></span><br></pre></td></tr></table></figure>

<p>dst – 目的内存地址 src – 源内存地址<br>count – 拷贝的大小，单位为字节<br>kind – 传输的类型。指定了拷贝的方向，取值如下： cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost, cudaMemcpyDeviceToDevice, or cudaMemcpyDefaut</p>
<p>推荐使用cudaMemcpyDefault, 这种情况下，传输的类型由指针的取值推测处理。</p>
<p>cudaMemcpyToSymbol()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">__host__cudaError_t <span class="title function_">cudaMemorycpyToSymbol</span><span class="params">(<span class="type">const</span> T&amp; symbol,<span class="type">const</span> coid*src,<span class="type">size_t</span> count,<span class="type">size_t</span> offset = <span class="number">0</span>,cudaMemcpyKind kind = cudaMemcpyHostToDevice)</span></span><br></pre></td></tr></table></figure>

<p>kind 取值可能为udaMemcpyHostToDevice, cudaMemcpyDeviceToDevice, or udaMemcpyDefault.<br>将src指向的内存区域的计数字节，复制到符号symbol开始的偏移字节所指向的内存区域。这些内存区域不能重叠（在DeviceToDevice时）。<br>symbol是一个<strong>驻留在设备全局或设备常量内存</strong>空间中的变量。</p>
<p>cudaMemcpyFromSymbol()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">template &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line">__host__cudaError_t <span class="title function_">cudaMemcpyFromSymbol</span> <span class="params">( <span class="type">void</span>* dst, <span class="type">const</span> T&amp; symbol, <span class="type">size_t</span> count, <span class="type">size_t</span> offset = <span class="number">0</span>, cudaMemcpyKind kind = cudaMemcpyDeviceToHost )</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> N = <span class="number">1048576</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> bytes = N * <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> *h_a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(bytes);</span><br><span class="line"><span class="type">int</span> *d_a;</span><br><span class="line"><span class="comment">//可分页内存；</span></span><br><span class="line">cudaMalloc((<span class="type">int</span>**)&amp;d_a, bytes);</span><br><span class="line"><span class="built_in">memset</span>(h_a, <span class="number">0</span>, bytes);</span><br><span class="line"><span class="comment">//通用的CPU与GPU之间的数据传输。</span></span><br><span class="line">cudaMemcpy(d_a, h_a, bytes, cudaMemcpyHostToDevice);</span><br><span class="line">cudaMemcpy(h_a, d_a, bytes, cudaMemcpyDeviceToHost); </span><br><span class="line"><span class="comment">//这个还有一个好处，就是不用同步时钟了，通过这两步拷贝就可以保证同步。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记 - 并行计算与CUDA编程</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>并行计算与CUDA编程</tag>
      </tags>
  </entry>
  <entry>
    <title>系统结构笔记四、五章</title>
    <url>/2023/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%842/</url>
    <content><![CDATA[<h2 id="第四章-向量处理机"><a href="#第四章-向量处理机" class="headerlink" title="第四章 向量处理机"></a>第四章 向量处理机</h2><blockquote>
<p>重点<br>向量处理方法：横向处理、纵向处理、纵横处理<br>向量流水处理机结构：<br>    1. 存储器-存储器结构：纵向处理<br>    2. 寄存器-寄存器结构：纵横处理<br>提高向量处理机性能的方法：<br>    - 多功能部件的并行操作<br>    - 链接技术 WD 相关<br>    - 分段开采<br>    - 多处理机系统结构<br>向量处理机性能的主要参数：<br>    - 一条向量指令的处理时间<br>    - 一组向量指令的处理时间<br>    - 向量处理机的性能评估（MFLOPS 或一个浮点运算的时间）<br>第四章，重点是链接技术，一般出大题，pin</p>
</blockquote>
<h3 id="向量基本概念和处理方法"><a href="#向量基本概念和处理方法" class="headerlink" title="向量基本概念和处理方法"></a>向量基本概念和处理方法</h3><p>向量处理机：设置了向量数据表示和向量指令的流水线处理机。</p>
<p>向量处理机方式：</p>
<ul>
<li>横向处理方式：向量按 column 的方式从左到右横向进行。适用于一般处理机，<strong>不适用于向量处理机的并行处理</strong>。<ul>
<li>以 $D&#x3D;A \times (B+C)$为例</li>
<li>每个向量的处理产生N次数据相关，2N次功能转移（向量长度特别长）</li>
</ul>
</li>
<li><strong>纵向处理方式</strong>：向量按 row 的方式从上到下纵向进行。将整个向量按相同运算处理完之后，再进行别的运算。不产生数据相关，对向量长度 N 没有限制。</li>
<li><strong>纵横处理方式</strong>：把向量分成若干组，组内按纵向方式处理，依次处理各组。对向量长度 N 没有限制，但以每 n 个元素分一组处理，n 的值固定。</li>
</ul>
<h3 id="向量处理机结构"><a href="#向量处理机结构" class="headerlink" title="向量处理机结构"></a>向量处理机结构</h3><h4 id="存储器-存储器结构"><a href="#存储器-存储器结构" class="headerlink" title="存储器-存储器结构"></a>存储器-存储器结构</h4><p><mark>适合纵向处理方式。</mark></p>
<ul>
<li><strong>源向量</strong>和<strong>目的向量</strong>都存放在存储器中，运算的中间结果需要送回存储器。</li>
<li>对应的向量分量能并发访问，计算结果能并行地保存。</li>
<li>普通存储器的 3 倍带宽：3 条独立数据通路，一个时钟周期读出两个操作数并写回一个结果。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/2362ff86-2352-49f6-b62e-fa1337ccdc60-16175743.jpg" alt="2"></p>
<p>为了满足运算器带宽要求，存储器采用多个存储器模块组成的结构方式，运算器与主存间有三条相互独立的数据通路，三条路之间可以并行工作，但每个模块同一时间只服务于一个《？？》</p>
<h4 id="寄存器-寄存器结构"><a href="#寄存器-寄存器结构" class="headerlink" title="寄存器-寄存器结构"></a>寄存器-寄存器结构</h4><p><mark>适合纵横处理方式。</amrk></p>
<ul>
<li>若干级中间存储器形成有层次结构的存储系统，相当于寄存器。</li>
<li>访问中间存储器速度更快(比直接访问存储器)。</li>
<li>通过中间存储器形成新的数据结构，高效。</li>
<li>中间存储器高带宽、多种寻址方式、支持流水线链接技术。</li>
</ul>
<p>CRAY-1向量处理机</p>
<ul>
<li>上课讲了，but没怎么听懂（草）。</li>
</ul>
<p>向量流水线并行条件：</p>
<ul>
<li>功能部件不冲突</li>
<li>源寄存器不冲突</li>
<li>结果寄存器不冲突</li>
<li>数据不相关</li>
</ul>
<h3 id="提高向量流水处理机性能"><a href="#提高向量流水处理机性能" class="headerlink" title="提高向量流水处理机性能"></a>提高向量流水处理机性能</h3><ul>
<li><strong>设置多个功能部件，使它们并行工作</strong></li>
<li><strong>采用链接技术，加快一串向量指令的执行</strong></li>
<li>采用（分段）循环开采技术，加快循环的处理</li>
<li>采用多处理机系统，进一步提高性能</li>
</ul>
<h4 id="多功能部件的并行操作"><a href="#多功能部件的并行操作" class="headerlink" title="多功能部件的并行操作"></a>多功能部件的并行操作</h4><p>约束条件为：</p>
<ol>
<li>无向量寄存器使用冲突</li>
<li>无功能部件使用冲突</li>
</ol>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>必须是“寄存器——寄存器”系统<br>向量运算输出可直接作为输入使用，结果寄存器立即成为后继指令操作数寄存器。是定向技术的发展，利用 RAW 数据相关性。<strong>数据进（出）每个功能部件需 1 个时钟周期</strong>。</p>
<p>链接条件：</p>
<ul>
<li>空间<ul>
<li>无向量寄存器(源和结果都不冲突)、功能部件冲突</li>
</ul>
</li>
<li>时间<ul>
<li>仅上一指令的第 1 个结果分量送入结果向量寄存器的时钟周期可链接。</li>
<li>若后一指令源操作数分别是前两指令的结果寄存器，前两指令产生结果时间必须相等。</li>
<li>向量长度必须相等。</li>
</ul>
</li>
</ul>
<p>由于同步的要求,链接时,Cray-1中把向量数据元素送往向量功能部件以及把结果存入向量寄存器都需要一拍时间,从存储器中把数据送入访存功能部件也需要一拍时间。</p>
<p>例题（课本4.1 4.2）</p>
<h4 id="分段（循环）开采"><a href="#分段（循环）开采" class="headerlink" title="分段（循环）开采"></a>分段（循环）开采</h4><p>向量长度大于向量寄存器长度时，对向量进行分段处理，系统完成，对程序员透明。<br>处理长向量的程序结构称为向量循环。也称分段开采技术。。<br>向量分段由系统硬件和软件控制完成，对程序员透明。即看不到分段过程。<br>进入循环前，系统会根据向量长度计算出循环的次数。<br>分段需一定时间开销，包括流水线启动开销</p>
<h4 id="多处理机体系结构"><a href="#多处理机体系结构" class="headerlink" title="多处理机体系结构"></a>多处理机体系结构</h4><p>略</p>
<h3 id="向量处理机的性能评价"><a href="#向量处理机的性能评价" class="headerlink" title="向量处理机的性能评价"></a>向量处理机的性能评价</h3><p>向量处理指令特点：</p>
<ul>
<li>一条指令得到若干运算结果。</li>
<li>执行时间与向量长度有关。</li>
<li>向量处理中包含标量指令。</li>
<li>CPI、MIPS 不能反映向量处理性能。</li>
</ul>
<h4 id="向量处理机性能主要参数"><a href="#向量处理机性能主要参数" class="headerlink" title="向量处理机性能主要参数"></a>向量处理机性能主要参数</h4><h5 id="1-一条向量指令的处理时间-T-vp"><a href="#1-一条向量指令的处理时间-T-vp" class="headerlink" title="1.一条向量指令的处理时间$T_{vp}$"></a>1.一条向量指令的处理时间$T_{vp}$</h5><p>$T_{vp} &#x3D; T_s + T_e + (n-1)T_c$</p>
<p>$T_{vp}$ :执行一条向量长度为n的向量指令所需的时间<br>$T_s$ :向量处理部件流水线的建立时间<br>$T_e$ :向量流水线的通过时间<br>$T_c$ :流水线的时钟周期时间</p>
<p>不考虑 $T_s$，令$T_{start} &#x3D; e-1$</p>
<p>$T_{vp} &#x3D; T_{start} + (n-1)T_c$</p>
<p>其中, $T_{start}$ 为从一条向量指令开始执行到还差一个时钟周期就产生第一个结果所需的时钟周期数,可称为该向量指令的启动时间。此后,便是每个时钟周期流出一个结果,共有n个结果。</p>
<h5 id="2-一组向量指令的处理时间"><a href="#2-一组向量指令的处理时间" class="headerlink" title="2.一组向量指令的处理时间"></a>2.一组向量指令的处理时间</h5><p>下面考虑一组向量指令的执行时间。<br>这个执行时间主要取决于三个因素:</p>
<ol>
<li>向量的长度</li>
<li>向量操作之间是否存在流水功能部件的使用冲突</li>
<li>数据的相关性</li>
</ol>
<p>我们把<strong>能在同一个时钟周期内一起开始执行</strong>的几条向量指令称为<strong>一个编队</strong>。<br>同一个编队中的向量指令之间一定不存在<strong>流水功能部件的冲突</strong>﹑ <strong>$V_i$ 冲突</strong>或<strong>数据的相关性</strong>。如果存在这种冲突或相关,那么就必须将它们编入不同的编队。</p>
<p>$T_{all} &#x3D; \sum_{i&#x3D;1}^{m} T_{vp}^{(i)}$</p>
<p>m是编队的数目， $T_{vp}^{(i)}$ 表示第i个编队的执行时间。</p>
<p>当一个编队是由若干条指令组成时,其执行时间就应该由该编队中<strong>各指令的执行时间的最大值</strong>来确定。由于都是处理n个元素,所以主要的区别在于各条指令的 $T_{start}$ 值。令 $T_{start}^{(i)}$ 表示第i编队中各指令的启动时间的最大值,则</p>
<p>$T_{all} &#x3D; [T_{start} +mn] T_{c}$</p>
<p>其中， $T_{start}$ 是该组指令总的启动时间(时钟周期个数)。<br>如果表示成时钟周期个数,则</p>
<p>$T_{all} &#x3D; T_{start} +mn$ 拍。</p>
<p>后面主要用这个公式来计算向量指令序列的执行时间。</p>
<p><img src="https://api2.mubu.com/v3/document_image/a592bb21-aab4-44a8-943d-50b91b1516bd-16175743.jpg" alt="2"></p>
<h5 id="2-每秒浮点运算数目MFLOP（或-一个浮点运算的时间）"><a href="#2-每秒浮点运算数目MFLOP（或-一个浮点运算的时间）" class="headerlink" title="2.每秒浮点运算数目MFLOP（或 一个浮点运算的时间）"></a>2.每秒浮点运算数目MFLOP（或 一个浮点运算的时间）</h5><h5 id="4-向量流水线的最大性能-R-infty"><a href="#4-向量流水线的最大性能-R-infty" class="headerlink" title="4.向量流水线的最大性能$R \infty$"></a>4.向量流水线的最大性能$R \infty$</h5><h5 id="5-半性能向量长度-n-1-x2F-2"><a href="#5-半性能向量长度-n-1-x2F-2" class="headerlink" title="5.半性能向量长度 $n_1&#x2F;2$"></a>5.半性能向量长度 $n_1&#x2F;2$</h5><h5 id="6-向量长度临界值-n-v"><a href="#6-向量长度临界值-n-v" class="headerlink" title="6.向量长度临界值 $n_v$"></a>6.向量长度临界值 $n_v$</h5><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>向量处理机方式<ul>
<li>横向纵向纵横</li>
</ul>
</li>
<li>典型结构</li>
</ul>
<h2 id="第五章-指令级并行及其开发——硬件方法"><a href="#第五章-指令级并行及其开发——硬件方法" class="headerlink" title="第五章 指令级并行及其开发——硬件方法"></a>第五章 指令级并行及其开发——硬件方法</h2><blockquote>
<p>指令级并行的概念<br>相关与指令级并行<br>指令的动态调度<br>动态分支预测技术<br>多指令流出技术</p>
</blockquote>
<h3 id="指令级并行基础概念"><a href="#指令级并行基础概念" class="headerlink" title="指令级并行基础概念"></a>指令级并行基础概念</h3><p>分为两类（实际应用中，两者往往会相结合）</p>
<ol>
<li>基于硬件的动态开发方法(程序运行过程中)</li>
<li>基于软件的静态开发方法</li>
</ol>
<p>之前第三章已经介绍了编译器解决的方法（软件层面，静态的），本章来讨论<strong>动态调度代码的硬件方法</strong>。</p>
<p>指令级并行（ILP）是指令间存在的一种并行性，使计算机可以并行执行两条及以上的指令。</p>
<p>流水线处理机的实际 CPI:$CPI_{流水线} &#x3D; CPI_{理想} +停顿_{结构冲突}+停顿_{数据冲突}+停顿_{控制冲突}$</p>
<p><strong>基本程序块</strong>：如果一串连续的代码除了入口和出口以外,没有其他的分支指令和转入点,则称之为一个基本程序块(Basic Block)。</p>
<blockquote>
<p>由于程序中往往每隔4~7条指令就会有一个分支,而且指令之间还可能存在相关,因此在基本程序块中能开发出的并行性是很有限的,很可能比基本块的平均大小要小得多。为了明显地提高性能﹐必须跨越多个基本块开发ILP。</p>
</blockquote>
<p>相关有三种类型</p>
<ul>
<li>数据相关</li>
<li>名相关</li>
<li>控制相关</li>
</ul>
<p><strong>流水线冲突(hazard)</strong> 是指对于具体的流水线来说,由于相关的存在,使得指令流中的下一条指令不能在指定的时钟周期执行。</p>
<p>流水线冲突有三种类型</p>
<ul>
<li>结构冲突:因硬件资源冲突造成的</li>
<li>数据冲突:由数据相关和名相关造成的</li>
<li>控制冲突:由控制相关造成的</li>
</ul>
<p>数据相关限制了所能开发的ILP，可以从两方面来克服这些限制</p>
<ol>
<li>保持相关，但避免发生冲突（<strong>指令调度</strong>）</li>
<li>进行代码变换，消除相关</li>
</ol>
<p><strong>程序顺序</strong>(Program Order)是指:由原来程序确定的在完全串行方式下指令的执行顺序。但是,并不需要在所有存在相关的地方都保持程序顺序。</p>
<p>控制相关并不是一个必须严格保持的关键属性。为了保证程序执行的正确的，必须保持的最关键的两个属性是：<strong>数据流</strong>和<strong>异常行为</strong></p>
<ul>
<li>保持异常行为(Exception Behavoir)<br>无论怎么改变指令的执行顺序,都不能改变程序中异常的发生情况。即原来程序中是怎么发生的,改变执行顺序后应该还是那样发生。这个条件经常被弱化为:指令执行顺序的改变不能导致程序中发生新的异常。</li>
<li>数据流(Data Flow)<br>是指数据值从其产生者指令到其消费者指令的实际流动。分支指令使得数据流具有动态性,因为一条指令有可能数据相关于多条先前的指令。分支指令的执行结果决定了哪条指令真正是所需数据的产生者。</li>
</ul>
<p>有时,不遵守控制相关既不影响异常行为,也不改变数据流。这时就可以大胆地进行指</p>
<h3 id="动态调度的基本思想"><a href="#动态调度的基本思想" class="headerlink" title="动态调度的基本思想"></a>动态调度的基本思想</h3><p>5段流水：指令按序流出、按序执行</p>
<p>第三章的流水线中，<strong>结构冲突和数据冲突</strong>都是在ID<strong>译码段</strong>进行检测的，流出条件为：既没有结构冲突也没有数据冲突</p>
<p>现把指令流出的工作拆成两步</p>
<ol>
<li>检测结构冲突</li>
<li>等待数据冲突消失</li>
</ol>
<p><strong>只要检测到没有结构冲突</strong>，就可以让指令流出，且操作数一旦就绪就可以立刻执行<br>也就是说，把前面的5段露水ID段细分成两个阶段:</p>
<ol>
<li>流出（issue），指令译码，并检查是否存在结构冲突</li>
<li>读操作数：等待数据冲突消失，然后读操作数</li>
</ol>
<p>在读操作数段可能停顿和互相跨越</p>
<p>动态调度的流水线支持多条指令同时处于执行当中，这里我们假设具有多个功能部件。</p>
<p>动态调度的处理机：对于一条会产生异常的指令来说，只有当处理机确切地知道该指令将被执行时，才允许它产生异常行为。</p>
<p>不精确异常(Imprecise Exception)是指:当执行指令i导致发生异常时,处理机的现场(状态)与严格按程序顺序执行时指令i的现场不同。<br>反之,如果发生异常时,处理机的现场跟严格按程序顺序执行时指令i的现场相同,就称为精确异常(Precise Exception)。<br>不精确异常使得<strong>在异常处理后难以接着继续执行程序</strong>。</p>
<p>发生不精确异常的原因:</p>
<ol>
<li>流水线可能已经执行完按程序顺序是位于指令i之后的指令</li>
<li>流水线可能还没完成按程序顺序是指令i之前的指令</li>
</ol>
<h3 id="典型的动态调度算法"><a href="#典型的动态调度算法" class="headerlink" title="典型的动态调度算法"></a>典型的动态调度算法</h3><ol>
<li>记分牌算法</li>
<li>Tomasulo算法（比前者改进了很多）</li>
</ol>
<blockquote>
<p>基本上每次都考这两算法，其中第二个算法考的概率大很多（90%）</p>
</blockquote>
<h4 id="记分牌scoreboard"><a href="#记分牌scoreboard" class="headerlink" title="记分牌scoreboard"></a>记分牌scoreboard</h4><p>维护三张表：分别记录指令的执行状态、功能部件状态、寄存器状态以及数据相关关系等。所考虑指令有流出、读操作数、执行、写回四个执行状态。</p>
<ol>
<li>记录指令的执行状态 <strong>这个表是最重要的，一定不能出错</strong><br>记录（已取指指令）执行状态。</li>
<li>功能部件状态<br>记录各功能部件的状态</li>
<li>结果（目标）寄存器状态表<br>指出哪个功能部件将把结果写入该目标寄存器</li>
</ol>
<p>它把前述5段流水线中的译码段ID分解成了两个段:<strong>流出和读操作数</strong>﹐以避免当某条指令在ID段被停顿时挡住后面无关指令的流动。</p>
<ul>
<li>已经执行完成的指令可以不用画在指令状态表中</li>
<li>有的时候，乘法部件和除法部件是合在一起的</li>
<li>加法部件既可以做加法也可以做减法</li>
</ul>
<blockquote>
<p>一般第一列都是目的寄存器，功能部件状态表里面的寄存器Fijk的顺序跟指令的顺序一样</p>
</blockquote>
<h5 id="指令状态表"><a href="#指令状态表" class="headerlink" title="指令状态表"></a>指令状态表</h5><h5 id="功能部件表"><a href="#功能部件表" class="headerlink" title="功能部件表"></a>功能部件表</h5><ul>
<li>Busy：忙标志，Yes表示已流出，未写入（完成）。</li>
<li>no：已完成或未流出。</li>
<li>Op：正在<strong>或将要</strong>执行的操作。 Fi：目的寄存器（编号）。</li>
<li>Fj，Fk：两个源寄存器（编号）；</li>
<li>Qj，Qk：向两个源寄存器Fj、Fk写数据的功能部件。</li>
<li>Rj，Rk：标志位，“yes”：Fj，Fk中的操作数可用——<strong>就绪且未被取走（已产生但未读）</strong>。否则，“no”。</li>
</ul>
<h5 id="结果寄存器状态表"><a href="#结果寄存器状态表" class="headerlink" title="结果寄存器状态表"></a>结果寄存器状态表</h5><p>哪个功能部件将把结果写入该目标寄存器。<br>F0,F2,F8,F10: 目标寄存器 （F4,F6 :空闲，完成或未流出）</p>
<h5 id="每条指令的执行过程"><a href="#每条指令的执行过程" class="headerlink" title="每条指令的执行过程"></a><strong>每条指令的执行过程</strong></h5><ol>
<li>流出（Issue，IS）：若功能部件空闲，目的寄存器可用（无WW冲突），就流出指令，并修改记分牌内记录。否则不流出。检测目的寄存器可用性，解决了WW冲突和结构冲突。</li>
<li>读操作数（Read Operands，RO） ：若源操作数可用（就绪且未读），就读出并执行。否则，等待写完成后读出（锁定）</li>
<li>执行：取到操作数后功能部件开始执行（可能乱序执行）产生出结果后，通知记分牌已完成执行。<br>在浮点流水线中，这一段可能要占用多个时钟周期。<br>其他指令如不与正在执行或被锁定指令相关，可提前执行或完成。</li>
<li>执行部件完成后，检测目标寄存器，以避免RW冲突。<ol>
<li>如检测到RW冲突，不许该指令将结果写到目标寄存器。这发生在以下情况：前面的某条指令还没有读取该操作数（即前指令的源操作数寄存器是本指令的目标寄存器）。在这种情况下，记分牌必须等待，直到该冲突消失</li>
<li>如果不存在RW冲突（或冲突已消失），把结果写入目的寄存器，并释放该指令使用的所有资源（指令乱序执行成为可能）， 避免了RW冲突。</li>
</ol>
</li>
</ol>
<h5 id="指令执行过程的冲突分析"><a href="#指令执行过程的冲突分析" class="headerlink" title="指令执行过程的冲突分析"></a>指令执行过程的冲突分析</h5><ul>
<li>WW冲突会导致记分牌在流出阶段停顿。</li>
<li>RW冲突会导致记分牌在写结果阶段停顿。</li>
<li>真相关引起的WR冲突会导致记分牌在读操作数阶段停顿。</li>
<li>资源冲突会导致记分牌在流出阶段停顿。</li>
</ul>
<p>通过记分牌控制：避免了 WW、WR、RW冲突及结构冲突。</p>
<blockquote>
<p>这里有两道例题，见ppt</p>
</blockquote>
<h5 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法*"></a>具体算法*</h5><h5 id="记分牌算法的限制性"><a href="#记分牌算法的限制性" class="headerlink" title="记分牌算法的限制性"></a>记分牌算法的限制性</h5><ul>
<li>记分牌并不能高效处理WW，WR和RW，只能通过停顿保证指令动态调度的正确性。</li>
<li>程序代码中可开发的并行性，即是否存在可以并行执行的不相关的指令。</li>
<li>记分牌的容量<ul>
<li>决定了流水线能在多大范围内寻找不相关指令。</li>
<li>流水线中可以同时容纳的指令数量称为指令窗口。</li>
</ul>
</li>
<li>功能部件的数目和种类。<ul>
<li>功能部件的总数决定了结构冲突的严重程度。</li>
</ul>
</li>
<li>反相关和输出相关<ul>
<li>引起记分牌中的WW，RW冲突</li>
</ul>
</li>
</ul>
<h3 id="托马苏格-Tomasulo-算法"><a href="#托马苏格-Tomasulo-算法" class="headerlink" title="托马苏格(Tomasulo)算法"></a>托马苏格(Tomasulo)算法</h3><p>电脑没电了，寄，下课再说</p>
]]></content>
      <categories>
        <category>笔记 - 计算机系统结构</category>
      </categories>
      <tags>
        <tag>course</tag>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
</search>
